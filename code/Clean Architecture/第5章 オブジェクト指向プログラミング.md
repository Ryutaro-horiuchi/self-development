## 依存関係逆転

- 典型的な呼び出しツリー
    - main関数が上位レベルの関数を呼び、それが中間レベルの関数を呼び出し、それが下位レベルの関数を呼び出す。→ ソースコードの依存関係は制御の流れとなっている。
    - 上位レベルのモジュールが、低レベルのモジュールに依存している
        
        ```mermaid
        graph TD
          Main --> HL1 --> ML1
          Main --> HL2
          HL1 --> ML2
          ML1 --> LL1
          ML1 --> LL2
          ML2 --> LL3
          ML2 --> LL4
        ```
        
    - mainが上位レベルの関数の一つを呼ぶためには、その関数を含むモジュールの名前を言及する必要がある
        - Ex. Python  `import HL1`
- ポリモーフィズム
    - HL1がモジュールML1にあるf関数をインターフェイス経由で呼び出している
        
        ```mermaid
        graph LR
          HL1 --> Interface-関数f
          HL1 -.-> ML1-関数f
          ML1-関数f --> Interface-関数f
        ```
        
        - 依存関係逆転の法則に従っている
            - 高レベルモジュールは低レベルモジュールに依存してはならない。両者は抽象に依存すべきである。
            - 抽象は具体的なものに依存してはならない。具体的なものが抽象に依存すべきである。
        - HL1モジュールが低いモジュールであるML1に依存せず、interfaceを挿入することによって、抽象に依存できている
        - システムの流れ関係なく、制御の方向を絶対的に制御できる
- ポリモーフィズムでで切ること
    - UI, ビジネスルール, データベースの3つのコンポーネントに分けることができ、データベースとUIをビジネスルールに依存させることができる
        
        ```mermaid
        graph LR
          UI --> BusinessRules
          BusinessRules -.-> UI
          Database --> BusinessRules
          BusinessRules -.-> Database
        ```
        
        - UIとデータベースをビジネスルールのプラグインにすることができる
            - 3つそれぞれを異なるコンポーネントやデプロイメントユニットにまとめることができる
            - コンポーネントのソースコードを変更しても、そのコンポーネントだけを再デプロイすれば良い。これが独立デプロイである
            - モジュールを個別にデプロイできるなら、別々のチームが個別に開発できる。これが、独立開発可能性である
    
    ## まとめ
    
    - オブジェクト指向とは何か。
        - ソフトウェアアーキテクトにとっては、「ポリモーフィズムを使用することで、システムにある全てのソースコードの依存関係を絶対的に制御する能力」である
        - プラグインアーキテクチャを作成できる
            - 上位レベルの方針を含んだモジュールを、下位レベルの詳細を含んだモジュールから独立させる
            - 下位レベルの詳細はプラグインモジュール隣、上位レベルの方針を含んだモジュールとは独立して、デプロイおよび開発することが可能となる