# 非循環依存関係の原則(ADP)

---

## 二日酔い症候群

- 筆者の造語。自分の担当した機能が他の開発者の変更によって、正常に動作しなくなること
- 大規模なプロジェクトや開発チームだと往々にしてあり、ビルドできない状態が何週間も続くこともある

## 二日酔い症候群の対策

### 週次ビルド

- プロセス
    - 週で最初の4日間は、他の開発者の変更を無視し自身の作業に集中する
    - 最後の1日は、全員の変更を統合してビルドする
- 開発の規模が大きくなるほど、統合作業に要する時間が延びていく。このシナリオの行き着く先は危機的状況である

### 非循環依存関係の原則(ADP)

- プロセス
    - 開発環境をリリース可能なコンポーネントに分割し、コンポーネントごとに開発者(あるいは開発チーム)を割り当てる
    - 自分の担当するコンポーネントが動くようになったら、リリース番号を割り当てて、他のチームが利用できるディレクトリに移動する
    - コンポーネントの新しいリリースが使えるようになったら、他のチームはそのリリースをすぐに導入するかどうかを自分たちで判断できる。すぐには導入しないなら、これまでのリリースを使い、導入する準備が整った時点で、新しいリリースを使い始めることができる
    - プロセスをきちんと機能させるには、**循環依存**がないようコンポーネントの依存構造をきちんと管理しておく必要がある。

### プロセス図面

p127 図 14-1 を添付

- ポイント
    - コンポーネントの依存構造は有向グラフ構造になっている
    - どのコンポーネントからスタートしても、矢印を辿って元のコンポーネントに戻ることができない。循環構造が存在しない
- コンポーネント新しいリリース導入例
    - Presentersの開発チームが新しいリリースを公開したとする
        - このリリースの影響を受けるのは、矢印から見てViewとMainである
        - これらのコンポーネントの開発担当者は、どこかのタイミングで自分たちの環境にPresentersの新しいリリースを統合することになる
    - Mainがリリースされた時は、他のコンポーネントに何も影響を及ぼさない
- システムリリース手順例
    - Entitiesをコンパイルしてテスト、リリースする。
    - 次にDatabaseと、Interactorsを同じように進める
    - その後、PresentersとViewとControllersをリリースすr
    - 続けて、Authorizerをリリースする
    - 最後にリリースするのはMain

### 循環依存の影響

- 図14-2 を添付
- 新たな要件が追加されて、Entitiesに含まれるUserクラスがAuthorizerにあるPermissionsクラスを使わざるを得なくなった。この変更により、循環依存が発生する
- 影響
    - Databaseの開発者は、これまでのリリースではEntitiesとの互換性を維持することを考えておけばよかった。しかし、新たに登場した循環依存により、さらにAuthorizerとの互換性も考慮する必要が出てくる。さらにAuthorizerはInteractorsにも依存しており、これまでの比べてDatabaseがリリースするのが難しくなった
    - Entitiesのテスト時は、AuthorizerとInteractorsの両方を統合してビルドする必要がある
- 循環依存があると、コンポーネントを切り離すのが難しくなる

### 循環依存の解消

どのような状況でも、循環依存を排除することができる。以下の2つがよく使われる

1. 依存関係逆転の原則(DIP)を適用する
    1. 図14-3を添付
    - Userが必要とするメソッドを持つインターフェイスを作れば良い
    - このインターフェイスをEntitiesに入れて、Authorizerからはそれを継承する
    これで、EntitiesとAuthorizerの依存関係が逆転するので、循環依存は解消される
2. EntitiesとAuthorizerの両方が依存する新しいコンポーネントを作る
    1. 図14-4を添付

# 安定依存の原則(SDP)

安定度の高い方向に依存すること

## 安定度とは

- ソフトウェアを変更しづらくする(安定させる)要素は、多数のソフトウェアコンポーネントから依存されるようにする
- 多数のコンポーネントから依存されたコンポーネントは非常に安定している。
    - 少し変更するだけでも他のコンポーネントとの調整が必要になる
- 図14-5
    - 安定したコンポーネント
    - 独立コンポーネント
        - 他のコンポーネントに依存しておらず、外部要因で変更が必要になることはないコンポーネントのこと
- 図14-6
    - 不安定なコンポーネント
    - 従属コンポーネント
        - 他のコンポーネントに依存しており、外部要因による変更の可能性があるコンポーネントのこと

## 安定度の指標

- 方法として下記の数を調べて導き出すのが一つの方法
    - コンポーネント内のクラスに依存している外部のコンポーネントのクラスの数
        - ファン・イン、依存入力数と呼ばれる
    - 外部のコンポーネントに依存している、内部のコンポーネントのクラスの数
        - ファン・アウト、依存出力数と呼ばれる
    - I(Instability)不安定さ。
        
        ```python
        I = ファン・アウト ÷ (ファン・イン　+ ファンアウト)
        ```
        
- 図14-7
    - I は1/4となる
        - ファン・インは3、ファン・アウトは1
- 不安定さが1(最も不安定)となるのは、そのコンポーネントに依存するコンポーネントが一つもなく(ファン・イン = 0)、そのコンポーネントが他のコンポーネントに依存している(ファン・アウト > 0)場合
- 不安定さが0(最も安定)となるのは、そのコンポーネントに依存するコンポーネントが存在し(ファン・イン > 0)、そのコンポーネントがどのコンポーネントにも依存していないファン・アウト = 0)の場合
- 安定依存の原則は、コンポーネントの I を依存するコンポーネントの I よりも大きくすべきというもの
    - → より安定しているものに依存すべきということ

## 全てのコンポーネントに高い安定度を求める必要はない

- 全てのコンポーネントが最大限に安定した状態となっていたら、システムには手を加えられない。
- 高い安定度を全てに求めるのではなく、安定度の低いコンポーネントも安定度の高いコンポーネントもあるのが理想的な構成
- 図14-8 理想的な構成
    - 安定度の低いコンポーネントを上へ、安定度の高いコンポーネントを下に書くと、SDPに違反している場合は矢印が上に向くので、違反しているコンポーネントがすぐにわかるようになる
- 図14-9 安定依存の原則 違反
    
    Stableコンポーネントの I の値は、Flexibleコンポーネントに比べて小さい。
    
    → (安定しているコンポーネントが不安定なコンポーネントに依存してしまっている)
    
    対策としてDIPを使用して、Flexbleないの依存しているクラスのインターフェイスを持つクラスを定義してそれを別コンポーネントとして切り出す。