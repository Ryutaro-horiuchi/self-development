# 非循環依存関係の原則(ADP)

---

## 二日酔い症候群

- 筆者の造語。自分の担当した機能が他の開発者の変更によって、正常に動作しなくなること
- 大規模なプロジェクトや開発チームだと往々にしてあり、ビルドできない状態が何週間も続くこともある

## 二日酔い症候群の対策

### 週次ビルド

- プロセス
    - 週で最初の4日間は、他の開発者の変更を無視し自身の作業に集中する
    - 最後の1日は、全員の変更を統合してビルドする
- 開発の規模が大きくなるほど、統合作業に要する時間が延びていく。このシナリオの行き着く先は危機的状況である

### 非循環依存関係の原則(ADP)

- プロセス
    - 開発環境をリリース可能なコンポーネントに分割し、コンポーネントごとに開発者(あるいは開発チーム)を割り当てる
    - 自分の担当するコンポーネントが動くようになったら、リリース番号を割り当てて、他のチームが利用できるディレクトリに移動する
    - コンポーネントの新しいリリースが使えるようになったら、他のチームはそのリリースをすぐに導入するかどうかを自分たちで判断できる。すぐには導入しないなら、これまでのリリースを使い、導入する準備が整った時点で、新しいリリースを使い始めることができる
    - プロセスをきちんと機能させるには、**循環依存**がないようコンポーネントの依存構造をきちんと管理しておく必要がある。

### プロセス図面

![IMG_3692.jpeg](attachment:681996e9-8514-4a42-b860-d547658cef58:IMG_3692.jpeg)

- ポイント
    - コンポーネントの依存構造は有向グラフ構造になっている
    - どのコンポーネントからスタートしても、矢印を辿って元のコンポーネントに戻ることができない。循環構造が存在しない
- コンポーネント新しいリリース導入例
    - Presentersの開発チームが新しいリリースを公開したとする
        - このリリースの影響を受けるのは、矢印から見てViewとMainである
        - これらのコンポーネントの開発担当者は、どこかのタイミングで自分たちの環境にPresentersの新しいリリースを統合することになる
    - Mainがリリースされた時は、他のコンポーネントに何も影響を及ぼさない
- システムリリース手順例
    - Entitiesをコンパイルしてテスト、リリースする。
    - 次にDatabaseと、Interactorsを同じように進める
    - その後、PresentersとViewとControllersをリリースすr
    - 続けて、Authorizerをリリースする
    - 最後にリリースするのはMain

### 循環依存の影響

![IMG_3693.jpeg](attachment:6b18e1e4-652d-44e8-8e09-0eb6c3a9de61:IMG_3693.jpeg)

- 新たな要件が追加されて、Entitiesに含まれるUserクラスがAuthorizerにあるPermissionsクラスを使わざるを得なくなった。この変更により、循環依存が発生する
- 影響
    - Databaseの開発者は、これまでのリリースではEntitiesとの互換性を維持することを考えておけばよかった。しかし、新たに登場した循環依存により、さらにAuthorizerとの互換性も考慮する必要が出てくる。さらにAuthorizerはInteractorsにも依存しており、これまでの比べてDatabaseがリリースするのが難しくなった
    - Entitiesのテスト時は、AuthorizerとInteractorsの両方を統合してビルドする必要がある
- 循環依存があると、コンポーネントを切り離すのが難しくなる

### 循環依存の解消

どのような状況でも、循環依存を排除することができる。以下の2つがよく使われる

1. 依存関係逆転の原則(DIP)を適用する
    
    ![IMG_3694.jpeg](attachment:8dfae0be-c6ea-4e1d-9c64-998219e99b29:IMG_3694.jpeg)
    
    - Userが必要とするメソッドを持つインターフェイスを作れば良い
    - このインターフェイスをEntitiesに入れて、Authorizerからはそれを継承する
    これで、EntitiesとAuthorizerの依存関係が逆転するので、循環依存は解消される
2. EntitiesとAuthorizerの両方が依存する新しいコンポーネントを作る
    
    ![IMG_3695.jpeg](attachment:d581a508-3dd6-4cd6-91f8-65cb8c7b1ea2:IMG_3695.jpeg)
    

# 安定依存の原則(SDP)

安定度の高い方向に依存すること

## 安定度とは

- ソフトウェアを変更しづらくする(安定させる)要素は、多数のソフトウェアコンポーネントから依存されるようにする
- 多数のコンポーネントから依存されたコンポーネントは非常に安定している。
    - 少し変更するだけでも他のコンポーネントとの調整が必要になる

### 安定したコンポーネント

![IMG_3696.jpeg](attachment:a8e0156a-4b72-488c-a5cd-fd8da253e1cc:IMG_3696.jpeg)

- 独立コンポーネント
    - 他のコンポーネントに依存しておらず、外部要因で変更が必要になることはないコンポーネントのこと

### 不安定なコンポーネント

![IMG_3697.jpeg](attachment:072cb0c6-4535-42f9-bcfd-1422cb01b9cb:IMG_3697.jpeg)

- 従属コンポーネント
    - 他のコンポーネントに依存しており、外部要因による変更の可能性があるコンポーネントのこと

## 安定度の指標

- 方法として下記の数を調べて導き出すのが一つの方法
    - コンポーネント内のクラスに依存している外部のコンポーネントのクラスの数
        - ファン・イン、依存入力数と呼ばれる
    - 外部のコンポーネントに依存している、内部のコンポーネントのクラスの数
        - ファン・アウト、依存出力数と呼ばれる
    - I(Instability)不安定さ。
        
        ```python
        I = ファン・アウト ÷ (ファン・イン　+ ファンアウト)
        ```
        

### 例

![IMG_3698.jpeg](attachment:e418f4a3-313c-486a-bff3-290f15bfb158:IMG_3698.jpeg)

- コンポーネントCcの I は1/4となる
    - ファン・インは3、ファン・アウトは1
- 不安定さが1(最も不安定)となるのは、そのコンポーネントに依存するコンポーネントが一つもなく(ファン・イン = 0)、そのコンポーネントが他のコンポーネントに依存している(ファン・アウト > 0)場合
- 不安定さが0(最も安定)となるのは、そのコンポーネントに依存するコンポーネントが存在し(ファン・イン > 0)、そのコンポーネントがどのコンポーネントにも依存していないファン・アウト = 0)の場合
- 安定依存の原則は、コンポーネントの I を依存するコンポーネントの I よりも大きくすべきというもの
    - → より安定しているものに依存すべきということ

## 全てのコンポーネントに高い安定度を求める必要はない

- 全てのコンポーネントが最大限に安定した状態となっていたら、システムには手を加えられない。
- 高い安定度を全てに求めるのではなく、安定度の低いコンポーネントも安定度の高いコンポーネントもあるのが理想的な構成

### 理想的な構成

![IMG_3699.jpeg](attachment:2ce56f16-ed52-40db-a5f4-c37a649072b9:IMG_3699.jpeg)

- 安定度の低いコンポーネントを上へ、安定度の高いコンポーネントを下に書くと、SDPに違反している場合は矢印が上に向くので、違反しているコンポーネントがすぐにわかるようになる

### 安定依存の原則 違反

![IMG_3700.jpeg](attachment:5791eb27-f818-4c85-b621-dfb05a1faa57:IMG_3700.jpeg)

Stableコンポーネントの I の値は、Flexibleコンポーネントに比べて小さい。

→ (安定しているコンポーネントが不安定なコンポーネントに依存してしまっている)

対策としてDIPを使用して、Flexible内の依存しているクラスのインターフェイスを持つクラスを定義してそれを別コンポーネントとして切り出す。

# 安定度・抽象度等価の原則(SAP)

- 安定度と抽象度の関係についての原則
    - 安定度の高いコンポーネントは抽象度も高くあるべき。一方、安定度の低いコンポーネントは具体的なものであるべきだとしている
        - つまり、安定度を高くしたいのであれば、拡張できるようにインターフェイスと抽象クラスで構成すべき
- SAPと安定依存の原則(SDP)の組み合わせが、コンポーネント版の依存関係逆転の原則(DIP)に相当する
    - → 抽象度が高くなる方向に依存すべき

## 抽象度の計測

- Nc : コンポーネント内のクラスの総数
- Na : コンポーネント内の抽象クラスとインターフェイスの総数
- A : 抽象度。 A = Na ÷ Nc

### 抽象度のグラフ

![IMG_3701.jpeg](attachment:30a527d0-7ec1-4ba6-95ee-0d8cdb8760bd:IMG_3701.jpeg)

- 縦軸をA(抽象度)。横軸を I (不安定度)
- 安定度と抽象度が共に最大のコンポーネントは、グラフの左上にあたる(0, 1)にプロットされる
- 安定度と抽象度が共に最低のコンポーネントは、グラフの右下にあたる(1, 0)にプロットされる
- 全てのコンポーネントを(0,1)か(1,0)のいずれかに強制することは程度の問題があるので不可能だが、コンポーネントがプロットされるべきではない範囲を見つけることで、コンポーネントがI/Aグラフのどのあたりにあれば妥当かを定めることはできる。

### プロットされるべきではない範囲

![IMG_3702.jpeg](attachment:74825da5-b2bf-4eb9-8652-6e0e57353f97:IMG_3702.jpeg)

- 苦痛ゾーン (0, 0)の近辺
    - 安定度が最高の具象コンポーネント
    - 柔軟性に欠けており、抽象度が低いため拡張することができない。安定度が高いので変更も難しい
    - データベーススキーマは苦痛ゾーンの一例として挙げられる。スキーマは変更されやすく、かつ抽象度が低くて他のコンポーネントから依存されまくっている
- 無駄ゾーン(1, 1)の近辺
    - 最大限に抽象化されているが、そのコンポーネントに依存するコンポーネントが存在しない。無意味である
- 除外すべきゾーンを回避する(主系列)
    - プロットされるべきではない2つのゾーンを回避するには、(1,0)と(0,1)を繋ぐ直線になる。この直線を主系列と呼ぶ
    - 主系列上にあるコンポーネントは、その安定度に対して抽象的すぎず、その抽象度に対して不安定すぎないものとなる
    - コンポーネントは、この主系列上に載せるか、そこに近づけるようにすると良い
    - 主系列からの距離
        - D(距離) : |A + I - 1|
            - これは0以上1以下の値となり、0の場合は主系列であること。値が1の場合は、主系列から最も離れた状態を指す
            
            ![IMG_3703.jpeg](attachment:48228924-6081-4756-90c4-2218cc3fa598:IMG_3703.jpeg)
            
            - 大半のコンポーネントが主系列上にあるが、平均からの距離が標準偏差(z=1)を超えているコンポーネントも存在することがわかる
            
            ![IMG_3704.jpeg](attachment:c04b0732-75db-4726-b475-d98f3b525ad0:IMG_3704.jpeg)
            
            - 個々のコンポーネントについてD値の推移を記録すること