p153

try catch filnallyは最初に書く

単体テストを書いて例外を送出するテストを書き、そのあとで、テストが成功するように振る舞いを追加する

- チェック例外
    - 主に**予測可能なエラー**に対応し、ファイル操作やデータベース接続など、外部システムとのやり取りで頻繁に発生する可能性がある
    - コンパイル時に処理を強制されるため、プログラムがエラー処理を逃さないようにする役割を持っている
    
    - C#, Python, Rubyには存在しない
    - Ex.
        - ファイルが見つからなかったり、読み取り権限がなかった場合(IOException)
        - データベース操作中に発生する例外で、データベース接続やSQLクエリの実行で問題があった場合(SQLException)
- 非チェック例外
    - 非チェック例外は**プログラミング上のミス**で発生するエラーに対応し、主にランタイムエラーを含みます
    - コンパイル時に処理を強制されません。コードの不備や想定外の状況によって発生するため、予測が難しい
    - Ex.
        - オブジェクトが`null`であるにも関わらず、そのメソッドやフィールドにアクセスしようとした場合に発生します(NullPointerException)
        - 配列の範囲外のインデックスにアクセスしようとした場合に発生します。(ArrayIndexOutOfBoundsException)

p154

例外で状況を伝える

- スタックトレースからは、失敗した処理の意図まではわからない
- 十分な情報を持ったエラーメッセージを作成し、それを例外に含める
    - 失敗した処理、失敗の種類
    - catchした場所で、ロギングを行うために必要な情報を渡す

呼び出し元が必要とする例外クラスを定義する

- Ex. サードパーティのライブラリ
    - ダメな例: 例外の送出をそのまま定義している
        
        ```java
        ACMEPort port = new ACMEPort(12);
        
        try {
        	port.open();
        } catch(DeviceResponseException e) {
        	reportportError(e);
        	logger.log("Device response Exception", e);
        } catch (ATM1212UnlockedException e) {
        	reportportError(e);
        	logger.log("Unlock exception", e);
        } finally {
        	...
        }
        ```
        
    - 良い例: 例外の送出をラップする
        
        ```java
        public class LocalPort {
        	private ACMEPort innterPort;
        	
        	public LocalPort(int portNumber) {
        		innerPort = new ACMEPort(portNumber)
        	}
        	
        	public void open() {
        		try {
        			innerPort.open();
        		} catch(DeviceResponseException e) {
        			throw new PortDeviceFailure(e);
        		} catch (ATM1212UnlockedException e) {
        			throw new PortDeviceFailure(e);
        		} finally {
        			...
        		}
        	}
        	
        	
        	
        	LocalPort port = new LocalPort(12);
        	
        	try {
        		port.open();
        	} catch (PortDeviceFailure e) {
        		reportError(e);
        		logger.log(e.getMessage(), e);
        	} finally {
        		...
        	}
        ```
        
- サードパーティAPIをラップするのは、ベストプラクティスの一つ
    - ラップすれば、依存性を最小限とすることができる
    - 特定のAPIの設計に依存しなくなるため、ライブラリの移行も容易になる