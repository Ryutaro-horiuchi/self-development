## TDD三原則

1. 失敗する単体テストのコードを書く前に、製品のコードを書いてはならない
2. コンパイルが通り、適切に失敗する単体テストができるまでは、次の単体テストを書いてはならない
3. 原則失敗している単体テストが多るまで、次の製品コードを書いてはならない

→ テストコードと製品コードはほぼ同時に書く

## テストを綺麗に保つ

- テストコードも製品コードと同じぐらい重要で品質を保つ必要がある
    - 汚いテストは、テストがないことと同値
    - コードの変更があったときにテストコードも変更する必要があるが、汚いとテストコード自体の修正に時間がかかってしまう

### テストがないと

- コードの変更が期待通りに動くのかがわからない
- ある変更がシステムの別の部分を壊していないか確認することができない

### テストは、xxx性を可能とする

- コードの柔軟性、保守容易性、再利用性を維持、提供するのは**単体テスト**
    - テストがあれば、恐れずに変更できる
    - 製品コードを網羅する単体テストスイートは、アーキテクチャと設計を綺麗にするためのキー

## クリーンテスト

- 洗練されたテストとは、読みやすさ
    - 読みやすいテストとは、構築 - 操作 - 検査の3パターンで表現されていること
        - 構築
            - テストデータの構築
        - 操作
            - テストデータに操作を行う
        - 検査
            - 操作結果が期待される結果になっているか

### ドメイン特化テスト言語

- 用意されているAPIをそのまま使うのではなく、APIを使った関数とユーティリティを作成してテストをもっと簡単に読み書きできるようにする
    - これらの関数はとユーティリティは、テストのために特化したテスト言語である

## 1つにのテストに一つのアサート

1つのユニットテストには1つのアサート文までとするべき

- コードの重複が生みやすい
    
    → クラスのテンプレートメソッドパターンを使用して綺麗にすることは可能だが、大袈裟過ぎる
    
- 筆者としては2つ以上のアサート文を入れて問題ないと考えている。重要なのは、それが少なくするべき
    
    <aside>
    💡
    
    1つのテストでは1つの概念を扱う
    
    </aside>
    

## F.I.R.S.T

クリーンテストは、上記の頭文字に示される5つの規則に従う

### 高速である Fast

- 実行に時間がかかると、テストを頻繁に実行する気が削がれてしまう
    - 頻繁に実行しないと、早い時期(修正が容易な時期)に問題に気づくことができなくなる

### 独立している Independent

- テストはお互いに関連すべきではない
    - あるテストが後続のテストの前提条件を準備してはいけない
        - 前提条件を準備してしまうと、そのテストの失敗が後続のテストの失敗を生み出してしまう

### 再現性がある Repeatbale

- どんな環境でも再現可能でなければならない
    - 本番環境、品質保証環境、インターネットが繋がらないPC環境でも

### 自己検証可能 （Sef-Validating）

- 成功か失敗かのどちらかを出力すべき
    - 長いファイルを読まないと、テストの結果がわからないようなテストは避けるべき
        - 例えば、長いテキストファイルを比べてテストが成功したかどうかがを確認するようなテストは、判定が属人的になってしまう

### 適時性がある (Timely)

- テストは必要なときにすぐ書けなければならない
    - 製品コードを書く直前に単体テストは書かれ、このテストが通るように製品コードを書く必要がある
- 製品コードの後でテストを書こうとすると、製品コードがテストしづらいものになっていることに気づくことになるかも
    
    → その中のいくつかは、あまりにテストが困難だと結論付けることになるかも
    
    → テストが困難な製品コードを設計してしまうかも