## 関数は小さく

---

- 関数は小さくすること。第一の原則は小さくせよ。第二の原則はさらに小さくせよ
    - 関数の長さが20行に達するなど、ほとんどないようにすべき

### ブロックとインデント

- if文などのブロックは1行の長さでなければならない。
    - 1行 = 関数を呼び出すだけ
- 関数内のインデントレベルは1つか2つ

### 関数は1つのことを行うようにする(単一責務の原則)

<aside>
💡

関数では一つのことを行うようにせよ。その一つのことをきちんと行い、それ以外のことを行ってはならない

</aside>

- 一つのこと
    - 関数の名前で示されている責務(1つの抽象レベル)を、いくつかのステップのみで表現されているなら、その関数は一つのことをしている
        - 関数を書く目的は、ある一つのより広い概念(関数の名前)を、次の抽象レベルのいくつかのステップに分解すること
- 単一責務の原則
    - クラスやモジュールは、**一つのことだけに責任を持つ**べき
    - 悪い例
        
        ```python
        class User:
            def __init__(self, name, email):
                self.name = name
                self.email = email
        
            def send_email(self, message):
                # メールを送信するためのロジック
                pass
        
            def save_to_database(self):
                # ユーザー情報をデータベースに保存するロジック
                pass
        ```
        
        - `User` クラスは、ユーザー情報を扱う責務を持ちながら、メールの送信やデータベースへの保存も行ってしまっている
    - 良い例
        
        ```python
        class User:
            def __init__(self, name, email):
                self.name = name
                self.email = email
        
        class UserDatabase:
            def save(self, user):
                # ユーザー情報をデータベースに保存するロジック
                pass
        
        class EmailService:
            def send_email(self, user, message):
                # メールを送信するためのロジック
                pass
        ```
        
        - `User` クラスはユーザー情報のみを保持し、メール送信やデータベース保存の責務はそれぞれ別のクラスに移している
    

## 1つの関数に1つの抽象レベル

---

- 関数内の抽象レベルは統一したほうが良い

### コード通読 : 逓減規則

- 逓減規則
    - コードは上から下からへと物語のように読める必要がある
    - → 抽象レベルが上から順番に並んでいる必要がある

## switch文

---

- switch文をそのまま使用すると、問題が出てくる
    - 関数が肥大化しやすい(新しい分岐が増えるたびに大きくなる)
    - 単一責務の原則に反している
    - 開放 / 閉鎖の原則に反している
        - 開放 / 閉鎖の原則
            - **拡張に対して開かれている（Open for extension）**
                - クラスやモジュールの機能は、新しい振る舞いや機能を追加するために拡張可能であるべきです。
            - 修正に対して閉じられている
                - 既存のクラスやモジュールのソースコードは、既存の動作を変更せずに新しい機能を追加できるように設計されるべきです。
- 多態(ポリモーフィズム)
    - 同じ操作(メソッド名やインターフェース)を異なるデータ型やクラスで行うことができる性質を指す
        - これにより、異なるクラスのオブジェクトが、同じインターフェースを持つメソッドを使って異なる動作を実行できるようになります。
    - Ex. アニマルクラス
        
        ```python
        class Animal:
            def make_sound(self):
                pass
        
        class Dog(Animal):
            def make_sound(self):
                print("Woof!")
        
        class Cat(Animal):
            def make_sound(self):
                print("Meow!")
        
        animals = [Dog(), Cat()]
        
        for animal in animals:
            animal.make_sound()
        ```
        
        - `make_sound`メソッドが各クラスで異なる動作をしている
        - 同じ操作（`make_sound`）でありながら、クラスに応じて異なる動作をするのが多態（ポリモーフィズム）の特徴

## 内容をよく表す名前を使う

---

- 長い名前を付けるのを怖がらない
- 内容をよく表す長い名前は、不可解な短い名前よりも優れている

<aside>
💡

「そこに書かれているルーチンを読んだとき、それが大体あなたの期待通りであったとしたら、そのときあなたはクリーンコードの中で作業をしていることを知るのです」

</aside>

## 関数の引数

---

- 引数の数は理想が0、その次が1,2
- 3つの引数はできれば避ける。4つ以上は余程の理由がない限りやめる
    
    → インスタンス変数として持たせることはできないか検討する
    

### フラグ引数

- 関数にフラグ引数を渡すのは良くない習慣
- フラグ引数がある時点で、この関数は2つ以上のことをしている
    - それぞれの関数に分けるべき

### 引数2つの関数

- 自然な順序づけができない2つの引数を使用するときは、正しい順序で引数を渡す必要があり、コストがかかる
- 悪というわけではないが、1引数に変換できないか検討する
    - 引数の一つをクラスとし、もう一つの引数をとるメソッドを定義する
        
        ```python
        ×
        writeField(outputStream, name)
        
        ○
        outputStream.writeField(name)
        ```
        

### 引数オブジェクト

- ある関数の引数に2, 3を超える引数が必要なら、引数のいくつかをオブジェクトでラップしてみるのも検討
    
    ```python
    ×
    def make_circle(x, y, radius):
    
    ○
    def make_circle(point, radius):
    ```
    

### 動詞とキーワード

- 1引数の場合、関数名と引数は洗練された動詞 / 名詞の組み合わせとなる
    
    ```python
    write(name)
    ```
    
    → 名前が書かれることが瞬時に理解できる
    

- 関数名に引数の内容がわかるキーワードを入れることで、以下メリット
    - 引数の順序がわかる
        
        ```python
        assertEquals(expected, actual) 
         → assertExpectedEqualsActual(expected, actual)
        ```
        
    - 引数が実際に何を指しているのかがわかる
        
        ```python
        write(name) → writeField(name)
        
        ```
        

## 副作用を避ける

- 関数の与えられた責務に隠れて、別のことを行うのは避ける
- 副作用の例
    - 与えられた引数に対して、またはグローバルに対して隠れて値を変更するなど

## コマンド・照会の分離原則

---

- 関数は、なんらかの処理を行うか、なんらかの応答を返すかのどちらかを行うべき
    - Ex. ダメな例
        
        ```python
        def set(attribute, value);
        	"""attributeにvalueを設定する。
        	　　設定に成功したらtrueを返す。
        	　　attributeがなければ、falseを返す
        	"""
        ```
        

## try / catchブロックの分離

---

- try / catchブロック自体が無格好
- それぞれの中身を関数として切り出した方が良い
    
    ```python
    def delete(page):
    	try {
    		deletePageAndAllReferences(page)
    	} catch (Exception e) {
    		logError(e)
    	}
    
    def deletePageAndAllReferences(page):
    	"""ページを完全に削除する処理"""
    ```
    
    - deleteはエラー処理のみを行っているため、理解しやすい
    - deletePageAndAllReferencesはページを完全に削除することのみを行なうため、エラー処理は無視している
    - うまく分離されているため、理解しやすく変更も用意
    - エラー処理も1つの処理であるため、エラー処理を行う関数は他の処理をすべきではない
        
        → tryが最初にきていないおかしい。同様に、catch / finally が最後に来ていないとおかしい
        

## DRY原則

---

重複はコード量を増やし、アルゴリズムに変更が必要な場合は重複されている分だけ修正しなければならない。修正漏れの確率も重複されている分だけ増える

## 構造化プログラミング

---

- エドガー・ダイクストラの構造化プログラミング
    
    > 全ての関数と関数内の全てのブロックは入り口と出口を一つにすべき
    > 
    
    → return文は一つだけ。ループ内には、break, continue文は存在しないということになる
    
- 関数が小さい場合にはあまり、この考えは役に立たない
    - 入口出口を少なくするよりも、return break continueを使用することで、コードの表現が豊かになる

## ソフトウェアを書くということ

---

- ソフトウェアを書くということは、文章の執筆と同じようなもの
    - 文章
        - 自分の思いを書き出す → 読みやすくなるように修正する → 読みたいと思えるような文章になるまで修正する → 完成
    - ソフトウェア
        - 関数をとりあえず書いてみる(冗長でも、長くてもOK) → 単体テストを書いてみる → リファクタリングする → 常にテストが通っていることを確認しながら、綺麗なコードになるまで修正する → 完成