## 同時並行性がなぜ必要か

---

- 同時並行性は、「何」を実行するのかと、「いつ」実行するのかを分離する
- メリット
    - アプリケーションの構造
        - 一つの大きなメインループではなく、たくさんの協調する小さなシステムの集まりに見える
            - システムの理解を簡単にし、関心ごとの分離を推し進める
    - 応答時間や、スループットの向上

### 神話と誤解

- 同時並行性は常にパフォーマンスを改善するわけではない
    - 時としてパフォーマンスは改善するが、改善されるケースは、待ち時間が大量にあり、それを複数のスレッドあるいはプロセッサで共有できる場合だけ
- 同時並行性に変更した場合に、設計の変更は必要である
- 同時並行性には余分なコード、オーバーヘッドが付きまとう
- 解くべき問題が単純であっても、正しい同時並行性の確保は複雑となる
- 同時並行性のバグには大抵は再現性がなく、一過性の問題として片付けられてしまう

## 難問

- 同時並行性の難しい問題は、数ある実行経路のうち、正しくない結果をもたらす実行経路が存在すること
- Ex.
    
    ```java
    public class X {
    	private int lastIdUsed;
    	
    	public int getNextId() {
    		return ++lastIdUsed;
    	}
    }
    ```
    
    - `lastIdUsed`を42にして、Xインスタンスを生成し、2つのスレッドで`getNextId`を呼び出すと、取りうる結果は以下の3通りになる
        1. スレッド1は値43を受け取り、スレッド2は値44を受け取る。lastUsedの現在値は44である。
        2. スレッド1は値44を受け取り、スレッド2は値43を受け取る。lastUsedの現在値は44である。
        3. スレッド1は値43を受け取り、スレッド2は値43を受け取る。lastUsedの現在値は43である。
            
            → この結果は、2つのスレッドが同時に動作したときに起こる
            

## 同時並行性防御原則

---

システムを同時並行処理コードの問題から守るための原則と技法

### 単一責務の原則

- SRPでは、変更の要因となるものは一つだけ持つとする
- 同時並行処理にすることで設計を見直す必要があり、それ自体が変更の要因となる
- → 同時並行性に関係するコードを、他のコードから分離すること

### データのスコープを限定する

- 同じスレッドで共有オブジェクトのフィールドを変更すると、予期されない挙動を招く
    - 対策するには、コード内で共有オブジェクトを操作するクリティカルセクションを保護する
        - クリティカルセクション自体の数が少ないことが一番望ましい
- データのカプセル化を徹底し、共有される可能性のあるデータへのアクセスを厳しくすること

### スレッドはできるかぎり独立せよ

- 全てのスレッドがそれぞれ独立したコードを実行するのであれば問題ない
    - Ex. HttpServletを継承したクラス
        - HttpServlet: JavaのHTTPメソッドを実行するための抽象クラス
        - getパラメーター、postパラメーターをメソッドから取得する場合、それぞれのServletのコードがローカル変数のみを使用している限りは、サーブレットが同期化の問題を起こすことはない
            
            <aside>
            💡
            
            スレッドでは、ローカル変数は競合しない
            
            </aside>
            
    - 同期化の問題
        - 複数のリクエストが同時に同じインスタンスを処理する際に、共有リソースが原因で起こるデータの競合や不整合のこと
        - Ex.
            - インスタンス変数や静的変数は同じ共有リソースにあたるため、競合が起きる
            - 対して、ローカル変数はスレッドごとにスタック内に割り当てられるため**、**他のスレッドと共有されず、競合は起きない

### 使用しているライブラリを知る

- 同時並行処理のライブラリを知ることから始める
- ライブラリを用いて、スレッド化されたコードを書くときには考慮すべき点がある
    - 提供されているスレッドセーフなコレクションを利用する
    - お互いに関係しないタスクの実行に、エグゼキュタフレームワークを利用する
    - 可能であれば、ブロックしない方法を用いる
    - ライブラリのいくつかは、スレッドセーフではない

## 実行モデルを見分ける

---

### 同時並行処理の基本的な定義

- 束縛リソース
    - 同時並行処理環境で使用される、固定長のリソース。あるいは数値
- 相互排他
    - 共有リソースには、同時に1アクセスしかできない
- 飢餓状態
    - あるスレッドが、長時間あるいは永遠に実行機会を与えられないこと
- デッドロック
    - 2つ以上のスレッドがお互いの終了を待っている状態
        - それぞれのスレッドが1つのリソースを持っており、そのリソースを別のスレッドが要求している
        - どのスレッドももう一方のリソースを取得するまで終了しないケース
- ライブロック
    - 複数のスレッドが足並みをそろえて処理をした際にお互いに邪魔しあって、処理が長時間あるいは永遠に進まない状態

### 同時並行処理プログラミングにおける実行モデル

- プロデューサーコンシューマ
    - 1つ以上のプロデューサースレッドが作業を生成してバッファ、あるいはキューに格納する
        - 書き込み前に、キューに空き領域ができるのを待つ必要がある
    - 1つ以上のコンシューマスレッドが、作業からキューを取り出して完了させる
        - キュー内に作業が入るまで待たなければならない
    - キューは「束縛リソース」である
- リーダーライター
    - リーダー
        - 読み込み(スループット)を重視すると、飢餓状態と更新されずに古い情報の集積が起こる
    - ライター
        - 更新を許すと、多くのリーダを長時間ロックにさせてしまいがちで、スループットの問題が起こる
    - 許容範囲のスループット、許容範囲の飢餓状態を満たしつつリーダーとライターの要件の妥協点を見つける点が問題となってくる
        - リーダがいなくなるまで、ライターの更新を待たせると、ライターが飢餓状態となる
        - ライターが優先度を高く持っているっと、スループットが悪化する
    

p247

正確に終了できるようにすることに、時間がかかることを覚悟しておく

スレッド化されたテストのコード

問題を炙り出すテストをかき、それを異なるプログラム構成、システム設定上で頻繁に実行する

テストが失敗したら、失敗の原因を掘り下げる

→ 2度目が失敗しなかったからといって、無視してはいけない

はじめにスレッド化されていないコードを完成させる

p249

異なるプラットフォームで実行する

p250

コードに対して色々なことを試し、エラーを強制的に発生させる

- 同時並行処理のエラーは通常の動作時には見つからないことが多く、再現が難しい
    - 問題のあるセクションの数千の実行経路パスの中で、実際に失敗する経路を通る確率は驚くほど低いため
- Javaだと、Object.sleep()といったような、実行順序に影響を与えるものを駆使して、問題箇所を発見できるようにする

p252

結論

同時並行処理コードを正しく作成するのは難しい

まずは、単一責務の原則に従う

スレッドを意識するコードと、そうではないコードとに分ける

同時並行性の問題となりうるものについてきちんと理解を

共有データの操作等

問題は突然現れる。負荷が高いときにだけ起きたりなど。

→ スレッドに関係したコードは、さまざまな構成で、さまざまなプラットフォーム上で何度も続けて実行できるようにしておく必要がある

## プロセスとスレッド(調べ)

---

- **プロセス**
    - 独立したメモリ空間を持ち、他のプロセスとメモリを直接共有しない。
    - 通信は明示的な手段（IPC）を使用する必要がある。
- **スレッド**
    - 同じプロセスのメモリ空間（コード、静的変数、ヒープ領域）を共有。
    - 各スレッドには個別のスタックがあり、ローカル変数は競合しない。
    - 共有メモリにアクセスする場合は同期が必要。

### スレッドが使用するメモリについて

- **スレッドごとのスタック領域**
    - 各スレッドは独自の**スタック領域**を持ちます。このスタック領域は、ローカル変数や関数の呼び出し情報（戻りアドレスなど）を保持します。
    - スタック領域のサイズは通常、**OSやJVMの設定**で決まっています（例えば、Javaではデフォルトで1MB程度）。
        
        ```java
        java
        コードをコピーする
        // JVMオプションでスタックサイズを指定可能
        -Xss512k  // スタックサイズを512KBに設定
        
        ```
        
- **共有されるメモリ**
    - スレッドはプロセス内の共有メモリ（コードセクション、ヒープ領域、データセクション）も利用しますが、スタック領域はスレッドごとに確保されるため、スレッド数が増えるとその分だけ追加のメモリが必要になります。