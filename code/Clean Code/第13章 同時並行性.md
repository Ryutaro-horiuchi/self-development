並行処理について

p239

神話と誤解

同時並行性は常にパフォーマンスを改善するわけではない

- 時としてパフォーマンスは改善するが、待ち時間が大量にあり、それを複数のスレッドあるいはプロセッサで共有できる場合だけ

同時並行性には余分なコード、オーバーヘッドが付きまとう

解くべき問題が単純であっても、正しい同時並行性の確保は複雑となる

p240

難問

```java
public class X {
	private int lastIdUsed;
	
	public int getNextId() {
		return ++lastIdUsed;
	}
}
```

- lastIdUsedを42にして、Xインスタンスを生成し、2つのスレッドでgetNextIdを呼び出すと、取りうる結果は3通りになる
    1. スレッド1は値43を受け取り、スレッド2は値44を受け取る。lastUsedの現在値は44である。
    2. スレッド1は値44を受け取り、スレッド2は値43を受け取る。lastUsedの現在値は44である。
    3. スレッド1は値43を受け取り、スレッド2は値43を受け取る。lastUsedの現在値は43である。
        
        → この結果は、2つのスレッドが同時に動作したときに起こる
        

p241

同時並行性防御原則

システムを同時並行処理コードの問題から守るための原則と技法

- 単一責務の原則
    - 同時並行性に関係するコードを、他のコードから分離すること
- データのスコープを限定する
    - 同じスレッドで共有オブジェクトのフィールドを変更すると、予期されない挙動を招く
        - 対策するには、コード内で共有オブジェクトを操作するクリティカルセクションを保護する
            - クリティカルセクション自体の数が少ないことが一番望ましい
    - データのカプセル化を徹底し、共有される可能性のあるデータへのアクセスを厳しくすること
- スレッドはできるかぎり独立せよ
    - 全てのスレッドがそれぞれ独立したコードを実行するのであれば、問題はない
        - Ex. HttpServletを継承したクラス
            - HttpServlet: JavaのHTTPメソッドを実行するための抽象クラス