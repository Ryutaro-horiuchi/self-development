## 同時並行処理の有効性

マルチスレッド化により解決できるのかは、まずシステムのどの部分で時間が掛かっているのかを事前に考える必要がある

- 考えられるのは2つ
    - I/O: ソケットアクセス、データベースへの接続、仮想メモリのスワッピング待ち
        
        コードがI/O関連であれば、同時並行は効率を向上させる。
        
        システムのある部分がI/O待ちの時、別の部分はその間に処理ができる
        
    - プロセッサ: 数値計算、正規表現の処理、ガベージコレクション
        
        コードがプロセッサ依存のものであれば、処理装置の増強により改善される
        
        並行化しても、早くはならない
        

## 実行経路の数

### 前提

- 生成されたバイトコードから調べる必要がある
    - **バイトコード (bytecode)** は、プログラムのソースコードをコンパイルして生成される中間形式のコードです。
    - Ex.
        - コード
            
            ```python
            x = 5
            y = x + 2
            print(y)
            ```
            
        - バイトコード
            
            ```python
              0 LOAD_CONST               1 (5)
              2 STORE_NAME               0 (x)
              4 LOAD_NAME                0 (x)
              6 LOAD_CONST               2 (2)
              8 BINARY_ADD
             10 STORE_NAME               1 (y)
             12 LOAD_NAME                2 (print)
             14 LOAD_NAME                1 (y)
             16 CALL_FUNCTION            1
             18 POP_TOP
             20 LOAD_CONST               0 (None)
             22 RETURN_VALUE
            ```
            
- バイトコードの数をNとする。スレッドをTとすると、全体のステップ数はN×T。
    - Ex. バイトコードが2つ、スレッドが2つだと全体のステップ数は4になる

### 計算

1. ステップの組み合わせを考えると、スレッド1が「1」、スレッド2が「2」で表され、命令の進行状況により次のような文字列が生成されます:
    
    ```python
    1122, 1212, 1221, 2112, 2121, 2211, ....
    ```
    
2. 各文字列には、**「1が2つ」**、**「2が2つ」** 含まれています。
3. 「1が2つ」、「2が2つ」という条件は、次のように配置を入れ替えても同じ意味を持ちます:
    1. `1122` の先頭の「1」と2番目の「1」、3番目の「2」と4番目の「2」を入れ替えても文字列としての意味は変わらない。
4. この重複を取り除くには、全順列数を以下のように修正します
    - **総順列数**: 4!=24
    - **重複の種類**: 「1の並び替え数」 × 「2の並び替え数」 `= 2!×2! = 2×2=4`
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/a643e5c2-0b43-4ddb-a882-7a28e8718617/image.png)
        

### 一般的なケース

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/c66705ee-8899-4535-a09a-ec183c5b1c8f/image.png)

- 具体例 バイトコードの数が3 スレッドが2の場合
    - 文字列の並び(一部)
        
        ```python
        111222, 112122, 112212, 121122, 121212 ...
        ```
        
    - 総合順列数
        - 命令が6つ（`111222`）なので、順列の全通りは： 6! = 720
    - 重複
        - 数字 `1` が3回 → 3! 通りの重複
        - 数字`2`が3回 → 3!通りの重複
        
        ＝ (3!)の2乗
        
    - 計算
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/c6f2872c-c998-4f65-ab23-abd852cc24a7/image.png)
        
    - 答え
        - 20通り

## デッドロックが発生する条件

- 以下の4つの条件全てが揃うと、デッドロックが起きる可能性がある。
- これらの条件のどれか一つでも成立しなければデッドロックは起きない

### 相互排他

- 複数のスレッドが同じ資源を使用する必要があり、その資源が以下のようなものであるときに発生する
    - 同時には複数のスレッドでアクセスすることができない
    - 数が限られている
    - Ex.
        - データベース接続、書き込みオープンされたファイル、レコードロック、セマフォ
        - セマフォ
            - 共有資源に対するアクセス可能な数を示す値

### ロックと待機

- あるスレッドが資源を獲得したら、作業に必要となる全ての資源を確保し、作業が完了するまで解放しない

### 割り込み不可

- スレッドは、別のスレッドから資源を取り上げることがでいない。別のスレッドが資源を得るためには、現在保有しているスレッドが、資源を解放する必要がある

### 循環待機

- T1, T2という2つのスレッドと、R1, R2という二つの資源があるとする
- T1がR1を、T2がR2を所有している
- T1はさらにR2を、T2はさらにR1を要求する

## デッドロックの要因を取り除く

### 相互排他を取り除く

- 資源を同時にアクセスできるようにする
- 資源の数と競合状態となるスレッドの数を同等、あるいはそれを超える数の資源を用意する

<aside>
💡

 大抵の資源は同時アクセスを許して送らず、数も限られているため、取り除くことは難しい

</aside>

### ロックと待機を取り除く

- 待機しないようにすることで回避できる
    1. 資源を獲得する際に獲得済みかをチェックする。すでにどれかの資源が他のスレッドによって獲得済みの場合は、それ以上待機せずに以下を行う
        - 現在獲得している資源をすべて解放する。
        - 最初から資源の獲得を再試行する。
    2. すべての資源が獲得できる場合のみ、そのプロセスは進行可能になる。
- 問題点
    - 飢餓状態
        - [飢餓状態](https://www.notion.so/14093db0555480018794f0508068202c?pvs=21)
    - ライブロック
        - [ライブロック](https://www.notion.so/14093db0555480d3b9b2fb2151f795a0?pvs=21)

<aside>
💡

スループットはとても低いものになる。

非効率に見えるが、全く処理されないよりはまし

</aside>

### 割り込みできるようになる

- 資源を別のスレッドから取り上げることができるようにする
- スレッドが資源の待機をすることが可能である点で、「ロックと待機を取り除く」の改善策よりも利点があるが、実装は面倒なものになる可能性がある点には注意する

### 循環待機を行う

- 最も一般的な手法
- スレッドで資源の確保の順番を揃えることで、循環待機を回避できる
    - 全てのスレッドが資源確保の順番を決めて、それに従うようにすればデッドロックは回避できる
- 問題点
    - 獲得順と使用順とは一致しない場合がある。獲得されても最後まで使われないケースが存在する
        - Ex.
            - スレッドAが資源1と資源2を使用する必要があるとします。
                1. ルールに従い、最初に資源1を獲得します。
                2. 次に資源2を獲得します。
                3. しかし、実際には資源2が先に必要で、資源1は後で使用される。
            - 資源1が獲得されたまま長時間未使用になり、システム全体で資源が無駄に占有される可能性があります。
            - 他のスレッドが資源1を必要としている場合、そのスレッドが不要な待機を強いられる（スループット低下）。
    - 資源の獲得順を強制することができないことがある
        - 資源の管理が異なるプロセス間で共有されていない場合、グローバルな順序を決定することが困難です。
        - 例：複数の分散システム間で一貫した順序を強制するのは技術的に複雑です。