筆者とマーチン・ファウラーのリファクタリングのクロスリファレンス

## コメント

---

### C1: 不適切な情報

- 更新履歴等をコメントに載せるのは不適切なコメント

### C2: 退化コメント

- 古くなったコメント、間違ったコメントは退化コメント
- 発見したら、すぐに最新化するか取り除く

### C3: 冗長なコメント

- それ自体を正確に記述しているコメントは冗長なコメント
    
    Ex. 
    
    ```java
    i++; // iを1増やす
    ```
    

### C4: 記述不足のコメント

- 十分に記述されていなければ価値がない
    - 単語を慎重に選ぶ、正確な文法、句読点の付け方を心がける
    - とりとめのないことを書かない
    - 当たり前のことを記述しない

### C5: コメントアウトされたコード

- コメントアウトされたコードは残り続けやすい
    - 他の誰かが必要としている、将来的に削除する予定があると思っているから
    - 残り続けたコメントアウトのコードは日を追うごとに腐敗し、現在のコードの規約にそぐわない過去のものとなる
- コメントアウトされたコードを見つけたら即削除する
    
    削除されたコメントが例え必要だったとしても、ソースコード管理システムを辿れば良い
    

## 環境

---

### E1: ビルドに複数のステップを要する

- プロジェクトのビルドは単一の簡単な操作でなければならない
- ビルドをするのに、細々としたものをいくつもチェックアウトすることを要するようなことや、特定の環境に依存したスクリプトが必要となる状況は避けるべき
- 1つのコマンドでシステムをチェックアウトし、もう一つのコマンドによってビルドできるようにするべき

### E2: テストに複数のステップを要する

- コマンド一発ですべての単体テストが実行できるようにしておくべき

## 関数

---

### F1: 多すぎる引数

- 関数の引数は少なくすべき。ないのがベスト
- 3つはできるだけ避けるべき。4以上は、よほどの理由がない限りやめる。

### F2: 出力引数

- 出力引数は直感的ではない。
- 出力引数
    - 与えられた引数に変更を加えること

### F3: フラグ引数

- Boolean引数は関数が二つ以上のことを行なっていることを声高に宣言している。混乱を招くのでやめるべき

### F4: 死んだ関数

- どこからも呼び出されないメソッドは削除すべき
    - デッドコードをそのままにしておいても無駄
    - 削除してもソースコード管理システムが覚えていてくれるから躊躇する必要なし

## 一般

---

### G1: 1つのソースファイルに複数の言語を使用する

- 理想的なのは、1つの言語のみでソースファイルが構成されること
- 現実的には2つ以上の言語を使うことになるが、例え苦労をしてでも、ソースファイルの中で使用する余計な言語の数と量を最小化すべき

### G2: あって当然の振る舞いが実装されていない

- 「驚き最小の原則」に従い、プログラマがその命名から当然と期待する振る舞いをあらゆる関数、クラスが行うようにすべき

### G3: 境界値に対する不正確な振る舞い

- あらゆる境界条件、さまざまな特殊ケース等が、アルゴリズムを複雑にする。
- 動作すると思って直感を信じるのではなく、それを証明するために、あらゆる境界条件を含んだテストを隅々まで行うこと

### G4: 安全軽視

- 「失敗するテストを無視して、後で通るようにすれば良い」といったような軽視をしない

### G5: 重複

- 重複コードが存在するところでは、抽象化の機会が失われている
    - 重複部分は明らかにサブルーチンか別のクラスにできる
    - 重複を抽象化することで、別のプログラマがその抽象化機構を使用することができる
    - コーディングを素早くできるようになり、エラーも起きにくくなる

### G6: 抽象レベルが正しくないコード

- 高いレベルの概念は抽象クラスのみに持たせ、継承クラスに低いレベルの概念のみを持たせる
    - 実装詳細にのみ関係する定数、変数、ユーティリティ関数はベースクラスに置くべきではない

### G7: 継承クラスに依存したベースクラス

- ベースクラスは継承クラスの知識を持たない
    - ベースクラスが、継承クラスの名前を知っていたとしたら、何らかの問題があることを疑った方が良い

### G8: 情報過多

- うまく定義されたモジュールは、とても狭いインターフェイスを持ちながら、多くのことをこなす。対して不完全に定義されたモジュールは、広く深いインターフェイスを持ち、単純なことを行うにもさまざまな指定を必要とする
    
    <aside>
    💡
    
    クラス、モジュールの外部へのインターフェイスの公開を最低限に抑えること
    
    </aside>
    
- うまく定義されたモジュール
    - **少ない依存関係**: インターフェイスがうまく設計されている場合、必要最小限の関数やメソッドだけを公開しています。
    - **結合度が低い**: 呼び出し元（クライアント）は、必要な情報だけを取得でき、余計な詳細を知る必要がありません。
    - Ex. データベース操作を抽象化したインターフェイス。
        
        ```python
        class UserRepository:
            def get_user(self, user_id: str) -> User:
                pass
        ```
        
        - **`get_user`** を呼び出すだけでユーザー情報を取得できる。データベースクエリや接続管理などの詳細を知る必要がありません。
- 不完全に定義されたモジュール
    - **多すぎる依存関係**: 不適切に設計されたインターフェイスは、クライアントに多くの関数やメソッドを呼び出すことを強制します。
    - **結合度が高い**: 呼び出し元はこれらすべての関数を順序通りに使用する必要があり、内部構造や実装の詳細に依存します。
    - Ex. データベース操作の不完全なインターフェイス
        
        ```python
        class BadUserRepository:
            def connect_to_database(self):
                pass
        
            def execute_query(self, query: str):
                pass
        
            def parse_results(self, raw_data):
                pass
        ```
        
        - インターフェイスの多くのメソッドを呼び出さなければ目的を達成できない
        - インターフェイスに変更があると、クライアントコード側も修正が必要になる。

### G9: デッドコード

- デッドコードとは実行されることのないコード。害なので削除する
- Ex.
    - 決して成立することのない条件を持ったif文
    - 例外をスローしない try catchブロック

### G10: 垂直分離

- 変数と関数は、それが使用される場所の近くで定義すべき
    - ローカル変数はそれが使用される場所の直前で定義すべきで、縦方向のスコープを最低限に限定すべき

### G11: 不整合

- 何かを行うときに、ある方法を使用するのなら、それに類すること は全て同じ方法で行えるべき
- Ex.
    - HttpServletResposeオブジェクトを保持する変数名をresponseと名付けたのなら、他の箇所でHttpServletResposeオブジェクトを使用する関数でも、同じ変数名を名付けるべき

### G12: 雑然

- 未使用変数、呼ばれることのない関数、何の情報も提供しないコメントはゴミでしかなく、削除すべき

### G13: 人為的な結合

- 人為的な結合とは、2つのモジュール間の直接の意図のない結合のこと
    - 変数、定数、関数を、そこが不適切な場所にも関わらず、単に一時的に便利だからという理由で入れてしまうことによって起こる
- 他モジュールが使用すべきでないものは明示的に非公開（例: **`_`** を付ける）にするなどといった対策をとり、人為的な結合を避けるように努める
- Ex. 変数の人為的な結合
    - モジュールA
        
        ```python
        # 定数を定義
        PI = 3.14159
        
        # 円の面積を計算する関数
        def calculate_circle_area(radius):
            return PI * (radius ** 2)
        ```
        
    - モジュールB
        
        ```python
        from module_a import PI  # モジュールAからPIをインポート
        
        # 別の計算に使用
        def calculate_sphere_volume(radius):
            return (4 / 3) * PI * (radius ** 3)
        
        ```
        
    - あるモジュール内の変数が、別のモジュールで意図せず使用されてしまう。
        - **`PI`** はモジュールAの実装の一部として意図されていたが、モジュールBが直接利用しています。
        - 将来的にモジュールAが**`PI`**を変更した場合（たとえば、名前を変えたり、異なる計算方法に変更）、モジュールBも意図せず影響を受けます。
    

### G14: 機能の羨望

- クラスのメソッドは、別のクラスの変数、関数に関心を持つべきではない
    - あるメソッドが、別のオブジェクトのアクセサを使ってデータにアクセスしている場合、そのメソッドは、別のオブジェクトにアクセスできることを羨望している
- Ex. Bad
    
    ```python
    class Book:
        def __init__(self, title, author):
            self.title = title
            self.author = author
    
    class Library:
        def __init__(self):
            self.books = []
    
        def add_book(self, book):
            self.books.append(book)
    
        def list_authors(self):
            # Bookの内部構造に直接依存している
            return [book.author for book in self.books]
    
    ```
    
    - **`Library`** クラスは **`Book`** の内部実装（**`author`** 属性の存在）に依存しています。
        - 将来、**`Book`** クラスの実装が変わり、**`author`** 属性がなくなった場合や、取得方法が変わった場合、**`Library`** クラスのコードも修正が必要になります。
- Ex. Good
    
    ```python
    class Book:
        def __init__(self, title, author):
            self._title = title
            self._author = author
    
        def get_author(self):
            return self._author
    
    class Library:
        def __init__(self):
            self.books = []
    
        def add_book(self, book):
            self.books.append(book)
    
        def list_authors(self):
            # Bookの公開メソッドを介して情報を取得
            return [book.get_author() for book in self.books]
    
    ```
    
    - **`Library`** クラスは **`Book`** クラスの内部構造を知らなくても、公開されたインターフェイスを使ってデータを取得できます。
    - **`Book`** クラスの内部実装が変更されても、インターフェイスが変わらない限り、**`Library`** クラスへの影響は最小限に抑えられます。

### G15: セレクタ引数

- 関数の引数にbooleanなど、その関数の振る舞いを選択する引数の使用は避けるべき
    - その関数に出くわすたびに、セレクタ引数が何を指すか確認をする必要がある
    - 小さな関数に分割できるのに、セレクタ引数を使用することによって大きな関数になりがち

### G16: 不明瞭な意図

- コードはできる限り表現豊かにし、意図が明瞭である必要がある
    - 長々と続く式、マジックナンバーは作者の意図を不明瞭にする

### G17: 責務を持たせる場所の間違い

- どこにコードを置くかは、ソフトウェア開発者にとって最も重要な判断の一つ
- 驚き最小の原則に従い、コードは読み手が 当然と思う位置におくべき

### G18: 不適切なstatic

- 一般的にはstaticよりも非staticを好むべき
    - staticは、多態性をサポートしていない
    - どうしてもstaticにしたいと感じたときは、多態的な振る舞いが必要になることがありえないか確認をすること
- Ex. Bad
    
    ```python
    HourlyPayCalculator.calculatePay(employee, overtimeRate)
    ```
    
    - 使用するデータは引数のみであるが、多態的に扱いたいケースが出てくるかもしれない
        - `OvertimeHourlyPayCalculator`(残業分の給与を計算する)
        - 非staticであればサブクラスでオーバーライドすることで、多態を表現できるが、staticではそれができない
- Ex. Good
    
    ```java
    Math.max(double a, double b)
    ```
    
    - maxが使用するデータは引数のa,bのみ。オブジェクトが保持するデータは参照しない
    - 多態的に扱う余地がない

### G:19 説明的変数

- プログラムを読みやすくするために、計算の途中結果を変数に格納し、その変数に説明的な名前をつける
- 説明的な変数は少ないよりも多い方が一般的には望ましい
- Ex.
    
    ```java
    if results:
    	key = results[0]
    	value = results[1]
    	...
    ```
    

### G20: 関数名は体を(**振る舞いや性質を明確に**)表すべき

```java
Date newDate = date.add(5); 
```

- date.addは色んな解釈が生まれる
    - dateに5を足すのか。それとも、週か、時間か
        - 5日を足すのであれば、addDaysTo, increaseByDaysのような名前にすべき
    - dateインスタンスは変化するのか。それとも新しいDateを返すのか
        - 新たなインスタンスを返すのであれば、daysLater, daysSinceという名前にすべき
- 関数が何を行うかを知るために、実装を見なければならないのであれば、もっと良い名前を探すか、機能を整理して、もっと良い名前を持った複数の関数に分けるべき

### G21: アルゴリズムを理解する

- アルゴリズムを正しく理解していないと、誤ったロジックや非効率なコードが生まれてしまう
    - テストがすべて通るだけでは不十分であり、アルゴリズムの設計意図や、その解が本当に正しいかどうかを確認する必要がある。
        - 解
            - アルゴリズムが導き出す結果（またはアウトプット)
- 問題を解く本質を見失うと、動作するように見えるが本質的に間違った実装が量産されるリスクがある。

### G: