筆者とマーチン・ファウラーのリファクタリングのクロスリファレンス

## コメント

---

### C1: 不適切な情報

- 更新履歴等をコメントに載せるのは不適切なコメント

### C2: 退化コメント

- 古くなったコメント、間違ったコメントは退化コメント
- 発見したら、すぐに最新化するか取り除く

### C3: 冗長なコメント

- それ自体を正確に記述しているコメントは冗長なコメント
    
    Ex. 
    
    ```java
    i++; // iを1増やす
    ```
    

### C4: 記述不足のコメント

- 十分に記述されていなければ価値がない
    - 単語を慎重に選ぶ、正確な文法、句読点の付け方を心がける
    - とりとめのないことを書かない
    - 当たり前のことを記述しない

### C5: コメントアウトされたコード

- コメントアウトされたコードは残り続けやすい
    - 他の誰かが必要としている、将来的に削除する予定があると思っているから
    - 残り続けたコメントアウトのコードは日を追うごとに腐敗し、現在のコードの規約にそぐわない過去のものとなる
- コメントアウトされたコードを見つけたら即削除する
    
    削除されたコメントが例え必要だったとしても、ソースコード管理システムを辿れば良い
    

## 環境

---

### E1: ビルドに複数のステップを要する

- プロジェクトのビルドは単一の簡単な操作でなければならない
- ビルドをするのに、細々としたものをいくつもチェックアウトすることを要するようなことや、特定の環境に依存したスクリプトが必要となる状況は避けるべき
- 1つのコマンドでシステムをチェックアウトし、もう一つのコマンドによってビルドできるようにするべき

### E2: テストに複数のステップを要する

- コマンド一発ですべての単体テストが実行できるようにしておくべき

## 関数

---

### F1: 多すぎる引数

- 関数の引数は少なくすべき。ないのがベスト
- 3つはできるだけ避けるべき。4以上は、よほどの理由がない限りやめる。

### F2: 出力引数

- 出力引数は直感的ではない。
- 出力引数
    - 与えられた引数に変更を加えること

### F3: フラグ引数

- Boolean引数は関数が二つ以上のことを行なっていることを声高に宣言している。混乱を招くのでやめるべき

### F4: 死んだ関数

- どこからも呼び出されないメソッドは削除すべき
    - デッドコードをそのままにしておいても無駄
    - 削除してもソースコード管理システムが覚えていてくれるから躊躇する必要なし

## 一般

---

### G1: 1つのソースファイルに複数の言語を使用する

- 理想的なのは、1つの言語のみでソースファイルが構成されること
- 現実的には2つ以上の言語を使うことになるが、例え苦労をしてでも、ソースファイルの中で使用する余計な言語の数と量を最小化すべき

### G2: あって当然の振る舞いが実装されていない

- 「驚き最小の原則」に従い、プログラマがその命名から当然と期待する振る舞いをあらゆる関数、クラスが行うようにすべき

### G3: 境界値に対する不正確な振る舞い

- あらゆる境界条件、さまざまな特殊ケース等が、アルゴリズムを複雑にする。
- 動作すると思って直感を信じるのではなく、それを証明するために、あらゆる境界条件を含んだテストを隅々まで行うこと

### G4: 安全軽視

- 「失敗するテストを無視して、後で通るようにすれば良い」といったような軽視をしない

### G5: 重複

- 重複コードが存在するところでは、抽象化の機会が失われている
    - 重複部分は明らかにサブルーチンか別のクラスにできる
    - 重複を抽象化することで、別のプログラマがその抽象化機構を使用することができる
    - コーディングを素早くできるようになり、エラーも起きにくくなる

### G6: 抽象レベルが正しくないコード

- 高いレベルの概念は抽象クラスのみに持たせ、継承クラスに低いレベルの概念のみを持たせる
    - 実装詳細にのみ関係する定数、変数、ユーティリティ関数はベースクラスに置くべきではない

### G7: 継承クラスに依存したベースクラス

- ベースクラスは継承クラスの知識を持たない
    - ベースクラスが、継承クラスの名前を知っていたとしたら、何らかの問題があることを疑った方が良い

### G8: 情報過多

- うまく定義されたモジュールは、とても狭いインターフェイスを持ちながら、多くのことをこなす。対して不完全に定義されたモジュールは、広く深いインターフェイスを持ち、単純なことを行うにもさまざまな指定を必要とする
    
    <aside>
    💡
    
    クラス、モジュールの外部へのインターフェイスの公開を最低限に抑えること
    
    </aside>
    
- うまく定義されたモジュール
    - **少ない依存関係**: インターフェイスがうまく設計されている場合、必要最小限の関数やメソッドだけを公開しています。
    - **結合度が低い**: 呼び出し元（クライアント）は、必要な情報だけを取得でき、余計な詳細を知る必要がありません。
    - Ex. データベース操作を抽象化したインターフェイス。
        
        ```python
        class UserRepository:
            def get_user(self, user_id: str) -> User:
                pass
        ```
        
        - **`get_user`** を呼び出すだけでユーザー情報を取得できる。データベースクエリや接続管理などの詳細を知る必要がありません。
- 不完全に定義されたモジュール
    - **多すぎる依存関係**: 不適切に設計されたインターフェイスは、クライアントに多くの関数やメソッドを呼び出すことを強制します。
    - **結合度が高い**: 呼び出し元はこれらすべての関数を順序通りに使用する必要があり、内部構造や実装の詳細に依存します。
    - Ex. データベース操作の不完全なインターフェイス
        
        ```python
        class BadUserRepository:
            def connect_to_database(self):
                pass
        
            def execute_query(self, query: str):
                pass
        
            def parse_results(self, raw_data):
                pass
        ```
        
        - インターフェイスの多くのメソッドを呼び出さなければ目的を達成できない
        - インターフェイスに変更があると、クライアントコード側も修正が必要になる。

### G9: デッドコード

- デッドコードとは実行されることのないコード。害なので削除する
- Ex.
    - 決して成立することのない条件を持ったif文
    - 例外をスローしない try catchブロック

### G10: 垂直分離

- 変数と関数は、それが使用される場所の近くで定義すべき
    - ローカル変数はそれが使用される場所の直前で定義すべきで、縦方向のスコープを最低限に限定すべき

### G11: 不整合

- 何かを行うときに、ある方法を使用するのなら、それに類すること は全て同じ方法で行えるべき
- Ex.
    - HttpServletResposeオブジェクトを保持する変数名をresponseと名付けたのなら、他の箇所でHttpServletResposeオブジェクトを使用する関数でも、同じ変数名を名付けるべき

### G12: 雑然

- 未使用変数、呼ばれることのない関数、何の情報も提供しないコメントはゴミでしかなく、削除すべき

### G13: 人為的な結合

- 人為的な結合とは、2つのモジュール間の直接の意図のない結合のこと
    - 変数、定数、関数を、そこが不適切な場所にも関わらず、単に一時的に便利だからという理由で入れてしまうことによって起こる
- 他モジュールが使用すべきでないものは明示的に非公開（例: **`_`** を付ける）にするなどといった対策をとり、人為的な結合を避けるように努める
- Ex. 変数の人為的な結合
    - モジュールA
        
        ```python
        # 定数を定義
        PI = 3.14159
        
        # 円の面積を計算する関数
        def calculate_circle_area(radius):
            return PI * (radius ** 2)
        ```
        
    - モジュールB
        
        ```python
        from module_a import PI  # モジュールAからPIをインポート
        
        # 別の計算に使用
        def calculate_sphere_volume(radius):
            return (4 / 3) * PI * (radius ** 3)
        
        ```
        
    - あるモジュール内の変数が、別のモジュールで意図せず使用されてしまう。
        - **`PI`** はモジュールAの実装の一部として意図されていたが、モジュールBが直接利用しています。
        - 将来的にモジュールAが**`PI`**を変更した場合（たとえば、名前を変えたり、異なる計算方法に変更）、モジュールBも意図せず影響を受けます。
    

### G14: 機能の羨望

- クラスのメソッドは、別のクラスの変数、関数に関心を持つべきではない
    - あるメソッドが、別のオブジェクトのアクセサを使ってデータにアクセスしている場合、そのメソッドは、別のオブジェクトにアクセスできることを羨望している
- Ex. Bad
    
    ```python
    class Book:
        def __init__(self, title, author):
            self.title = title
            self.author = author
    
    class Library:
        def __init__(self):
            self.books = []
    
        def add_book(self, book):
            self.books.append(book)
    
        def list_authors(self):
            # Bookの内部構造に直接依存している
            return [book.author for book in self.books]
    
    ```
    
    - **`Library`** クラスは **`Book`** の内部実装（**`author`** 属性の存在）に依存しています。
        - 将来、**`Book`** クラスの実装が変わり、**`author`** 属性がなくなった場合や、取得方法が変わった場合、**`Library`** クラスのコードも修正が必要になります。
- Ex. Good
    
    ```python
    class Book:
        def __init__(self, title, author):
            self._title = title
            self._author = author
    
        def get_author(self):
            return self._author
    
    class Library:
        def __init__(self):
            self.books = []
    
        def add_book(self, book):
            self.books.append(book)
    
        def list_authors(self):
            # Bookの公開メソッドを介して情報を取得
            return [book.get_author() for book in self.books]
    
    ```
    
    - **`Library`** クラスは **`Book`** クラスの内部構造を知らなくても、公開されたインターフェイスを使ってデータを取得できます。
    - **`Book`** クラスの内部実装が変更されても、インターフェイスが変わらない限り、**`Library`** クラスへの影響は最小限に抑えられます。

### G15: セレクタ引数

- 関数の引数にbooleanなど、その関数の振る舞いを選択する引数の使用は避けるべき
    - その関数に出くわすたびに、セレクタ引数が何を指すか確認をする必要がある
    - 小さな関数に分割できるのに、セレクタ引数を使用することによって大きな関数になりがち

### G16: 不明瞭な意図

- コードはできる限り表現豊かにし、意図が明瞭である必要がある
    - 長々と続く式、マジックナンバーは作者の意図を不明瞭にする

### G17: 責務を持たせる場所の間違い

- どこにコードを置くかは、ソフトウェア開発者にとって最も重要な判断の一つ
- 驚き最小の原則に従い、コードは読み手が 当然と思う位置におくべき

### G18: 不適切なstatic

- 一般的にはstaticよりも非staticを好むべき
    - staticは、多態性をサポートしていない
    - どうしてもstaticにしたいと感じたときは、多態的な振る舞いが必要になることがありえないか確認をすること
- Ex. Bad
    
    ```python
    HourlyPayCalculator.calculatePay(employee, overtimeRate)
    ```
    
    - 使用するデータは引数のみであるが、多態的に扱いたいケースが出てくるかもしれない
        - `OvertimeHourlyPayCalculator`(残業分の給与を計算する)
        - 非staticであればサブクラスでオーバーライドすることで、多態を表現できるが、staticではそれができない
- Ex. Good
    
    ```java
    Math.max(double a, double b)
    ```
    
    - maxが使用するデータは引数のa,bのみ。オブジェクトが保持するデータは参照しない
    - 多態的に扱う余地がない

### G:19 説明的変数

- プログラムを読みやすくするために、計算の途中結果を変数に格納し、その変数に説明的な名前をつける
- 説明的な変数は少ないよりも多い方が一般的には望ましい
- Ex.
    
    ```java
    if results:
    	key = results[0]
    	value = results[1]
    	...
    ```
    

### G20: 関数名は体を(**振る舞いや性質を明確に**)表すべき

```java
Date newDate = date.add(5); 
```

- date.addは色んな解釈が生まれる
    - dateに5を足すのか。それとも、週か、時間か
        - 5日を足すのであれば、addDaysTo, increaseByDaysのような名前にすべき
    - dateインスタンスは変化するのか。それとも新しいDateを返すのか
        - 新たなインスタンスを返すのであれば、daysLater, daysSinceという名前にすべき
- 関数が何を行うかを知るために、実装を見なければならないのであれば、もっと良い名前を探すか、機能を整理して、もっと良い名前を持った複数の関数に分けるべき

### G21: アルゴリズムを理解する

- アルゴリズムを正しく理解していないと、誤ったロジックや非効率なコードが生まれてしまう
    - テストがすべて通るだけでは不十分であり、アルゴリズムの設計意図や、その解が本当に正しいかどうかを確認する必要がある。
        - 解
            - アルゴリズムが導き出す結果（またはアウトプット)
- 問題を解く本質を見失うと、動作するように見えるが本質的に間違った実装が量産されるリスクがある。

### G22: 論理的な依存性を物理的なものとする

- 論理的な依存性とは
    - 暗黙的な前提や期待の形で表現される依存関係。
    - コード上に明確に記述されていないため、他の開発者やコードの読者にはわかりにくい。
- 物理的な依存性とは
    - コードで明示的に表現された依存関係。
    - クラス間やモジュール間の依存が設計として意図され、コードの中に具体的な形（引数、インターフェース、クラス構造など）で記述されている。
- コード
    - `HourlyReporter`：従業員の勤務時間のデータを扱いやすい形式にする
    `HourlyReportFormatter`：HourlyReporterクラスで作成したデータ形式からプレーンテキストで印刷する
    - Bad
        
        ```python
        class HourlyReporter:
            def __init__(self):
                self.PAGE_SIZE = 55  # フォーマット関連の設定をここで定義している
                self.page = []
        
            def add_line_item(self, item):
                self.page.append(item)
                if len(self.page) == self.PAGE_SIZE:
                    self.print_and_clear_item_list()
        
            def print_and_clear_item_list(self):
                print("Printing page...")
                self.page.clear()
        
        class HourlyReportFormatter:
        	...
        ```
        
        - 問題点
            - **`PAGE_SIZE`** がフォーマットに関連する設定値であるにもかかわらず、**`HourlyReporter`** に属している。
            - フォーマット設定を変更したい場合、**`HourlyReporter`** を直接修正する必要があり、役割の分離が不十分。
    - Good
        
        ```python
        class HourlyReportFormatter:
            def __init__(self, page_size=55):
                self.page_size = page_size
        
        class HourlyReporter:
            def __init__(self, formatter: HourlyReportFormatter):
                self.formatter = formatter
                self.page = []
        
            def add_line_item(self, item):
                self.page.append(item)
                if len(self.page) == self.formatter.page_size:
                    self.print_and_clear_item_list()
        
            def print_and_clear_item_list(self):
                print("Printing page...")
                self.page.clear()
        
        # 使用例
        formatter = HourlyReportFormatter(page_size=55)
        reporter = HourlyReporter(formatter)
        for i in range(60):
            reporter.add_line_item(f"Line {i}")
        ```
        
        - **役割の分離**
            - **`PAGE_SIZE`** が **`HourlyReportFormatter`** に移動し、フォーマット関連の設定が適切な場所に置かれた。
            - **`HourlyReporter`** はフォーマッタの設定値を使うだけで、自身がその責任を負う必要がなくなった。
        - **柔軟性の向上**
            - 異なるページサイズを使用するフォーマッタを簡単に作成可能。
            - **`HourlyReporter`** を修正することなく、フォーマッタを差し替えるだけで対応できる。
        - **依存の明示**
            - **`HourlyReporter`** のコンストラクタで **`HourlyReportFormatter`** を受け取ることで、明示的に依存が宣言された。

### G23: if/elseやswitch/caseよりも多態を好む

- switchを使うよりも多態を検討する
    - 同じ条件分岐が複数箇所で使われる
    - 新しい型を追加するたびに、すべてのswitch文を修正する必要がある。
    - 条件分岐が増えるほどコードが煩雑になる。
- 筆者は「1つのswitch」ルールに従っている
    - ある型の選択において、switch文はひとつまでにすること。このswitch文は多態的にオブジェクトを生成し、システムの残りの部分では、代わりにこれを利用する
        - → switch文の役割は、異なる型のインスタンスを生成することだけに限定する

### G24: 標準の規約に従う

- 業界で一般的なコーディング標準に従うべき

### G25: マジックナンバーを名前付けした定数に置き換える

- 一部の一目瞭然の数値を除き、数字をそのままコードの中に置くのは、望ましくない

### G26: 正確であれ

- 自分のコードに対し何か決断を行うときには、正確**に**行うことを心がける
    - 決断の精度に無頓着にならないこと
    - コードの曖昧さ、不正確さは、不調和あるいは怠惰につながる
- Ex.
    - 同時更新がそんなに起きないからと、ロックとトランザクションの両方、あるいはどちらかわを使わない
        - → 可能性があるのなら、何らかのロック機構を実装する
    - nullを返すかもしれない関数があるのなら、nullチェックを忘れない

### G27: 規約より構造

- 設計を強制するには、規約よりも構造を優先する
    - うまく名前付けされたswitch / case文よりも、抽象メソッドを定義したベースクラスの方が、具象クラスはメソッドの実装が強制される

### G28: 条件をカプセル化せよ

- ブール論理の理解は、容易ではない。条件の意図を説明する関数を抽出する
    - 条件によっては、直接書いた方がわかりやすいこともあるため、うまく使い分けること
- コード
    - Bad
        
        ```python
        if timer.hasExpired() and not timer.isRecurrent():
            # 処理
        ```
        
        - **この条件が何を表しているのか**を理解するには、**`hasExpired()`**や**`isRecurrent()`**が何を意味するのかを知る必要があります。
    - Good
        
        ```python
        if shouldBeDeleted(timer):
            # 処理
        ```
        
        - 条件式全体を「**shouldBeDeleted**」という名前の関数に抽出しています。
        - この関数名を見るだけで、条件の意図（「削除すべきタイマーかどうかを判断している」）が明確になります。

### G29: 条件の否定系を避ける

- 否定系の条件は分かりづらい。できるだけ条件は肯定系で表現するようにする

### G30: 関数では1つのことを行うべき

- 複数のセクションで構成され、いくつかの処理を連続して行う関数がしばしば作成されがち
    - こうした関数は複数のことを行うことになる
    - 1つのことを行う関数に分解すべきである
    - [関数は1つのことを行うようにする(単一責務の原則)](https://www.notion.so/1-12693db0555480478719ee3fbf0a5df8?pvs=21)

### G31: 隠れた時間軸上の結合

- 時間軸上の結合は隠してはいけない
    - 引数をうまく構成して呼び出すべき順序が明確になるようにする
- Ex. コード
    - Bad
        
        ```python
        class MoogDiver:
            def dive(self, reason):
                self.saturate_gradient()
                self.reticulate_splines()
                self.dive_for_moog(reason)
        ```
        
        - 上記dive内の関数の呼び出し順序は重要であるが、これでは時間軸上の強制は行えていない
    - Good
        
        ```python
        	class MoogDiver:
            def dive(self, reason):
                gradient = self.saturate_gradient()
                splines = self.reticulate_splines(gradient)
                self.dive_for_moog(splines, reason)
        
        ```
        
        バケツリレーのように、それぞれの関数が後続の関数が必要とする引数を生成するため、間違った順序で呼ぶことができなくなっている
        

### G32: いいかげんにならないこと

- コードを構成するときは根拠を持つこと。根拠とコードの構造との間に矛盾が生じないようにすること

### G33: 境界条件はカプセル化する

- 境界条件を常に追うのは大変であるため、この条件は一箇所にまとめておく
- Ex.
    
    ```java
    if (level + 1 < tags.length)
    {
     parts = new Parse(body, tags, level + 1, offset + endTag):
     body = null
     }
    ```
    

- level + 1が2回現れている。これは境界条件であり、nextLevelのような名前の変数にカプセル化すべき

### G34: 関数は一つの抽象レベルを担うべき

- 1つの関数の中の分は同じ抽象レベルで書かれるべき
    - → 関数の名前で表現された操作の1つ下のレベルとなるべき
- コード
    - Bad
        
        ```python
        def process_user_registration(user_data):
            # 高レベルの操作
            save_user_to_database(user_data)
            
            # 低レベルの操作（抽象度が低い）
            email_body = f"Welcome {user_data['name']}! Thank you for registering."
            smtp_server = smtplib.SMTP("smtp.example.com", 587)
            smtp_server.starttls()
            smtp_server.login("admin@example.com", "password")
            smtp_server.sendmail(
                "admin@example.com",
                user_data["email"],
                email_body
            )
            smtp_server.quit()
        ```
        
        - `process_user_registration`は、「ユーザー登録を処理する」という高い抽象度を持つ名前だが、内部には直接メール送信の詳細な処理が含まれている
        - 異なる抽象度のコードが混在しているため、関数の目的が不明瞭で変更やテストが困難
    - Good
        
        ```python
        def process_user_registration(user_data):
            # 高レベルの操作
            save_user_to_database(user_data)
            send_welcome_email(user_data)
        
        def send_welcome_email(user_data):
            # 中レベルの操作
            email_body = create_welcome_email_body(user_data)
            send_email("admin@example.com", user_data["email"], email_body)
        
        def create_welcome_email_body(user_data):
            # 低レベルの操作
            return f"Welcome {user_data['name']}! Thank you for registering."
        
        def send_email(sender, recipient, body):
            # 低レベルの操作
            smtp_server = smtplib.SMTP("smtp.example.com", 587)
            smtp_server.starttls()
            smtp_server.login("admin@example.com", "password")
            smtp_server.sendmail(sender, recipient, body)
            smtp_server.quit()
        ```
        
        - **`process_user_registration`** は「ユーザー登録を処理する」という高レベルの操作に専念。
        - メール送信の詳細な処理は **`send_welcome_email`** やさらに下位の関数に委譲。
        - 各関数が1つの抽象レベルを担うため、コードの役割が明確になり、読みやすさが向上。
- ポイント
    1. **関数名と内容の整合性**
        
        関数名で表現される抽象度を下回る詳細な処理は、別の関数に切り出します。
        
    2. **再利用性とテスト性**
        
        低レベルの関数は他の文脈でも再利用可能であり、テストも個別に実施しやすいです。
        
    3. **変更の影響を局所化**
        
        例えばメールの送信方法が変わったとしても、**`send_email`** のみ修正すれば済みます。
        

### G35: 設定可能なデータは高いレベルに置く

- 高い抽象レベルで使用される定数、デフォルト値は、それを低レベルの関数の中に埋め込まない
- 高いレベルの関数から、低いレベルの関数を呼び出す時の引数として明示する
    - 高いレベルに位置することで、容易に変更ができるため
- Ex. コード
    - Bad
        
        ```python
        def calculate_discount(price, discount_rate=0.1):  # デフォルト値が埋め込まれている
            return price * (1 - discount_rate)
        
        def process_order(order):
            total = calculate_discount(order['price'])  # デフォルト値を使用
            print(f"Total after discount: {total}")
            
        def process_bulk_order(order):
            total = calculate_discount(order['price'])  # デフォルト値を使用
            print(f"Bulk order total: {total}")
        ```
        
        - **`discount_rate`** の値が低レベルの関数 **`calculate_discount`** に埋め込まれているため、変更が難しい。
            - 理由
                - **`discount_rate`** を例えば **`0.15`** に変更したい場合、**`calculate_discount`** のデフォルト値を変更する必要がある。
                - この変更により、**`process_order`** と **`process_bulk_order`** の両方に影響が出る。
                - 各関数で異なる割引率を使用したい場合、**`calculate_discount`** を呼び出す全ての箇所を修正し、明示的に引数を渡す必要が出てくる。
        - デフォルト値が「どこで設定されているか」がコード全体から見えにくい。
    - Good
        
        ```python
        def calculate_discount(price, discount_rate):
            return price * (1 - discount_rate)
        
        def process_order(order, default_discount_rate=0.1):  # 高いレベルで制御
            total = calculate_discount(order['price'], default_discount_rate)
            print(f"Total after discount: {total}")
        
        def process_bulk_order(order, bulk_discount_rate=0.15):
            total = calculate_discount(order['price'], bulk_discount_rate)  # 高いレベルで制御
            print(f"Bulk order total: {total}")
        ```
        
        - **`default_discount_rate`** は高いレベルの関数 **`process_order`** , `**process_bulk_order**`で設定されているため、デフォルト値が明示的でわかりやすい。
        - **`calculate_discount`** は設定に依存せず、純粋な計算ロジックを持つ低レベル関数として再利用可能。
        - デフォルト値を変更する場合、高いレベルの関数を修正するだけで済む。

### G36: 推移的なナビゲーションを避ける

- 1つのモジュールに、協調動作する他のモジュールについての知識をあまり持たせたくはない。
    - AとBが協調動作、BとCが協調動作する場合に、Aを使用するモジュールには、Cについての知識を持たせたくない
        
        → `a.getB().getC().doSomething();`という呼び出しは行いたくない
        
        - デメテルの法則と呼ばれる
- モジュールは協調動作するモジュールについてのみの知識を持つべきで、システム全体図を知るべきではない

## 名前

---

### N1: 記述的な名前を選ぶ

- 名前はソフトウェアの読みやすさを9割方支配している
- 名前をつけるときに、急ぎすぎずに記述的になるようにする
    - 記述的: 名前がその役割や目的を正確に説明する

### N2: 抽象レベルに適切な名前を選ぶ

- 今作業しているクラス、関数の抽象レベルを反映した名前をつけるようにする
- Ex. コード
    - Bad
        
        ```python
        def process_data(data):
            # データをフィルタリング
            filtered_data = [x for x in data if x > 10]
            # 平均を計算
            average = sum(filtered_data) / len(filtered_data)
            return average
        
        ```
        
        - 関数名 **`process_data`** は曖昧で、関数の中身が何をしているのか推測しづらい。
        - 「データを処理する」という抽象レベルに対して、中で行われている操作（フィルタリングや平均計算）が具体的すぎる。
    - Good
        
        ```python
        def calculate_average_of_filtered_data(data, threshold=10):
            filtered_data = [x for x in data if x > threshold]
            return sum(filtered_data) / len(filtered_data)
        ```
        
        - 関数名 **`calculate_average_of_filtered_data`** は具体的で、この関数の目的が明確に伝わる。
        - 関数内の処理内容と抽象レベルが一致している。

### N3: 可能な限り標準の用語を使用する

- 既存の規約、利用に基づいた名前は理解が容易のため、可能な限り使用するべき
    - Ex.
        - デコレーターパターンを使用しているのであれば、Decoratorという名前をつける
        - ユビキタス言語(ある特定のプロジェクトの名前体系標準の定義)を使用する

### N4: はっきりした名前

- 関数や変数の働きを的確に表す名前を選ぶ

### N5: 広いスコープには長い名前を

- 名前の長さは、スコープの広さに対応させるべき
- 小さなスコープで使用する変数名は短いもので良い
    - `i`とか`j`は5行までのスコープに相応しい

### N6: エンコーディングを避ける

- 名前の中に型やスコープの情報を埋め込んではいけない

### N7: 名前で副作用を示すべき

- 関数、変数、クラスが何であり、何をするのかを名前で表現すべき
- 副作用を名前の下に隠してはいけない
- Ex.  コード
    - Bad
        
        ```python
        def update_user(user):
            # ユーザー情報を更新し、データベースに保存する
            user["last_login"] = "2024-12-01"
            save_to_database(user)
        ```
        
        - 名前 **`update_user`** からは、この関数がデータベースに保存する副作用を伴うことがわからない。
        - データベース操作を行うなら、その意図を名前に含めるべき。
    - Good
        
        ```python
        def update_user_and_save(user):
            # ユーザー情報を更新し、データベースに保存する
            user["last_login"] = "2024-12-01"
            save_to_database(user)
        
        ```
        
        - 名前に **`save`** が含まれることで、データベースに変更があることを明確に示している。
    - Goodコードの疑問をChatGPTへ
        
        andで繋げると、その関数は一つのことをやっておらず、単一責務の原則に反しているように見えるのですが、こちらについてはいかがでしょうか 
        
        - **`and`** が関数名に含まれる場合は、単一責務の原則に反している可能性があります。ただし、次のケースでは例外的に許容されることもあります：
            - 操作が密接に関連している。
                - **`update_user_and_save`** のように、「ユーザー情報を更新し、それを保存する」という2つの操作が密接に関連している場合、関数としてまとめても違和感が少ない場合があります。これらは同じ目的（ユーザー情報の変更を反映する）を達成するために必要な一連の操作だからです。
            - 関数の抽象レベルが統一されている。
            - 分離することで再利用性や可読性が著しく向上するわけではない。
        - 1つのこととは、**抽象度が統一された1つの責務**を指します。以下の点を意識すると、単一責務を守りやすくなります：
            - **抽象度の統一:**
                - 関数内の操作が同じ抽象レベルにあるか確認します。
                - 例: **`update_user_and_save`** は「ユーザーを更新する」抽象レベルの範囲内と見なせる場合があります。
            - **意図を明確に:**
                - 関数名に具体性を持たせて、単一責務であることを示す。
                - もし **`and`** を使わざるを得ないなら、責務が曖昧になっていないか確認します。

## テスト

---

### T1: 不十分なテスト

- 一つのテストスイートには幾つのテストが必要か
    - テストスイートは、壊れる可能性のあるところ全てに対して行うべき
    - 網羅されていない条件、検証されていない計算処理があるのなら、十分とはいえない

### T2: カバレッジツールを使用する！

- テストのやり方の中に存在する、ずれを報告してくれる。
    - テストが不十分なモジュール、クラス、関数を簡単に見つけることができる

### T3: ささいなテストを省略しない

- テストが些細なものなら、書くことも簡単
    - それに書くことのコストを上回るドキュメントとしての価値がある

### T4: 無視することを指定されたテストは、あいまいさへの問いかけである

- 時として振る舞いの詳細がよくわからないことがある
    - → 要件が不明確だから
- 疑問点をテストで示し、コメントアウトして残しておく

### T5: 境界条件テスト

- 境界条件のテストには注意を払う
    - 境界条件を間違えていることが よくある

### T6: バグの周辺は徹底的にテストを

- バグには群を作る修正がある
    - ある関数にバグを発見したら、その関数を徹底的にテストするのが賢い。おそらく他にもバグは出てくる

### T7: 失敗パターンは何かを語る

- テストケースの失敗パターンから、問題を発見できることがある
    - なるべくテストを完璧に行うべきであるという主張を裏付ける、もう一つの根拠でもある
- Ex.
    - 全てのテストが、5文字を超える入力に対して失敗する
    - 関数の第二引数に負の数値を与えると、どのテストもことごとく失敗する

### T8: テストカバレッジのパターンは何かを語る

- 成功したテストにおいて、実行された行と実行されなかった行とを見ることが、失敗した原因のヒントになることがある

### T9: テストは高速であるべき

- 遅いテストは、結局実行されない
- 状況が逼迫していれば、実行に時間がかかるテストは削除されてしまう
- 高速なテストコードを書く