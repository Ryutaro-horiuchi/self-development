筆者とマーチン・ファウラーのリファクタリングのクロスリファレンス

## コメント

---

### C1: 不適切な情報

- 更新履歴等をコメントに載せるのは不適切なコメント

### C2: 退化コメント

- 古くなったコメント、間違ったコメントは退化コメント
- 発見したら、すぐに最新化するか取り除く

### C3: 冗長なコメント

- それ自体を正確に記述しているコメントは冗長なコメント
    
    Ex. 
    
    ```java
    i++; // iを1増やす
    ```
    

### C4: 記述不足のコメント

- 十分に記述されていなければ価値がない
    - 単語を慎重に選ぶ、正確な文法、句読点の付け方を心がける
    - とりとめのないことを書かない
    - 当たり前のことを記述しない

### C5: コメントアウトされたコード

- コメントアウトされたコードは残り続けやすい
    - 他の誰かが必要としている、将来的に削除する予定があると思っているから
    - 残り続けたコメントアウトのコードは日を追うごとに腐敗し、現在のコードの規約にそぐわない過去のものとなる
- コメントアウトされたコードを見つけたら即削除する
    
    削除されたコメントが例え必要だったとしても、ソースコード管理システムを辿れば良い
    

## 環境

---

### E1: ビルドに複数のステップを要する

- プロジェクトのビルドは単一の簡単な操作でなければならない
- ビルドをするのに、細々としたものをいくつもチェックアウトすることを要するようなことや、特定の環境に依存したスクリプトが必要となる状況は避けるべき
- 1つのコマンドでシステムをチェックアウトし、もう一つのコマンドによってビルドできるようにするべき

### E2: テストに複数のステップを要する

- コマンド一発ですべての単体テストが実行できるようにしておくべき

## 関数

---

### F1: 多すぎる引数

- 関数の引数は少なくすべき。ないのがベスト
- 3つはできるだけ避けるべき。4以上は、よほどの理由がない限りやめる。

### F2: 出力引数

- 出力引数は直感的ではない。
- 出力引数
    - 与えられた引数に変更を加えること

### F3: フラグ引数

- Boolean引数は関数が二つ以上のことを行なっていることを声高に宣言している。混乱を招くのでやめるべき

### F4: 死んだ関数

- どこからも呼び出されないメソッドは削除すべき
    - デッドコードをそのままにしておいても無駄
    - 削除してもソースコード管理システムが覚えていてくれるから躊躇する必要なし

## 一般

---

### G1: 1つのソースファイルに複数の言語を使用する

- 理想的なのは、1つの言語のみでソースファイルが構成されること
- 現実的には2つ以上の言語を使うことになるが、例え苦労をしてでも、ソースファイルの中で使用する余計な言語の数と量を最小化すべき

### G2: あって当然の振る舞いが実装されていない

- 「驚き最小の原則」に従い、プログラマがその命名から当然と期待する振る舞いをあらゆる関数、クラスが行うようにすべき

### G3: 境界値に対する不正確な振る舞い

- あらゆる境界条件、さまざまな特殊ケース等が、アルゴリズムを複雑にする。
- 動作すると思って直感を信じるのではなく、それを証明するために、あらゆる境界条件を含んだテストを隅々まで行うこと

### G4: 安全軽視

- 「失敗するテストを無視して、後で通るようにすれば良い」といったような軽視をしない

### G5: 重複

- 重複コードが存在するところでは、抽象化の機会が失われている
    - 重複部分は明らかにサブルーチンか別のクラスにできる
    - 重複を抽象化することで、別のプログラマがその抽象化機構を使用することができる
    - コーディングを素早くできるようになり、エラーも起きにくくなる

### G6: 抽象レベルが正しくないコード

- 高いレベルの概念は抽象クラスのみに持たせ、継承クラスに低いレベルの概念のみを持たせる
    - 実装詳細にのみ関係する定数、変数、ユーティリティ関数はベースクラスに置くべきではない

### G7: 継承クラスに依存したベースクラス

- ベースクラスは継承クラスの知識を持たない
    - ベースクラスが、継承クラスの名前を知っていたとしたら、何らかの問題があることを疑った方が良い

### G8: 情報過多

- うまく定義されたモジュールは、とても狭いインターフェイスを持ちながら、多くのことをこなす。対して不完全に定義されたモジュールは、広く深いインターフェイスを持ち、単純なことを行うにもさまざまな指定を必要とする
    
    <aside>
    💡
    
    クラス、モジュールの外部へのインターフェイスの公開を最低限に抑えること
    
    </aside>
    
- うまく定義されたモジュール
    - **少ない依存関係**: インターフェイスがうまく設計されている場合、必要最小限の関数やメソッドだけを公開しています。
    - **結合度が低い**: 呼び出し元（クライアント）は、必要な情報だけを取得でき、余計な詳細を知る必要がありません。
    - Ex. データベース操作を抽象化したインターフェイス。
        
        ```python
        class UserRepository:
            def get_user(self, user_id: str) -> User:
                pass
        ```
        
        - **`get_user`** を呼び出すだけでユーザー情報を取得できる。データベースクエリや接続管理などの詳細を知る必要がありません。
- 不完全に定義されたモジュール
    - **多すぎる依存関係**: 不適切に設計されたインターフェイスは、クライアントに多くの関数やメソッドを呼び出すことを強制します。
    - **結合度が高い**: 呼び出し元はこれらすべての関数を順序通りに使用する必要があり、内部構造や実装の詳細に依存します。
    - Ex. データベース操作の不完全なインターフェイス
        
        ```python
        class BadUserRepository:
            def connect_to_database(self):
                pass
        
            def execute_query(self, query: str):
                pass
        
            def parse_results(self, raw_data):
                pass
        ```
        
        - インターフェイスの多くのメソッドを呼び出さなければ目的を達成できない
        - インターフェイスに変更があると、クライアントコード側も修正が必要になる。

### G9: デッドコード

- デッドコードとは実行されることのないコード。害なので削除する
- Ex.
    - 決して成立することのない条件を持ったif文
    - 例外をスローしない try catchブロック

### G10: 垂直分離

- 変数と関数は、それが使用される場所の近くで定義すべき
    - ローカル変数はそれが使用される場所の直前で定義すべきで、縦方向のスコープを最低限に限定すべき

### G11: 不整合

- 何かを行うときに、ある方法を使用するのなら、それに類すること は全て同じ方法で行えるべき
- Ex.
    - HttpServletResposeオブジェクトを保持する変数名をresponseと名付けたのなら、他の箇所でHttpServletResposeオブジェクトを使用する関数でも、同じ変数名を名付けるべき

### G12: 雑然

- 未使用変数、呼ばれることのない関数、何の情報も提供しないコメントはゴミでしかなく、削除すべき

### G13: 人為的な結合

- 人為的な結合とは、2つのモジュール間の直接の意図のない結合のこと
    - 変数、定数、関数を、そこが不適切な場所にも関わらず、単に一時的に便利だからという理由で入れてしまうことによって起こる
- 他モジュールが使用すべきでないものは明示的に非公開（例: **`_`** を付ける）にするなどといった対策をとり、人為的な結合を避けるように努める
- Ex. 変数の人為的な結合
    - モジュールA
        
        ```python
        # 定数を定義
        PI = 3.14159
        
        # 円の面積を計算する関数
        def calculate_circle_area(radius):
            return PI * (radius ** 2)
        ```
        
    - モジュールB
        
        ```python
        from module_a import PI  # モジュールAからPIをインポート
        
        # 別の計算に使用
        def calculate_sphere_volume(radius):
            return (4 / 3) * PI * (radius ** 3)
        
        ```
        
    - あるモジュール内の変数が、別のモジュールで意図せず使用されてしまう。
        - **`PI`** はモジュールAの実装の一部として意図されていたが、モジュールBが直接利用しています。
        - 将来的にモジュールAが**`PI`**を変更した場合（たとえば、名前を変えたり、異なる計算方法に変更）、モジュールBも意図せず影響を受けます。
    

### G14: 機能の羨望

- クラスのメソッドは、別のクラスの変数、関数に関心を持つべきではない
    - あるメソッドが、別のオブジェクトのアクセサを使ってデータにアクセスしている場合、そのメソッドは、別のオブジェクトにアクセスできることを羨望している
- Ex. Bad
    
    ```python
    class Book:
        def __init__(self, title, author):
            self.title = title
            self.author = author
    
    class Library:
        def __init__(self):
            self.books = []
    
        def add_book(self, book):
            self.books.append(book)
    
        def list_authors(self):
            # Bookの内部構造に直接依存している
            return [book.author for book in self.books]
    
    ```
    
    - **`Library`** クラスは **`Book`** の内部実装（**`author`** 属性の存在）に依存しています。
        - 将来、**`Book`** クラスの実装が変わり、**`author`** 属性がなくなった場合や、取得方法が変わった場合、**`Library`** クラスのコードも修正が必要になります。
- Ex. Good
    
    ```python
    class Book:
        def __init__(self, title, author):
            self._title = title
            self._author = author
    
        def get_author(self):
            return self._author
    
    class Library:
        def __init__(self):
            self.books = []
    
        def add_book(self, book):
            self.books.append(book)
    
        def list_authors(self):
            # Bookの公開メソッドを介して情報を取得
            return [book.get_author() for book in self.books]
    
    ```
    
    - **`Library`** クラスは **`Book`** クラスの内部構造を知らなくても、公開されたインターフェイスを使ってデータを取得できます。
    - **`Book`** クラスの内部実装が変更されても、インターフェイスが変わらない限り、**`Library`** クラスへの影響は最小限に抑えられます。