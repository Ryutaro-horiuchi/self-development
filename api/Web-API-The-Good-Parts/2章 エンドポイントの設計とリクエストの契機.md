## APIの設計を考えるにあたって

- ポイントは公開したAPIがどのように使われるのか、そのユースケースをきちんと考えること
    - 本書では画面とその遷移を用意し、その図からどういったAPIを用意すべきか一通り列挙していく

## エンドポイントの基本的な設計

- WebAPIのエンドポイントとはURIのこと
- 良いURLの設計とは
    - 抽象
        
        <aside>
        💡 覚えやすく、どんな機能を持つURLなのか一目でわかる
        
        </aside>
        
    - 具体
        - 短く入力しやすいURI
        - 人間が読んで理解できるURI
        - 大文字小文字が混在していないURI
        - 改造しやすい(Hackableな)URI
        - サーバー側のアーキテクチャが反映されていないURI
        - ルールが統一されたURI

### 人間が読んで理解できるURI

- むやみに省略形を使用しない
    - わかりづらいURIを生みがち
    - Ex.
        
        ```
        http:///api.example.com/sv/u/
        ```
        
- よく使われている**英単語**を使用する
    - Ex. 探す
        - search ⭕️
        - find ❌

### 大文字小文字が混在していないURI

- ホスト名は小文字で表記されるため、それに続くパスも小文字の方が読みやすい
- 既存のURIに、大文字でアクセスがあった場合は404で返すのが一般的(Ex. Github)
    - HTTPにおいてURIは「スキーマとホスト名を除いては大文字と小文字は区別される」という仕様であるため(RFC7230)

### 改造しやすいHackableなURI

```
thttp:///api.example.com/v1/items/12346
```

- 上記のURIを見て、itemsの後に続くパスの番号を変えれば、他の商品を取得できる事がわかる
- APIを使用する側にとって、いちいちドキュメントを見てAPIを使用するのはストレスが溜まる
    
    → URIから他のURIを想像できるようなAPIであれば、ドキュメントを見なくても開発を進める事ができ、見なかったことによって引き起こされるバグの問題も起きづらくなる
    

### ルールは統一させる

- 複数形・単数系は統一させる
    - [複数形の名詞を利用する](https://www.notion.so/f1ceb74022b84ab7a5c6f3f340fceb42?pvs=21)
- 使用するパス・クエリパラメーターの統一など

## HTTPメソッドとエンドポイント

- HTTPのメソッドは、HTTPリクエストヘッダの先頭行の最初に以下のようにつけられて、サーバーに送信される
    
    ```
    GET /v1/users/123 HTTP/1.1
    Host: api.example.com
    ```
    
- URIとメソッドの関係
    - 操作するものと操作方法の関係である
    - URIのRはリソースを意味しており、何らかのデータである。メソッドは操作するかを表す
    - 一つのURIのエンドポイントに異なるメソッドでアクセスすることで、リソースに対してどう扱うかをきちんと分離して考えられる
- HTML4.0(現在は5.0)では、GETとPOSTしか用意されていない

### GETメソッド

- 「情報の取得」を表す
- GETメソッドに対してサーバー上の情報を変更する処理を書くのはご法度

### POST

- 新しいリソースを送信する
- POSTはそのリソースの下に従属関係となる新たなデータを作成する

### PUT

- 指定したデータを完全に更新する

### DELETE

- リソースの削除

### PATCH

- PUTと違い、データの一部を変更するということを明示したメソッド

## POSTを使用して、内部的に他のメソッドであることをサーバーに知らせる

前提

HTMLのformタグでは、GET, POSTしか使えない。しかしAPIによってはGET, POST以外のメソッドで定義されているものもある

API側でPUT, PATCH, DELETEのメソッドをPOSTを使って表現することを許可する事が可能。二通りの方法がある

### X-HTTP-Method-Overrideヘッダ

本題

- 以下のようにしてX-HTTP-Method-Overrideヘッダにて、本当に使用したいメソッドをサーバー側に送信する事ができる
    
    ```
    POST /v1/users/123 HTTP/1.1
    Host: api.example.com
    X-HTTP-Method-Override: DELETE
    ```
    

### application/x-www-form-urlencodedで、_methodパラメーターを指定する

- application/x-www-form-urlencodedのContentTypeで表されるデータの一部として_methodパラメーターを使用する。
- Ruby on Railsなどでよく採用されている方法
    
    ```
    user=testuser&_method=PUT
    ```
    
- Content-Typeをapplication/x-www-form-urlencoded以外の形式でデータを送信する場合に使用できなく、使い方をはっきり定義できない側面もあるため、X-HTTP-Method-Overrideヘッダの方が利用しやすい

## WebAPIエンドポイントの基本的な設計

| 目的 | エンドポイント | メソッド |
| --- | --- | --- |
| ユーザー一覧取得 | http://api.example.com/v1/users | GET |
| ユーザーの新規登録 | http://api.example.com/v1/users | POST |
| 特定のユーザーの情報の取得 | http://api.example.com/v1/users/:id | GET |
| ユーザーの情報の更新 | http://api.example.com/v1/users/:id | PUT/PATCh |
| ユーザーの情報の削除 | http://api.example.com/v1/users/:id | DELETE |
- usersはユーザーの集合
    - データベースで例えるならテーブル名
- users/:idは個々のユーザーを意味する
    - データベースで例えるならレコード
- 上記のテーブルやレコードに対してどのような操作をするのかがHTTPメソッド

<aside>
💡 「あるデータの集合」と　「個々のデータ」をエンドポイントとして表現し、それに対してHTTPメソッドで「操作」を表していく考え方はWebAPI設計の基本中の基本である

</aside>

### 複数形の名詞を利用する

- データベースのテーブル名が複数形を用いるのが適切と言われているのと同様に、usersやfriendsは「集合」を表しているものであるので、複数形の方が適切であるとされている
- 名刺を利用するのは、HTTPのURIがそもそもリソースを表すものであるから
- 動詞はHTTPメソッドの役割であるため、いれないのを本書では推奨

### 利用する単語に気をつける

- 適切な単語を使用する
    
    → 他の類似のAPIでは、どの単語を使用しているかを調べてみる
    

### パーセントエンコードする文字は使わない

- スペースなどはURIでは利用できないため、パーセントエンコードされる
    - パーセントエンコードされているAPIは一目見て、なんのAPIかわからないため、使用しない

### 単語を繋げる必要があるときは、ハイフンを利用する

- Googleが推奨
    - アンダースコアは無視して一つの単語としてみなす
        
        リンクアドレスに下線が引かれるが、これがアンダースコアと被って見にくいなど
        
- ドメインはハイフンは許可されているが、アンダースコアは許可されていない
    - ホスト名と同じルールでURI全体を統一しようとするとハイフンで繋ぐのが適している
- なるべく複数の単語を繋げないのも重要
    - パスで区切るなど
        
        ```
        popular_users -> users/popular
        ```
        

## 検索とクエリパラメータの設計

### ページネーションのパラメーター

- 取得数と取得位置を設定する
    - 取得位置の指定方法は絶対位置と相対位置とに分かれる
        
        [相対位置指定だと、途中でデータを削除されたときなどに不整合が起きる](https://www.notion.so/976127fed1fa4b6fa039b3d6a9839f68?pvs=21) 
        
    - 一般的な取得数と取得位置のパラメータ
        - limit / offset   `?limit=50&offset=100`
            - limit / offsetの方がper_pageのセットと比べて自由度が高い
        - per_page / page `?per_page=50&page=3`
- 相対位置
    - [クエリパフォーマンスの問題](https://www.notion.so/36beeb8ff3bb477fae37b0fb901be0b4?pvs=21)
    - 相対位置だと先頭から順にデータを数える必要があるため、処理に時間がかかる
- 絶対位置
    - 一般的なパラメーター
        - since_id / max_id

### 検索のパラメーター

- 絞り込む要素名、値には絞り込む値を指定するのが一般的(完全一致)
    - `users?name=ken`
- 検索するフィールドが、明らかな場合はqというパラメーターが使用される事が多い(部分一致)
    - `users?q=jack`

### クエリパラメーターとパスの使い分け

- 一意なリソースを表すのに必要な情報かどうか
    - ユーザーidは、ユーザーidを指定することで情報が一意に決まるため、パスに入れた方が良い
- 省略可能かどうか
    - 先の検索パラメーターなどは省略すると、一覧を取得するAPIとなるため、省略可能であると判断できる

## OAuthの基本的な仕組み

- 認可を行うために用いられる
    1. ユーザー登録機能(Facebook等)があるサービスAがAPIを公開していて、そのAPIを使用するサービスBがあったとする
    2. サービスAに登録しているユーザーが、サービスBを利用したい時に、サービスBはサービスAのユーザー情報を取得したい
    3. サービスBに対して、ユーザーがサービスAに登録している情報を利用して良いかの許可を与える仕組みがOAuth
- 仕組み
    - サービスAに「サービスAは、~のデータにアクセスできます。信用(認可)しますか？」との質問にはいと答えると、サービスBに渡す用のトークンを返される
    - ユーザーは、サービスBにトークンを渡してサービスAにアクセスするようにする事で、リソースを得る事ができる

### OAuthのエンドポイントの例

- Twitterで使用されている`/oauth2/token`が一番わかりやすい

### Grant Type

- OAuthには、リソースにアクセスするための手段が4つ定められており、Grant Typeと呼ばれている
- AuthorizationCodeとImplicit
    - FacebookやTwitterが提供しているような、サービスAに保存している情報へのアクセス許可をする仕組み
- ClientCredentials
    - サービスAが特定のユーザーの許可を必要としない

### Resource Owner Password Credentials

- Grant Typeの一つであり、サーバーサイドを利用しないアプリケーション向け
- フロー
    1. クライアントアプリケーションは、自身のクライアントIDとクライアントシークレット情報を用意
    2. クライアントアプリケーションにて、ユーザーからユーザー名とパスワードを取得。
    3. クライアントアプリケーションは、ID、シークレット、ユーザーの認証情報をもとに直接認可サーバー(サービスA)にリクエストを送る
    4. 認可サーバーは認証情報が有効かを検証してアクセストークンをクライアントアプリケーションに値を返す。(以降は一般的なOAtuthと同様)
    5. クライアントアプリケーションは、取得したアクセストークンを使用して、リソースサーバーに対してリクエストを行い、ユーザーのリソースにアクセスします。
    
    - 3 のリクエスト時
        - エンドポイントに対して、application/x-www-form-urlencodedの形式で、以下のデータを含める必要がある
            - grant_type
                - passwordという文字列で良い。「Resource Owner Password Credentials」であることを示す
            - username
            - password
            - scope
                - アクセスのスコープを指定する
        - Authorizationヘッダ
            - 新しく利用しようとしているサービス(クライアントアプリケーション)が何なのかを特定するための情報
            - 認可サーバーから返されたクライアントID/クライアントシークレット(任意)を、ユーザー名 / パスワードとみなしてBasic認証の形式でBase64変換したものが入っている
            - クライアントID
                - クライアントアプリケーションを一意に識別するための識別子です。認可サーバーによって発行され、クライアントアプリケーションがリクエストを送る際に含まれます
            - **クライアントシークレット**
                - クライアントアプリケーションが認可サーバーに対して自身を認証するための秘密情報です。秘密鍵のようなもので、認可サーバーがクライアントアプリケーションを信頼するための手段
    - 4のレスポンス時
        - 今後使用するaccess_tokenが返される
        - token_typeのbearerは、OAuth2.0用のトークン形式
    - 5のリクエスト時
        - Authorizationヘッダに、4で受け取ったリクエストをセットする
            
            ```
            Authorization: Bearer b77xxxxxxx
            ```
            

## SSKDsとAPIデザイン(内部向けのAPI)

- 外部に公開しないAPIでエンドユーザーにとっての体験を意識すると、一般的な定石に則って実装した場合、必ずしも良しと言えない
    - 一つの画面(Ex. ホーム画面)を生成するのにたくさんのAPIを呼ぶことにつながりやすい
        - 画面を表示するのに時間がかかる
        
        → ホーム画面表示用のAPIにアクセスするだけで必要な情報を全て取得できるAPIを作成した方が利便性が高い
        
- 2014年3月 「API Strategy and Practive」Michele Titolo氏とPaul Wrightの講演
    
    <aside>
    💡 1スクリーン1APIコール、1セーブ1APIコール
    一つの画面を表示するのにコールするのが1つのAPIで済むようにそれに合わせたAPIを用意し、データを保存する場合にも1回のコールで済むようにAPIを用意するのが良い
    
    </aside>
    

## HATEOASとREST LEVEL3 API

前提

ハイパーテキスト

- 文書データ上のテキストや画像などをクリックすることで別のページに移動する仕組みを指します

### HATEOAS(hypermedia as the engine of application state)とは

APIの返すデータの中に次に行う行動、取得するデータ等のURIをリンクとして含めることで、そのデータを見れば次にどのエンドポイントにアクセスをすればよいかがわかるような設計のこと

### REST LEVEL3 API

- HATEOASの概念を導入したもの
- メリット
    - あらかじめURIを知る必要がないため、URIの変更がしやすい
    - 改造しやすいURLで実装する必要がなくなる
        
        → セキュリティの観点では吉
        

## まとめ

良いAPIとは

- 覚えやすく、どんな機能を持つかが一目でわかるエンドポイントにする
- 適切なHTTPメソッドを使用する
- 適切な英単語を使用し、単数系、複数形にも注意する
- 認証にはOAuth2.0を使用する