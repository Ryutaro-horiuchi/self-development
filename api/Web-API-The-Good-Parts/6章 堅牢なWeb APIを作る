# どんなセキュリティの問題があるのか

<br>


## サーバーとクライアント間での情報の不正入手

- パケットスニッフィング
    - 公共のWifiで、他人の通信を盗み見する行為
        - セッションIDなどの情報が丸見えになっていることもある
            
            → セッションハイジャック

<br>       

### HTTPSによるHTTP通信の暗号化

- SSL, TLSによる暗号化
- サーバーとクライアント間の通信は暗号化され、途中で経由する中継サーバーやネットワークでその中身を見ることができなくなる
    - URIのパス、クエリ文字列、ヘッダとボディ、セッション情報を暗号化する
- HTTPSを使えば100%安全か？
    - 100%ではない
        - 過去にOpenSSL(暗号化ライブラリ)に不具合があり、暗号化されている情報を盗み出せる可能性があった
- 証明書の検証
    - サーバーから送られてきた証明書をクライアント側で正しいかチェックしないと、中間者攻撃(**MITM**)にて盗聴される可能性がある
        - 中間者攻撃(**MITM**)
            
            クライアントとサーバーの通信経路の間に入り込んで中継を行うことで情報を盗み出す手法
            
    - 証名書の発行元が信頼できるか、証明書の有効期限、サーバー証明書のコモンネームが接続しようとしているサーバーと一致しているか
        - HTTPSクライアントライブラリの多くでは、上記の検証を行なってくれることが多いがAndroidで標準利用されているクライアントライブラリは、コモンネームの検証を行なっていなかった

<br>
<br>

## ブラウザでアクセスするAPIにおける問題

### XSS

ユーザーから送られてきたJavaScriptを実行できてしまう脆弱性

- Ex. ユーザーからの入力(ユーザー名など)に埋め込まれたJavaScriptがチェックをすり抜けてJSONとして格納。このデータをレスポンスし、ページ内に直接埋め込んでブラウザで表示した際にJavaScriptが実行され、クッキーに含まれたセッション情報が第三者の手に渡ってしまう
- Ex2. JSON形式であるが、データを返す際のContent-Typeがtext/htmlだった場合、HTMLとして解釈されてJavaScriptが実行される

### XSSを防ぐためには

- ユーザーからの入力はきちんとチェックし、JSONデータを返す際もチェックを行い、おかしな値は取り除く必要がある
- Content-Typeをきちんとapplication/jsonに指定する
- jQuery、Ruby on Railsでも対応している`X-Requested-With`ヘッダを使用することで対応することも可能
    
    ```
    X-Requested-With: XMLHttpRequest
    ```
    
- `/` や`< >`をエスケープすることでscript要素を完全に無効化できる
    
    JSONで許可されていない文字
    
    - ダブルクォーテーションとバックスラッシュ、コントロール文字以外の全ての文字はユニコード文字は格納可能


<br>

### XSRF(クロスサイトリクエストフォージェリ)

- あるサイトにアクセスした際にリンクなどを経由して、全く別のサイトへリクエストが行われる
    - ユーザーが悪意あるページにアクセスした際に、その中に埋め込まれたリンクやIFrame, IMG要素, フォームなどを経由して、全く別のサイトへのリクエストが行われ、ユーザーの意図しない処理が行われることを指す
    - 掲示板に勝手に投稿が行われたり、ECサイトの特定の商品の評価を不当に下げたり、上げたりする


### XSRFを防ぐには

- データが変化するAPIは、POST, PUT, DELETEメソッドを使用する
    
    → IMG要素を使用して攻撃することができなくなる
    
- XSRFトークンを使用する
    - サイトが発行したワンタイムトークンを埋め込んでおき、トークンがないアクセスは拒否するもの

<br>

### JSONハイジャック

- APIからJSONで送られてくる情報を悪意ある第三者が盗み取ろうとするもの
    - script要素に、同一生成元ポリシーが適用されないことを利用して、外部ののAPIから情報を取得しさまざまな手法を用いてデータの読み込みを可能にしようとするもの
    - Ex1. Arrayオブジェクトのコンストラクタを変更する
        
        ```jsx
        <script type="application/javascript">
        var data;
        Array = function() {
        	data = this;
        };
        </script>
        ```
        
        - Arrayのコンストラクタを再定義する際、data変数に取得した内容が含まれてしまう
        - 最近のブラウザでは対応しており、データが読み取れないようになっている
    - Ex2. Objectのセッターを用いる
        
        ```jsx
        <script type="application/javascript">
        	Object.prototype.__defineSetter__('id', function(obj) {alert(obj)})
        ```

### JSONハイジャックを防ぐには

- JSONをscript要素では読み込めないようにする
    - 特別なヘッダが付いてない時にはアクセスを認めないなど
    - XSS, XSRFと同様`X-Requested-With`など
- JSONをブラウザが必ずJSONと認識するようにする
    - Content-Typeを指定する
- JSONをJavaScriptとして解析不可能にする
    - JSONのトップレベルを配列型ではなく、オブジェクト型にして返す

<br>
<br>

## 悪意あるアクセスへの対策を考える

### パラメーターの改ざん

- 情報を解析して不正を働くユーザーがいる
- 本来アクセスができないはずの情報はサーバー側でチェックし、アクセスを禁止するようにしておく

<br>

### リクエストの再送信

- 一度送ったリクエストを再度送信することで、同じ処理をサーバー側にもう一度させてしまうこと
    - Ex. ゲームのAPIにて敵に勝利したというデータを2度送り、2度同じ報酬をもらうなど
- 繰り返しアクセスが発生する可能性がある場合は、状態を管理する(ゲームの例であれば、開始時間、終了時間を管理して正しくゲームが行われていたのかをチェックする)

<br>

## セキュリティ関連のヘッダ

### X-Frame-Options

指定したページがフレーム内で読み込みを可能とするか制御できるヘッダ

- denyを指定するとフレーム内で読み込まれることを阻止できる
    
    ```
    X-Frame-Options: deny
    ```
    
- クリックジャッキング対策
    - IFRAMEを透明にして他のページで読み込み、そのページでユーザーがクリックをおこなったにも関わらず、実際には透明にした別ページでクリックが行われ、意図しない投稿を掲示板に行ったりなど仕向けるもの

<br>

### Strict-Transport-Security

- あるサイトへのリクエストをHTTPSのみ限定させる
    - HTTPでアクセスしてきたものをHTTPSにリダイレクトさせる手法はよく取られるが、この場合最初のリクエストは暗号化されない
        
        → 使用することでブラウザにあらかじめこのサイトはHTTPSでのアクセスが必須であるということを知らせる
        
- HTTPアクセスが送られてきた場合は無視される
- Ex.
    
    ```
    Strict-Transport-Security: max-age=15768000
    ```
    
    - HTTPSでのアクセスの際に上記ヘッダが返されると、ブラウザはmax-ageの期間中、この情報を記録しておき、その後HTTPを指定されても、必ずHTTPSを使うようにする

<br>

## Set-Cookieヘッダとセキュリティ

- クッキーをセッション管理に使用する場合にセキュリティの観点から、`Secure`, `HttpOnly`属性を使用することが一般的
    
    ```
    Set-Cookie: session=e827...; Path=/; Secure; HttpOnly
    ```
    
    - Secure
        - クライアントからサーバーから送信する際、クッキーにセットしたセッションの情報をHTTPSでの通信の際のみサーバーに送り返されるようになる
    - HttpOnly
        - HTTPの通信のみで使われ、ブラウザでJavaScriptを使用してアクセスできないものであることを示す
        - XSS対策になる

<br>

# 大量アクセスへの対策

WebAPIに限らずネットワーク上に存在するサービスは常に、外部からの大量のアクセスを受けるリスクにさらされている

<br>


## ユーザーごとのアクセスを制限する

- 単位時間あたりの最大アクセス回数を決め、それ以上のアクセスがあった場合にエラーを返すようにする
- レートリミットを設ける際には以下の点を考慮する必要がある
    - 何を使ってユーザーを識別するか
    - リミット値をいくつにするか
    - どういう単位でリミット値を設定するか
    - リミットのリセットをどういうタイミングで行うか
- Ex. Twitter
    - ツイートの検索: 15分に180回まで
    - ダイレクトメッセージの取得: 15分に15回まで
- リミットの単位
    - 1日にすると長すぎる
        - 一度アクセス頻度を間違えてしまうと、長ければ24時間使用できなくなってしまうため
    - 長くても1時間

<br>

## 制限値を超えた場合のレスポンス

- ステータスコード429 (Too Many Requests)を使用する
    - RFCでは、429の使用について以下のように書かれている
        - エラーの詳細をレスポンスに含めるべきである(SHOUD)
        - Retry-Afterヘッダを使って次のリクエストをするまでにどれくらい待てば良いかを指定しても良い(MAY)

<br>

## レスポンスでレートリミットを渡す

毎回のAPIアクセスの際にAPIの残りのアクセス可能回数などをレスポンスに含めてクライアントに返す方法

ヘッダとボディに含める2通りがあるが、ヘッダに格納するのが一般的

```
X-RateLimit-Limit: 単位時間あたりのアクセス上限
X-RateLimit-Remaining: アクセスできる残り回数
X-RateLimit-Reset: アクセス数がリセットされるタイミング
```

- X-RateLimit-Reset
    - 値として、リセットされるタイミングの秒数と、リセットされる時間を表すUnixタイムスタンプを使う方法の2種類がある

<br>

## レートリミットの実装

- RedisなどのKVSを使って記録をするのが一般的