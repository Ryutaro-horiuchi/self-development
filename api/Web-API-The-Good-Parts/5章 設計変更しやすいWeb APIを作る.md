# APIをバージョンで管理する

<br>

## バージョンの指定方法

### URIのバージョンをパスに埋め込む

```
Twitter
https://api.twitter.com/1.1/statuses/user_timeline.json

Tumblr
http://api.tumblr.com/v2/blog/good.tumblr.com/info
```

- URIのパスの一番先頭につけるのが、バージョン番号をURIに埋め込む方法としては一般的
- バージョンの付け方にも種類がある
    - バージョンの前に`”v”`がついているか
        
        <aside>
        💡 vをつけた方が、バージョンであるということがはっきりわかる。筆者推奨
        
        </aside>
        
    - メジャーバージョン(1→2)か、マイナーバージョンのアップデート(1→1.1)か

### クエリ文字列に入れる方法

```
Netflix
http://api-public.netflix.com/catalog/titles/series/70023522?v=1.5
```

- パストの決定的な違いは省略ができてしまう。
    - 省略した際に、最新のバージョンを適用するAPIもあれば、古いバージョンを適用するAPIもある
        - 省略をした際にどのバージョンを使用するのか自明ではないため、筆者としては非推奨。
        - 筆者としては、そもそもエイリアス自体用意(クエリ文字列がなければあるバージョンを返す)する必要なないとしている

### メディアタイプでバージョンを指定する

- Acceptと Content-Typeで指定する
    - クライアントからのリクエストの際にバージョン番号を含むメディアタイプをAcceptヘッダに入れてサーバーに送信する
        
        ```
        Accept: application/vnd.example.v2+json
        ```
        
    - サーバ側では、Content-TypeとVaryヘッダをつけて返す
        
        ```
        Content-Type: application/vnd.example.v2+json
        Vary: Accept
        ```
        
        - Varyはキャッシュをする際に考慮するヘッダの指定
    
    <aside>
    💡 Content-Typeが完全にapplication/jsonと一致しないとJSONと判断しないクライアントライブラリがあり、エラーと認識してしまう危険性がある
    
    </aside>
    
- 独自のHTTPヘッダを用意する
    - Googleでは、GData-Versionというヘッダを利用している
        
        ```
        GData-Version: 3.0
        ```
        
<br>

## バージョン番号をどうつけるか

明確なルールはないが、整数でカウントするのが一般的(メジャーアップデート)

- バージョンを頻繁に上げるべきではないから
    - 複数のAPIのバージョンをメンテナンスするのはコストがかかる
- セマンティックバージョニング
    - 3つの数値をドットで繋いだものであり、順に、メジャー、マイナー、パッチと呼ばれる
        
        ```
        1.2.3
        ```
        
    - ルール
        - メジャーバージョンは後方互換性のない変更が行われた際に増える
        - マイナーバージョンは工法互換性のある昨日変更、あるいは特定の機能が今後廃止されることが決まった場合に増える
        - パッチバージョン
            - APIに変更がないバグ修正などを行った時に増える
    
    <aside>
    💡 バージョン番号を1つの数字で表すことは、メジャー番号だけをURIに含めていることになる
    
    </aside>
    

<br>

## どの方法を採用すべきか

- パスの中に含める形式が無難
- バージョンはセマンティックバージョニングのメジャーバージョニングを使用する

<br>
<br>

# バージョンを変える指針

- 工法互換性を保ったまま修正を行うことが難しい変更時にバージョンを上げるべき
    - 後方互換性を保つことが可能な場合は可能な限り同じバージョンでのマイナーバージョンアップで対応する
        
        → レスポンスで返すデータの名前やデータ形式を変更する、といった軽微な変更ではバージョンを上げるべきではない
        
    - 工法互換性を保たなくても良い変更
        
        → セキュリティや権限などのルールを変更した場合は、後方互換性を保たなくても良い
        
<br>
<br>

# APIの終了

広く一般に公開されたAPIの場合は、事前に終了日時をアナウンスして、対応してくれるよう周知徹底する必要がある

- Ex. Twitter 「継続的な告知とBlackout Test」
    - 新しいAPIバージョン(1.1)のリリース発表時、以前のAPIのバージョン(1.0)は、その発表時から半年以内に廃止となることが告げられる
    - 廃止発表から半年後、Blackout Testを実施する
        - 一時的に1.0のAPIを停止してアクセスできないようにするテスト
- あらかじめ提供終了時の仕様を盛り込んでおく
    - 例えば公開終了した際に、ステータスコード410を返し、APIのアップデートを促すメッセージをつけるなど
- 利用規約にサポート期限を明記する
    - 古いバージョンをどれくらいの間サポートするのかという、最低限の期間を定めておく
    - サポート期限を明記すると、逆にその期間は廃止することができなくなるという縛りにもなるため、安易には行わない

<br>
<br>

# オーケストレーション層

### 前提

- 一般公開されるAPIでは、多くのニーズに応えるために汎用的な設計にすることが求められる
    - 一方で、汎用的な設計はどうしても全てのニーズを満たすことはできないため、ニーズによっては使い方が煩雑になってしまうことがある
        
        Ex.
        
        - 一つのアクションを取るのに、複数のエンドポイントを叩く必要がある
        - 不要なデータも受け取ってしまいペイロードば大きくなりがち
- 利用者が限定されているAPIでも、利用者の使い方が多様化すればその都度APIを用意することは難しくなってくる

### 本題

- Netflix社が構築した仕組みらしい
- サーバー側の汎用的なAPIとクライアントの間に、オーケストレーション層を挟み、クライアントのニーズを満たす実装を入れる
    - クライアントの開発者が元の汎用APIの形式にとらわれずに、複数のAPIを一つにまとめたり、返すデータの量を調節したりできる