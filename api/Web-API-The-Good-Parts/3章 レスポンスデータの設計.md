## データフォーマット

- 世の中のデファクトスタンダードはJSONであるため、原則JSONとし、必要があればXMLを検討する

<br>

### JSONがXMLより優れている点

- データサイズが小さい
- JavaScriptとの相性が良い
- シンプル

### XMLがJSONより優れている点

- スキーマ定義の仕様がきちんと決まっている
- 要素に対して属性が付けられる
    
    <aside>
    💡 → 現在のWebAPIでやり取りされているデータは、キーバリュー形式や配列を使って表現するものがほとんどであり、XMLを使わなければならない状況はほとんどない
    
    </aside>
    

### データフォーマットの指定方法

- 一般的には以下のような方法が使われている
    - クエリパラメーターを使う方法
        
        ```
        https://api.example.com/v1/users?format=xml
        ```
        
    - 拡張子を使う方法
        
        ```
        https://api.example.com/v1/users.json
        ```
        
    - Acceptリクエストヘッダでメディアタイプを指定する方法
        
        ```
        GET /v1/users
        Host: api.example.com
        Accept: application/json
        ```
        
- 実際のAPIでよく使われているのはクエリパラメーター


<br>


## JSOAP

- JSON with paddingの略
- JSONにラップするJavaScriptを付け加えたもの
    
    ```jsx
    // サーバー側
    callback({”id”: 123, “name”: “Saeed”})
    
    // URI
    <script src="https://api.example.com/v1/users?callback=callback">
    ```
    
- 上記だとデータを読み込めれた際にcallback関数が呼び出される

### JSOAPがある背景

- XMLHTTPRequestでは、同一のドメインにしかアクセスできない(同一制限ポリシー規制)
- スクリプトタグに含まれると、上記の規制の対象外であるため異なるドメインからデータを取得することが可能になる
    - → 動的に要素を生成して使用されることが一般的(?)

### JSOAPを指定するURI

- クエリパラメーターにコールバック関数の指定があればJSOAPとしてみなすのが一般的
- Content-Typeヘッダにセットするメディアタイプはapplication/jsonではなく、application/javascriptになる

### エラー処理

- サーバーがエラーを返した際に正しく識別されない問題点がある
- script要素はサーバー400番台で返してもクライアント側では何が起こったのかわからない
    - JSOAPを使用する場合は常に200番台で返し、レスポンスボディでエラーの内容を表現することでこれに対応する
        
        ```jsx
        {
        	status_code: 404,
        	error_message: "User Not Found"
        	
        }
        ```
        

<br>

## データの内部構造の考え方

- APIで返すレスポンスデータを返す際にまず考えるべきことは、APIのアクセス回数がなるべく減るようにすること
    - → ユースケースをきちんと考える必要が出てくる
- データーベースのインターフェースではなく、アプリケーションインターフェースであり、利用者が使いやすい構造を検討する
    - Ex. 内部的にはそのデータを返すのに関連テーブルから取り出す必要がある
        - 関連テーブルだからといって、度外視するのはDBのインターフェース
        - 関連テーブルではあるが、ユーザーにとって必要な情報であると考え、レスポンスに組み込むのはアプリケーションインターフェース
- Chatty(おしゃべり)なAPIにはならないようにする
    - Chatty なAPIとは一つの作業を完結するのに複数回のアクセスを必要とするようなAPIの設計のこと
    - ユースケースを考え、できる限り少ないアクセスで済むAPIを心がけるべき


### レスポンスの内容をユーザーが選べるようにする

- 背景
    
    広く提供するAPIの場合、提供側の都合で仕様を決めすぎると、帯に短したすきに長しの状態となってしまい、誰にとっても使いづらいAPIになってしまう
    
- 本題
    
    取得する項目を利用者が選択可能にすることで、使いやすいAPIになる
    
- 方法
    - クエリパラメーターで取得する項目を指定する
    - 各項目を直接指定する代わりに、取得する項目をあらかじめ指定した異なるセットをいくつか用意して、その名前を指定させる
        - Ex. Amazon

### エンベロープは必要ない

- エンベロープとは全てのデータを同じ構造で包むことを指す
- 必要のない理由として、エンベロープはメタ情報を含めたいときに使用されることがあるが、HTTPヘッダがその役割を満たしているため。(JSOAPは除く)
    - Ex.
        
        ```json
        {
        	"header": {
        		"status": "success",
        		"errorCode": 0,
        	},
        	"response": {
        		...実際のデータ...
        	} 
        }
        ```
        

### データはフラットにすべきか

- 階層化は単なる複数の項目をまとめる時に使用するのはNG
- OKなのは、階層化によって反復した表現や複数存在する共通した概念を一つにまとめられるとき
    - Ex.
        
        ```json
        階層化
        {
        	"id": 3342124,
        	"message": "hoge",
        	"sender": {
        		"id": 3456,
        		"name": "Taro Yamada"
        	},
        	"receiver": {
        		"id": 12912,
        		"name": "Kenji Suzuki"
        	},
        }
        ```
        
        ```json
        フラット
        {
        	"id": 3342124,
        	"message": "hoge",
        	"sender_id": 3456,
        	"sender_name": "Taro Yamada"
        	"receiver_id": 12912,
        	"receiver_name": "Kenji Suzuki"
        }
        ```
        
        <aside>
        💡 階層化することで、sender, receiverというどちらも同じユーザーであることが見て取れる。また、反復した接頭辞を使わないことで、データのサイズ自体を小さくすることができる
        
        </aside>
        

### 配列とフォーマット

- APIで返す際に、配列で返す方法と、レスポンス全体をオブジェクトにして返す方法の2通りがある
- どちらを選んでもさほど問題はないが著者はオブジェクトで包んだ方がわかりやすいとのこと
    - レスポンスデータが何を表しているのかわかりやすい
    - セキュリティ上のリスクを避けることができる
        - 配列だとJSONインジェクションの攻撃を受ける可能性がある
            
            JSONインジェクション
            
            - script要素を使用してJSONを読み込むことで、ブラウザに他のサービスのAPIが提供するJSONを読み込ませて、不正に入手するというもの
            - Content-Typeが`application/javascript`である必要があり、オブジェクトではJavaScriptと見做されないため問題ない

### 配列の件数、続きがあることをどのようにして返すべきか

- コンテキスト
    - ページネーション
- 本題
    - 「次があるのか」の情報を返す
        - 20件のデータ取得であれば、21件のデータを取得してみて続きの値があるかの確認をする
        - 確認できれば「hasNext」などの名前でboolean値で返してあげればいい
    - 次のURIや、次のページの取得に必要なパラメーターを返すパターンもある
        - Ex.
            
            ```json
            {
            	...
            	"nextPageToken": "CkaEL"
            }
            ```
            

<br>

## データ

### データの名前

ポイント

- 多くのAPIで同じ意味で利用されている一般的な単語を知る
- なるべく少ない単語で表現する
    - Ex.   dateTime →  _at
- 複数の単語を連結する時はAPI全体を通して統一する
    - キャメルケースを推奨だが、統一性が保たれているのであればどれでもよし
- 変な省略形は使用しない
- 単数系/複数形にきをつける

### 性別のデータ

- LSUDsであれば、フィールド名はgenderで値は文字列(male, female)で管理する
    
    → 社会的・文化的にあわせて、性別を増やす対応をする可能性があるため。文字列で表現するのは、LSUDs向けなのであれば数値よりもわかりやすい
    

### 日付のフォーマット

- RFC3339(Ex. `2015-10-12T11:30:22+09:00`)が推奨
    - 日本での月日の扱い方と同じでわかりやすい
        - 月を英語の`Nov`など文字で表しているのではなく、数値で表している
        - 年 / 月 / 日 の日本のフォーマットと同一
    - HTTPヘッダの日付フォーマットとしては使用できない
- タイムゾーン
    
    HTTPヘッダで用いられているHTTP時間においてはUTCが採用されていることから、タイムゾーン”+00:00”を使うのが分かりやすくておすすめ
    

### 大きい数字データ

JavaScriptでは大きい整数を使用すると誤差が出てしまうため、APIで大きい数値を返す時は文字列に変換して返すと良い(Ex. X (旧Twitter))


<br>

## エラーの表現

- まずは適切なエラーコードを返す
    - 返したいメッセージに合うステータスコードがなかったときは、’200’, ‘400’, ‘500’などの’00番台’を使用する
- エラーの詳細をクライアントに返す
    - 独自のHTTPヘッダーを用意して返す方法とボディで返す方法がある
    - ボディで返すAPIが多い
        - → クライアント側で使用しやすい
- エラーの際にHTMLが返ることを防ぐ
    - 500番台や404など、アプリケーションフレームワーク側の設定でHTMLを返すことがデフォルトになっていることが多い
    - JSONやXML形式のデータが返ってくることを想定しているクライアントにとっては、体験が悪い

### メンテナンスとステータスコード

- やむをえずメンテナンスをし、サービスを停止させるときは503を返す
- 終了時刻もわかっているなら、次にアクセスが可能な時間帯も返す
    - HTTPヘッダー Retry-Afterを使用する