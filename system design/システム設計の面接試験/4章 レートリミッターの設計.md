## APIへのリクエストをスロットルで制限するレートAPIレートリミッターのメリット

- サービス拒否(DoS)攻撃によるリソースの枯渇を防ぐ。
    - Ex. Twitter 3時間あたりのツイート数を300に制限している
- コストを削減する
    - 過剰なリクエストを制限することで、サーバーの数を減らし、より多くのリソースを優先度の高いAPIに割り当てることができる
- サーバーの過負荷を防ぐ

## レートリミッターはどこに置くのか

- クライアント側、サーバー側どちらでも実装することができる
- クライアント側は、一般的に悪意のあるユーザーにより、簡単に偽造される可能性があるため、レート制限を実施するには、信頼性の低い場所である
- どこに置くのかはレート制限を置く上で重要だが、絶対的な答えはない。
- ガイドライン
    - 現在使用しているプログラミング言語で、レート制限を実装可能なのか
    - ビジネスニーズに合ったレート制限アルゴリズムを特定する
    - すでにマイクロサービス、アーキテクチャを採用し、認証などでAPIゲートウェイを設計に組み込んでいる場合、レート制限をゲートウェイに追加できる
    - 独自に構築するのは時間がかかるため、商用APIゲートウェイを利用するのが良い

### サーバー側での実装

![IMG_6643.jpeg](attachment:2c6e2d58-91cb-4738-897b-445adf7214f3:IMG_6643.jpeg)

### リミッターミドルウェア

- APIへのリクエストをスロットルで制限する
    
    ![IMG_6644.jpeg](attachment:84781792-11b7-46df-b24e-e7a140073aac:IMG_6644.jpeg)
    
    - HTTPレスポンス429は過剰なリクエストを送信したことを示す
- レート制限は通常、APIゲートウェイと呼ばれるコンポーネント内で実装されている

## レートリミッターアルゴリズム

- トークンバケットアルゴリズム
    - シンプルでわかりやすく、よく採用されている
        - AmazonやStripeにて
    - 動作
        - トークンバケット
            - あらかじめ決められた容量を持つコンテナ
            - 定期的にトークンが入れられ、バケットが満杯になると、それ以上トークンは追加されない
    - イメージ図
        
        ![IMG_6660.jpeg](attachment:6fc6bed0-ee74-482e-88a3-400f8565206d:IMG_6660.jpeg)
        
        - 各リクエストは1つのトークンを消費する。リクエストが届くと十分なトークンがあるかを確認する
            - ある場合は各リクエストに対して、1つのトークンを取り出し、リクエストを通過する
            - 十分なトークンがない場合は、リクエストは破棄される
    - パラメーター
        - バケットサイズ: バケットに入れられるトークンの最大数
        - 補充率: 1秒間に入れられるバケットのトークン数
    - バケットの数
        - 通常、APIエンドポイントごとに異なるバケットを用意する必要がある
        - IPアドレスに基づいてリクエストを制限する場合は、IPアドレスごとに用意する必要がある
        - システムが1秒間に最大10,000のリクエストを許可するなら、全てのリクエストで共有されるグローバルバケットを持つことは理にかなっている
    - 長所・短所
        - 長所
            - アルゴリズムの実装が簡単
            - メモリ効率が良い
            - 短時間のバーストトラフィックを可能にする
        - 短所
            - パラメーターを適切に設定するのは難易度が高い
- リーキーバケットアルゴリズム
    - キューで実装される
    - 動作
        - リクエストが到着すると、システムはキューが満杯かどうかをチェックする
            - 満杯でなければキューに追加される
            - 満杯であれば、リクエストは破棄される
        - リクエストは、キューから一定時間ごとに処理される
    - イメージ図
        
        ![IMG_6662.jpeg](attachment:a8ddfa8f-02c7-4632-81a3-0de2acbbe758:IMG_6662.jpeg)
        
    - パラメーター
        - バケットサイズ
            - キューサイズ
        - 流出率
            - 一定の割合で処理できるリクエスト数を定義するもので、通常は秒単位で指定
    - 長所・短所
        - 長所
            - キューサイズに制限があるため、メモリ効率が良い
            - リクエストは固定レートで処理されるため、安定した流出レートが必要なユースケースに適している
        - 短所
            - トラフィックのバーストは古いリクエストでキューを満たされる
            - パラメーターを適切に設定するのが難しい
- 固定ウインドウカウンタアルゴリズム
    - 動作
        - タイムラインを固定サイズのウインドウに分割し、各ウインドウにカウンタを割り当てる
        - 各リクエストは、カウンターを一つずつ増加させる
        - カウンタが事前に定義された閾値に達すると、新しいリクエストは、新しいタイムウインドウが始まるまで落とされる
    - イメージ図
        
        ![IMG_6663.jpeg](attachment:bdb546d8-1883-4d2e-aaf7-79db80509900:IMG_6663.jpeg)
        
    - 問題点
        - タイムウインドウの端でバーストが発生すると、許容されるクォーターよりも多くのリクエストが通過されてしまう
    - 長所・短所
        - 長所
            - メモリ効率が良い
            - 理解しやすい
        - 短所
            - ウインドウの端におけるトラフィックの急増は、通過する許容割り当てよりも多くのリクエストを引き起こす可能性がある
- スライディングウィンドウログアルゴリズム
    - 動作
        - リクエストのタイムスタンプを追跡する
        - 新しいリクエストが来たら、古いタイムスタンプ(現在のタイムウインドウの開始時点よりも古いものを指す)を削除する
        - 新しいリクエストのタイムスタンプをログに追加する
        - ログのサイズが許容カウントと同じかそれ以下の場合、リクエストは受け入れられる
    - イメージ図
        
        ![IMG_6665.jpeg](attachment:1fde4041-78cf-414a-a348-bc145b8210ab:IMG_6665.jpeg)
        
        - ④では、1:01:40にリクエストが到着し、1:00:40 ~ 1:01:40の範囲にあるリクエストが最新のタイムウインドウである
        - 1:00:40に送られたリクエストは削除されると、ログのサイズは2であるため、リクエストは受け入れられる
    - 長所・短所
        - 長所
            - このアルゴリズムによって実装されたレート制限は、非常に正確
        - 短所
            - リクエストが拒否されたとしても、そのタイムスタンプは記録されるため、リクエストが多いユーザーや攻撃があると、メモリが膨れやすい

## 高度なアーキテクチャ

- 高度なレベルでは、同じユーザーやIPアドレスから送られたいくつかのリクエストを追跡するためのカウンターが必要。
- カウンターの保存はRedisのようなインメモリ・ストアが最適
    - DBはディスクアクセスの遅さから良いアイデアとは言えない
    - Redisはレートリミッターを実装する上で一般的な選択肢。下記の二つのコマンドを実行する
        - INCR
            - 格納されたカウンターを1だけ増加させる
        - EXPIRE
            - カウンターにタイムアウトを設定し、タイムアウトが終了するとカウンターは自動的に削除される
- イメージ図
    
    ![IMG_6666.jpeg](attachment:8e6f03b9-ee77-4be2-8e62-3112fd3f3a33:IMG_6666.jpeg)
    

### レート制限ルール

- ルールは通常、設定ファイルとして記述され、ディスクに保存される
- Ex. Lyft
    
    ```yaml
    domain: auth
    descriptors:
     - key: auth_type
    	 value: login
    	 rate_limit:
    		 unit: minute
    		 requests_per_unit: 5
    ```
    
    クライアントは1分間に5回以上のログインが許可されていない
    

### レート制限の超過

- レート制限されている場合、APIはHTTPレスポンスコード429を返す
- レートリミッターのヘッダー
    - X-Ratelimit-Remaining
        - ウインドウ内で許可される残りのリクエスト数
    - X-Ratelimit-Limit
        - クライアントが1つのタイムウインドウで行える呼び出しの回数
    - X-Ratelimit-Retry-After
        - 制限されずにリクエストを再び行えるようになるまでの待ち時間

### 詳細設計

![IMG_6685.jpeg](attachment:143b811f-f361-436d-8fd5-3413d36065d0:IMG_6685.jpeg)

## 分散環境におけるレートリミッター

### レースコンディション

- 高度な並行処理環境では、レースコンディション発生の可能性がある
    
    ![IMG_6686.jpeg](attachment:c1b10e53-8639-4113-8e96-1f71d77a2856:IMG_6686.jpeg)
    
- ロックすることは、最もわかりやすい解決策ではあるが、速度を著しく低下させるデメリットがある
- 一般的にはLuaスクリプトとRedisのソート済みセットデータ構造
    - Luaスクリプト
        - 概要
            - RedisはLuaスクリプトをサポートしており、`EVAL`コマンドでスクリプトをRedisサーバー内で実行できます。
            - **スクリプトはRedis内で原子的（atomic）に実行される**ため、スクリプト内の全てのコマンドが他クライアントから割り込まれずに処理されます。
        - 利点
            - ネットワーク往復を減らせる（複数コマンドをまとめて実行）。
            - トランザクションのように、一連の操作を中断されずに実行可能。
            - ロック機構を使わずにレースコンディションを防止できる。
        - 例：在庫数を減らす
            - Luaスクリプト
                
                ```lua
                -- Luaスクリプト (在庫数が1以上ならデクリメント)
                local stock = redis.call("GET", KEYS[1])
                if tonumber(stock) > 0 then
                    redis.call("DECR", KEYS[1])
                    return 1
                else
                    return 0
                end
                
                ```
                
        - 実行例:
            
            ```bash
            EVAL "<上記スクリプト>" 1 product_stock
            ```
            
            これにより、複数のクライアントが同時に在庫を減らそうとしても、在庫数が負数になることはありません。
            
    - Redisのソート済みセット（Sorted Set）
        - 概要
            - ソート済みセットは、**スコア付きで要素を管理するデータ構造**です。
            - メンバーは一意で、スコアに基づいて自動的にソートされます。
        - 主なコマンド
            - `ZADD key score member` … 要素を追加
            - `ZRANGE key start stop` … スコア順に要素を取得
            - `ZREM key member` … 要素を削除
            - `ZSCORE key member` … 特定メンバーのスコア取得
        - レースコンディション防止での利用例
            
            特に「順番を保証したい」「同時アクセスを制御したい」というケースで利用されます。
            
        - 例：ジョブキューの順序制御
            - 複数のワーカーが同時にジョブを取り出す場合、通常のリストでは「同時取得による重複処理」が発生する可能性があります。
            - ソート済みセットを使うと、スコア（タイムスタンプ）を付与してキューを管理できます。
            
            ```bash
            bash
            コピーする編集する
            # 追加
            ZADD job_queue 1691059200 "job_1"
            ZADD job_queue 1691059201 "job_2"
            
            # 先頭のジョブを原子的に取得＆削除（Luaスクリプトでまとめる）
            
            ```
            
            Luaスクリプトで「スコアが最も小さいジョブを取り出して削除する」処理を原子的に行うことで、レースコンディションを防止できます。
            

### 同期の問題

- 数百万のユーザーをサポートするために複数のレートリミッター・サーバーを使用する場合には同期の問題が出てくる
- 良いアプローチとして、Redisのような集中型データストアを使用することが推奨されている

### 性能の最適化

- 2つの改善点
    - データセンターから離れた場所にいるユーザーのレイテンシーが高いため、レートリミッターでは複数のデータセンターでの設定が重要
- 一貫性モデルでデータを同期させる
    - 6章 「一貫性」の項目より

### その他の論点

- 異なるレベルでのレート制限
    - 今回はHTTP(第7層)でのレート制限をしたが、Iptablesなどを用いてIP(第3層)でレート制限を行うことができる
    - クライアント側でのベストプラクティスによるアプローチで、レート制限を受けないようにする
        - 頻繁なAPIコールを避けるためにクライアントキャッシュを使用する