## APIへのリクエストをスロットルで制限するレートAPIレートリミッターのメリット

- サービス拒否(DoS)攻撃によるリソースの枯渇を防ぐ。
    - Ex. Twitter 3時間あたりのツイート数を300に制限している
- コストを削減する
    - 過剰なリクエストを制限することで、サーバーの数を減らし、より多くのリソースを優先度の高いAPIに割り当てることができる
- サーバーの過負荷を防ぐ

## レートリミッターはどこに置くのか

- クライアント側、サーバー側どちらでも実装することができる
- クライアント側は、一般的に悪意のあるユーザーにより、簡単に偽造される可能性があるため、レート制限を実施するには、信頼性の低い場所である
- どこに置くのかはレート制限を置く上で重要だが、絶対的な答えはない。
- ガイドライン
    - 現在使用しているプログラミング言語で、レート制限を実装可能なのか
    - ビジネスニーズに合ったレート制限アルゴリズムを特定する
    - すでにマイクロサービス、アーキテクチャを採用し、認証などでAPIゲートウェイを設計に組み込んでいる場合、レート制限をゲートウェイに追加できる
    - 独自に構築するのは時間がかかるため、商用APIゲートウェイを利用するのが良い

### サーバー側での実装

![IMG_6643.jpeg](attachment:2c6e2d58-91cb-4738-897b-445adf7214f3:IMG_6643.jpeg)

### リミッターミドルウェア

- APIへのリクエストをスロットルで制限する
    
    ![IMG_6644.jpeg](attachment:84781792-11b7-46df-b24e-e7a140073aac:IMG_6644.jpeg)
    
    - HTTPレスポンス429は過剰なリクエストを送信したことを示す
- レート制限は通常、APIゲートウェイと呼ばれるコンポーネント内で実装されている

## レートリミッターアルゴリズム

- トークンバケットアルゴリズム
    - シンプルでわかりやすく、よく採用されている
        - AmazonやStripeにて
    - 動作
        - トークンバケット
            - あらかじめ決められた容量を持つコンテナ
            - 定期的にトークンが入れられ、バケットが満杯になると、それ以上トークンは追加されない
    - イメージ図
        
        ![IMG_6660.jpeg](attachment:6fc6bed0-ee74-482e-88a3-400f8565206d:IMG_6660.jpeg)
        
        - 各リクエストは1つのトークンを消費する。リクエストが届くと十分なトークンがあるかを確認する
            - ある場合は各リクエストに対して、1つのトークンを取り出し、リクエストを通過する
            - 十分なトークンがない場合は、リクエストは破棄される
    - パラメーター
        - バケットサイズ: バケットに入れられるトークンの最大数
        - 補充率: 1秒間に入れられるバケットのトークン数
    - バケットの数
        - 通常、APIエンドポイントごとに異なるバケットを用意する必要がある
        - IPアドレスに基づいてリクエストを制限する場合は、IPアドレスごとに用意する必要がある
        - システムが1秒間に最大10,000のリクエストを許可するなら、全てのリクエストで共有されるグローバルバケットを持つことは理にかなっている
    - 長所・短所
        - 長所
            - アルゴリズムの実装が簡単
            - メモリ効率が良い
            - 短時間のバーストトラフィックを可能にする
        - 短所
            - パラメーターを適切に設定するのは難易度が高い
- リーキーバケットアルゴリズム
    - キューで実装される
    - 動作
        - リクエストが到着すると、システムはキューが満杯かどうかをチェックする
            - 満杯でなければキューに追加される
            - 満杯であれば、リクエストは破棄される
        - リクエストは、キューから一定時間ごとに処理される
    - イメージ図
        
        ![IMG_6662.jpeg](attachment:a8ddfa8f-02c7-4632-81a3-0de2acbbe758:IMG_6662.jpeg)
        
    - パラメーター
        - バケットサイズ
            - キューサイズ
        - 流出率
            - 一定の割合で処理できるリクエスト数を定義するもので、通常は秒単位で指定
    - 長所・短所
        - 長所
            - キューサイズに制限があるため、メモリ効率が良い
            - リクエストは固定レートで処理されるため、安定した流出レートが必要なユースケースに適している
        - 短所
            - トラフィックのバーストは古いリクエストでキューを満たされる
            - パラメーターを適切に設定するのが難しい
- 固定ウインドウカウンタアルゴリズム
    - 動作
        - タイムラインを固定サイズのウインドウに分割し、各ウインドウにカウンタを割り当てる
        - 各リクエストは、カウンターを一つずつ増加させる
        - カウンタが事前に定義された閾値に達すると、新しいリクエストは、新しいタイムウインドウが始まるまで落とされる
    - イメージ図
        
        ![IMG_6663.jpeg](attachment:bdb546d8-1883-4d2e-aaf7-79db80509900:IMG_6663.jpeg)
        
    - 問題点
        - タイムウインドウの端でバーストが発生すると、許容されるクォーターよりも多くのリクエストが通過されてしまう
    - 長所・短所
        - 長所
            - メモリ効率が良い
            - 理解しやすい
        - 短所
            - ウインドウの端におけるトラフィックの急増は、通過する許容割り当てよりも多くのリクエストを引き起こす可能性がある
- スライディングウィンドウログアルゴリズム
    - 動作
        - リクエストのタイムスタンプを追跡する
        - 新しいリクエストが来たら、古いタイムスタンプ(現在のタイムウインドウの開始時点よりも古いものを指す)を削除する
        - 新しいリクエストのタイムスタンプをログに追加する
        - ログのサイズが許容カウントと同じかそれ以下の場合、リクエストは受け入れられる
    - イメージ図
        
        ![IMG_6665.jpeg](attachment:1fde4041-78cf-414a-a348-bc145b8210ab:IMG_6665.jpeg)
        
        - ④では、1:01:40にリクエストが到着し、1:00:40 ~ 1:01:40の範囲にあるリクエストが最新のタイムウインドウである
        - 1:00:40に送られたリクエストは削除されると、ログのサイズは2であるため、リクエストは受け入れられる
    - 長所・短所
        - 長所
            - このアルゴリズムによって実装されたレート制限は、非常に正確
        - 短所
            - リクエストが拒否されたとしても、そのタイムスタンプは記録されるため、リクエストが多いユーザーや攻撃があると、メモリが膨れやすい

## 高度なアーキテクチャ

- 高度なレベルでは、同じユーザーやIPアドレスから送られたいくつかのリクエストを追跡するためのカウンターが必要。
- カウンターの保存はRedisのようなインメモリ・ストアが最適
    - DBはディスクアクセスの遅さから良いアイデアとは言えない
    - Redisはレートリミッターを実装する上で一般的な選択肢。下記の二つのコマンドを実行する
        - INCR
            - 格納されたカウンターを1だけ増加させる
        - EXPIRE
            - カウンターにタイムアウトを設定し、タイムアウトが終了するとカウンターは自動的に削除される
- イメージ図
    
    ![IMG_6666.jpeg](attachment:8e6f03b9-ee77-4be2-8e62-3112fd3f3a33:IMG_6666.jpeg)