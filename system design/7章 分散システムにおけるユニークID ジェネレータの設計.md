## はじめに

- 分散システムにおけるユニークIDジェネレーターの設計が求められる
    - auto_incrementは分散環境では機能しない

### 面接官から求められる要件

- IDは一意でなければならない
- IDは数値のみである
- IDは64ビット以内で収まる
- IDは日付順に並んでいる
- 1秒間に10,000以上のユニークIDを生成できる

## マルチマスターレプリケーション

- DBのauto_incrementを使用し、IDを1ずつではなく**使用中のDBサーバーの数である**`k`ずつ増える
    
    ![IMG_7058.jpeg](attachment:fbff6484-45a6-41dd-b7ea-6fdde850cb06:IMG_7058.jpeg)
    
- 短所
    - 複数のデータセンターで拡張することが困難
    - IDは複数のサーバー間で時間と共に増えない
    - サーバー追加されたり、削除した時に、うまくスケーリングしない

## UUID

- 128ビットの番号
- データ衝突の可能性が非常に低く、毎秒10億個のUUIDを約100年間生成した後、一回衝突する確率が50%
- 長所
    - UUIDの生成が簡単であり、サーバー間での連携が不要。→ 同期の問題が発生しない
    - 各WebサーバーがIDの生成に責任を持つため、スケーリングが容易
- 短所
    - 求めているのが64ビットであり、本要件には合わない
    - IDが時間と共に増加することはない
    - IDは数字でない可能性がある

## チケットサーバー

- このアプローチでは、単一のデータベースサーバーで集中的にauto_increment機能を使用する
    
    ![IMG_7059.jpeg](attachment:1af282d0-02fd-44ac-8097-21fe55c89703:IMG_7059.jpeg)
    
- 長所
    - 実装が簡単で、小規模から中規模のアプリケーションに有効
- 短所
    - 障害点が単一。
        - チケットサーバーがダウンした場合、依存するすべてのシステムが問題に直面する

## Twitterによるsnowflakeアプローチ

- IDを直接生成する代わりに、IDを異なるセクションに分割する
    
    ![IMG_7060.jpeg](attachment:995c8426-0874-4336-bd37-eddb550c74fd:IMG_7060.jpeg)
    
    - 符号ビット
        - 1ビット。常に0。符号付きと符号なしを区別するために使用される可能性がある
    - タイムスタンプ
        - 41ビット。エポック(基準となる時刻)からのミリ秒。時間と共に増加するため、ソートが可能
    - データセンターID
        - 5ビット。32のデータセンターがあることになる
    - マシンID
        - 5ビット。32のマシンが存在することになる
    - シーケンス番号
        - 12ビット。マシン / プロセスでIDが生成されるたびにシーケンス番号が1増加する
        - この番号は1m秒ごとに0にリセットされる。
            - → 理論上、1台のマシンは1m秒間に最大4096個の新しいIDをサポートできる
- タイムスタンプのイメージ
    
    ![IMG_7061.jpeg](attachment:ca10738b-9459-4098-9262-b0eeb6c321e8:IMG_7061.jpeg)