# 概念スキーマと論理設計

- 概念スキーマを定義する設計を**論理設計**と呼ぶ
    - 一般的な意味の論理ではなく、「物理層の制約にとらわれない」という意味
    - 「物理層の制約にとらわれない」とは、DBサーバーのCPUやストレージのデータの格納場所、DBMSのSQLの構文といった具体的な実装レベルの条件は一旦無視するということ
- DB設計の手順
    - 概念スキーマ(論理設計) → 内部スキーマ(物理設計) の手順で設計を行う

## 論理設計のステップ

---

### 1. エンティティの抽出

- システムためにどのようなエンティティが必要になるかを抽出する
- エンティティは日本語で「実体」DBの文脈では物理的な実体に加えて、概念的な存在も含まれる
- Ex.
    - 物理的なエンティティ「顧客」「社員」「店舗」
    - 概念的なエンティティ 「税」「会社」「注文履歴」

### 2. エンティティの定義

- エンティティがどのようなデータを保持するかを決める
    - キーという列も定義する
- エンティティはデータを属性という形で保持する。二次元表における「列」と同義

### 3. 正規化

- 更新が整合的に行えるように、エンティティのフォーマットを整理する

### 4. ER図の作成

- エンティティ同士の関係を表現する図を作成する

<aside>
💡 論理設計の段階では具体的なハードウェアやDBMSのミドルウェアをインストールする必要がない。→ 論理設計は机上で行えると考えて良い

</aside>

# 内部スキーマと物理設計

## 物理設計のステップ

---

### 1. テーブル定義

- 論理設計で定義された概念スキーマを元に、DBMS内部に格納するための「テーブル」の単位に変換していく作業
- 物理モデルと呼ばれる
    - 補足: 論理設計で作られるERモデルは論理モデル

### 2. インデックス定義

- パフォーマンスの調整

### 3. ハードウェアのサイジング

サイジングは二つの意味がある

1. キャパシティ 「データの規模」
    1. システムで利用するデータサイズを見積り、それに十分な容量の記憶装置(ストレージ)を選定する
    - 必要な入力情報
        1. システムで利用するデータ量
        2. サービス終了時のデータ増加率
            1. ほとんどのシステムでは、サービスの開始時よりもデータ量は増えるため、運用終了時にデータ量がどの程度になるか見越しておかないと、途中でストレージの容量が足らないという重大な問題が起こる
            2. ただ、終了時のデータ量を正確に見積もるのはむずかしいため、二つのアプローチをとる
                1. 安全率を大きく取って、余裕を持たせたサイジング
                2. 仮に後で容量が不足した場合に、簡単に記憶装置を追加できるような構成にしておく
2. パフォーマンス 「処理性能」
    1. システムが十分な性能を発揮できるだけのスペックのCPUやメモリを持ったサーバーを選定する
    2. ストレージも絡んでくる。
        1. ディスク回転数など性能を決めるスペックがあるため。
        2. 性能問題のほとんどは、ストレージのI/Oネックによって引き起こされる
            - I/O: 「Input/Output(入出力)」の略でデータの読み込み（入力）と書き込み（出力）の操作のこと
    3. データの整合性とパフォーマンスの間に強いトレードオフが存在する
        1. 整合性を高くしようとするとパフォーマンスが犠牲になり、パフォーマンスを追求すると整合成を犠牲にする
    - 必要な入力情報
        1. 性能要件
            - 通常、システム開発では性能要件を二つの指標を使って定義する
                1. 処理時間
                    1. 特定の処理について「何秒以内に終了すること」といった形で定義する
                2. スループット
                    1. 特定の時間内にどれだけの処理をこなせるか
                    2. 単位で「1秒あたりの仕事量」を示すTPSという指標を使うのが一般的
        2. リソース使用量の基礎数値
            - どの程度の処理を行うと、どの程度のハードウェアリソースを消費するのか。根拠となる基礎数値を得る必要がある
                1. 類似の稼働中システムのデータを流用する
                2. プロトタイプシステムを構築して、性能検証を実施する
                    
                    → 予算とスケジュールに余裕があるプロジェクトでないと難しいため、キャパシティのサイジングと同様、スケーラビリティに留意したサイジングを行う必要がある
                    

### 4. ストレージの冗長構成

RAID 独立したディスクの冗長配列

- 複数のディスクに同じデータを書き込んで冗長化する
    - → 冗長とは同じものを複数の場所にもつ
- システムの信頼性と性能を向上することができる

RAIDについて考えること

- 当該データには、信頼性が求められるのか。それとも性能が求められるのか
- どのようなレベルでRAIDを採用するか
- 何本のディスクでRAIDを構成するか

RAIDのレベル

- RAID0
    - 複数のディスクにデータを分散させる。
    - 冗長性はないが、I/O性能はディスク本数が増えるほど向上する
- RAID1
    - 2本のディスクに全く同じデータを持つ
    - 冗長性は向上するが、データは分散されないため性能は1本の時と変わらなあい
- RAID5
    - パリティ分散
    - データとともにパリティと呼ばれる誤り符号訂正符号を分散して格納する
- RAID10
    - RAID 1 とRAID0 を組み合わせたもの
    - それぞれのいいとこどりではあるが、コストがかかる

少なくともRAID5で構成する。お金によゆうがあればRAID10。RAID0は論外

### 5. ファイルの物理配置

データベースをどのディスクに配置するかを決める

データベースに格納されるファイルは、用途別に以下5種類

- データファイル
    - DBに格納するデータを保持するためのファイル
- インデックスファイル
    - テーブルに作成されたインデックスが格納されるファイル
- システムファイル
    - DBMSのb内部管理用に使用されるデータを格納する。
- 一時ファイル
    - SQLでサブクエリを展開したデータや、GROUP BY句などを利用した時のソートデータなど、一時的なデータを保持する
- ログファイル
    - 前提 データの更新
        - テーブルのデータ変更を受け付けた時に、このログファイルに変更分を溜め込んだ後に、一括してデータを更新する

p51

DBMSの特徴

配置する

サイジングを意識してディスク配置をする

p53

## バックアップ設計

p54

バックアップ方式について

- フルバックアップ
    - ある時点でシステムが保持しているすべてのデータをバックアップする方式
    - 欠点
        - バックアップの時間が長い
        - 負荷が高い
        - サービスの停止が必要
- 差分バックアップ
    - DBMSは、ユーザーから受け付けた変更を、すぐにデータファイルに反映するのではなく、トランザクションログに溜め込む
        - 差分バックアップはトランザクションログをバックアップする
    - Ex.
        - 月曜日にフルバックアップし、火曜~日曜までは月曜からのトランザクションログをバックアップする
        - → 日曜日に障害が起きた場合は、月曜日のバックアップ分と土曜日のバックアップだけで良い
    - リカバリの手順がフルの時よりも増える
- 増分バックアップ