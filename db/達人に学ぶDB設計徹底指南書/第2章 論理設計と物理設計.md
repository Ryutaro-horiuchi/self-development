# 概念スキーマと論理設計

- 概念スキーマを定義する設計を**論理設計**と呼ぶ
    - 一般的な意味の論理ではなく、「物理層の制約にとらわれない」という意味
    - 「物理層の制約にとらわれない」とは、DBサーバーのCPUやストレージのデータの格納場所、DBMSのSQLの構文といった具体的な実装レベルの条件は一旦無視するということ
- DB設計の手順
    - 概念スキーマ(論理設計) → 内部スキーマ(物理設計) の手順で設計を行う

## 論理設計のステップ

---

### 1. エンティティの抽出

- システムためにどのようなエンティティが必要になるかを抽出する
- エンティティは日本語で「実体」DBの文脈では物理的な実体に加えて、概念的な存在も含まれる
- Ex.
    - 物理的なエンティティ「顧客」「社員」「店舗」
    - 概念的なエンティティ 「税」「会社」「注文履歴」

### 2. エンティティの定義

- エンティティがどのようなデータを保持するかを決める
    - キーという列も定義する
- エンティティはデータを属性という形で保持する。二次元表における「列」と同義

### 3. 正規化

- 更新が整合的に行えるように、エンティティのフォーマットを整理する

### 4. ER図の作成

- エンティティ同士の関係を表現する図を作成する

<aside>
💡 論理設計の段階では具体的なハードウェアやDBMSのミドルウェアをインストールする必要がない。→ 論理設計は机上で行えると考えて良い

</aside>

# 内部スキーマと物理設計

## 物理設計のステップ

---

### 1. テーブル定義

- 論理設計で定義された概念スキーマを元に、DBMS内部に格納するための「テーブル」の単位に変換していく作業
- 物理モデルと呼ばれる
    - 補足: 論理設計で作られるERモデルは論理モデル

### 2. インデックス定義

- パフォーマンスの調整

### 3. ハードウェアのサイジング

サイジングは二つの意味がある

1. キャパシティ 「データの規模」
    1. システムで利用するデータサイズを見積り、それに十分な容量の記憶装置(ストレージ)を選定する
    - 必要な入力情報
        1. システムで利用するデータ量
        2. サービス終了時のデータ増加率
            1. ほとんどのシステムでは、サービスの開始時よりもデータ量は増えるため、運用終了時にデータ量がどの程度になるか見越しておかないと、途中でストレージの容量が足らないという重大な問題が起こる
            2. ただ、終了時のデータ量を正確に見積もるのはむずかしいため、二つのアプローチをとる
                1. 安全率を大きく取って、余裕を持たせたサイジング
                2. 仮に後で容量が不足した場合に、簡単に記憶装置を追加できるような構成にしておく
2. パフォーマンス 「処理性能」
    1. システムが十分な性能を発揮できるだけのスペックのCPUやメモリを持ったサーバーを選定する
    2. ストレージも絡んでくる。
        1. ディスク回転数など性能を決めるスペックがあるため。
        2. 性能問題のほとんどは、ストレージのI/Oネックによって引き起こされる
            - I/O: 「Input/Output(入出力)」の略でデータの読み込み（入力）と書き込み（出力）の操作のこと
    3. データの整合性とパフォーマンスの間に強いトレードオフが存在する
        1. 整合性を高くしようとするとパフォーマンスが犠牲になり、パフォーマンスを追求すると整合成を犠牲にする
    - 必要な入力情報
        1. 性能要件
            - 通常、システム開発では性能要件を二つの指標を使って定義する
                1. 処理時間
                    1. 特定の処理について「何秒以内に終了すること」といった形で定義する
                2. スループット
                    1. 特定の時間内にどれだけの処理をこなせるか
                    2. 単位で「1秒あたりの仕事量」を示すTPSという指標を使うのが一般的
        2. リソース使用量の基礎数値
            - どの程度の処理を行うと、どの程度のハードウェアリソースを消費するのか。根拠となる基礎数値を得る必要がある
                1. 類似の稼働中システムのデータを流用する
                2. プロトタイプシステムを構築して、性能検証を実施する
                    
                    → 予算とスケジュールに余裕があるプロジェクトでないと難しいため、キャパシティのサイジングと同様、スケーラビリティに留意したサイジングを行う必要がある
                    

### 4. ストレージの冗長構成

- ストレージは、DBのデータを保持する媒体で一般的にはHDDを使用する
- DBの物理設計において、RAIDについて以下のことを考える必要がある
    - 当該データには、信頼性が求められるのか。それとも性能が求められるのか
    - どのようなレベルでRAIDを採用するか
    - 何本のディスクでRAIDを構成するか
- RAID とは
    - 複数のディスクを束ねて仮想的に一つのストレージとする技術
        - この単位でまとめられたディスクをRAIDグループと呼ぶ
    - 何段階かレベルはあるが、基本的な考え方は複数のディスクに同じデータを書き込んで冗長化し、一つのディスクが壊れてしまっても、残りのディスクが生きていればデータを保全できるようにするという考え方
    - → 冗長とは同じものを複数の場所にもつという意味
    - データを分散して保持するため、ディスクI/Oを分散することで、パフォーマンス向上を図ることができる
    
    <aside>
    💡 システムの信頼性と性能を向上することができる
    
    </aside>
    
- RAIDのレベル
    - RAID0
        - 複数のディスクにデータを分散させる。
        - 冗長性はないが、I/O性能はディスク本数が増えるほど向上する
        
        ![IMG_1392.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/fc8f5e60-f7c3-4a09-ad13-97e6d42cfad8/4ce7cd23-a33d-4129-a2d0-563df49911d9.png)
        
    - RAID1
        - 2本のディスクに全く同じデータを持つ
        - 冗長性は向上するが、データは分散されないため性能は1本の時と変わらない
        
        ![IMG_1393.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/8aeb7c61-e06a-4127-bb56-a9aec4e20043/1798f13d-3a2a-4288-aa39-ca91687cdeff.png)
        
    - RAID5
        - パリティ分散とよばれる方式
        - 最低3本で構成し、データとともにパリティと呼ばれる誤り符号訂正符号を分散して格納する
            - → ディスクが壊れてもパリティから実データを復元することができる
        
        ![IMG_1394.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/77f326dd-a500-4d7b-ba2b-c1319897a797/f8e35329-f73c-49b9-89b2-9be9ebbcd935.png)
        
    - RAID10
        - RAID 1 とRAID0 を組み合わせたもの
            - RAID1のグループを二つ作り、そのグループを使ってRAID0を作る
        - それぞれのいいとこどりではあるが、コストがかかる
        
        ![IMG_1395.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/40674700-51b4-420b-bc2b-89854bd23bf5/31a0f30f-45b2-4ef3-82cf-24f6b148ac5e.png)
        
- どのRAIDパターンを採用するか？
    
    <aside>
    💡 少なくともRAID5で構成する。お金によゆうがあればRAID10。RAID0は論外
    
    </aside>
    

### 5. ファイルの物理配置

- データベースのファイルをどのディスクに配置するかを決める
    - 最近のDBMSでは自動化が進んでいるため、エンジニアが意識しなくても、ある程度はDBMSが自動的に配置してくれるが、基本的な考え方は押さえておいた方が良い
- データベースに格納されるファイルは、用途別に5種類ある
    
    <aside>
    💡 開発者が存在を意識するのは、データファイルとインデックスファイルのみ
    
    </aside>
    
    - データファイル
        - DBに格納するデータを保持するためのファイル
    - インデックスファイル
        - テーブルに作成されたインデックスが格納されるファイル
    - システムファイル
        - DBMSの内部管理用に使用されるデータを格納する。
    - 一時ファイル
        - SQLでサブクエリを展開したデータや、GROUP BY句などを利用した時のソートデータなど、一時的なデータを保持する
    - ログファイル
        - 前提 データの更新
            - DBは、テーブルのデータ変更を受け付けた時に、即座にデータファイルを更新するのではなく、当ログファイルに変更分を溜め込んだ後に一括してデータを更新する
        - MySQLでは、バイナリログと呼ばれる
            - DBMSによって呼び名が異なる
        
- どの様に配置するか
    - 前提
        - 最も重要なのは「サイズと性能」
        - I/Oが最も多いのは、データファイルであるため、基本的な考え方はデータファイルとそれ以外のファイルを別のディスクに配置する
        - データファイルの次にI/Oが多いのはインデックスファイル、一時ファイルであるため、この二つのファイルも独立したディスクに配置するのが望ましい
        - ログファイルは、データ更新が多いシステムではI/Oが大きくなるが、データファイルの読み込み量と比較するとそれほどではない
        - システムファイルは、DBMS内部の管理用にしか使われないため、I/Oは非常に低くなる
    - すべてのファイルを異なるディスクに配置するのが望ましいが、コストが高くなり厳しいため、妥協案として、I/Oコストの低いシステムファイルとログファイルを同じディスクに配置するなど

# バックアップ設計

データベースのデータを失う事故を引き起こさないために必要な設計として、極力データを失わないRAID設計と、データを失ったときに復旧できるようにしておくことが大事になってくる

## 3種類のバックアップ方式

### フルバックアップ

- ある時点でシステムが保持しているすべてのデータをバックアップする方式
- イメージ図
    
    ![IMG_1396.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/4f92758f-e9f6-45a1-b7b0-a04a71e415aa/IMG_1396.jpeg)
    
- 欠点
    - バックアップの時間が長い
    - ハードウェアリソースへの負荷が高い
    - サービスの停止が必要

### 差分バックアップ

- 差分バックアップは変更分のログ(トランザクションログ)をバックアップする
- Ex.
    - イメージ図
        
        ![IMG_1397.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/3ffbe58e-edb1-40bb-8b12-46255578da50/IMG_1397.jpeg)
        
    - 月曜日だけにフルバックアップし、火曜~日曜までは月曜からのトランザクションログをバックアップする
    - → 日曜日に障害が起きた場合は、月曜日のバックアップ分と土曜日のバックアップだけで良い
- 利点
    - バックアップのデータ量が減る
- 欠点
    - リカバリの手順がフルバックアップの時よりも増える

### 増分バックアップ

- その日の変更分のトランザクションログのみバックアップをする
- Ex.
    - イメージ図
        
        ![IMG_1398.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/a5c068e6-4242-489a-abfd-d6e17e95bd9e/IMG_1398.jpeg)
        
    - 月曜日にフルバックアップし、火曜~日曜までは前日から増分したトランザクションログをバックアップする
    - → 日曜日に障害が起きた場合は、月曜日から土曜日までのすべてのバックアップファイルが必要になる
- 利点
    - バックアップデータ量が三つの方式のうち、最小になる。バックアップファイルを保有する容量も最小にするため、コストの面でも優れている
- 欠点
    - リカバリの手順が最も複雑になる
    - リカバリに要する時間も長くなる

## バックアップ方式にもトレードオフがある

- 3方式の特徴 表
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/02b81f5c-cc33-4e25-b8e2-a75e2fd5c6f2/Untitled.jpeg)
    
    - バックアップコスト(バックアップにかかる時間)が低いほど、リカバリコスト(リカバリにかかる時間)は高いというトレードオフになっている
    - 差分バックアップと増分バックアップの区別が曖昧な製品も存在する
        
        Ex. MySQLでは、差分バックアップと増分バックアップともに「増分バックアップ」となっている
        

### どのバックアップ方式を採用するか？

- バックアップしないことも検討の余地に入れる
    - バックアップファイル以外からデータを復旧させる手段がある場合など
- よく選択される方式は以下二つ
    - フルバックアップ + 差分バックアップ
    - フルバックアップバック + 増分バックアップ

　

# リカバリ設計

### リカバリとリストア

- リストア
    - フルバックアップのファイルをデータベースに戻す
- リカバリ
    - 差分(または増分)していたトランザクションログを適用して変更分を反映する作業
- ロールフォワード
    - DBMS内部に残っているバックアップ後のトランザクションログを適用して反映する作業