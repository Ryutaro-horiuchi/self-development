# データベースのパフォーマンスを決める要因

## インデックス

---

プログラミング言語的な表現だと(x, a)という形式の配列になる

- xはキー値、aは実データかそれへのポインタ

### 前提

- キー
    - インデックスが作成される列（または列の組み合わせ）を指します
        
        ```sql
        CREATE INDEX idx_users_name ON users (name);
        # nameがインデックスのキーとなる
        ```
        
- キー値
    - インデックスが作成された列の実際の値を指す
        
        ```sql
        | id | name  |
        |----|-------|
        | 1  | Alice |
        | 2  | Bob   |
        | 3  | Carol |
        
        # Alice, Bob, Carolがインデックスのキー値となる
        ```
        

## 統計情報

- データへ最短距離でアクセスする方法を決定するための情報

# インデックスの設計

インデックスはSQLのパフォーマンス改善のポピュラーな存在

- アプリケーションのコードに影響を与えない(アプリケーション透過的)
    - 前章の非正規化によるパフォーマンス調整はアプリケーションのコードも変更する必要があった
- テーブルのデータに影響を与えない(データ透過的)
    - インデックスを作成しても、テーブル構造やデータに変化は起きない
- それでいて性能改善の効果が大きい

## B-treeインデックス

---

いろんなインデックスがあるが、頻繁に利用するインデックスはB-treeインデックスのみ

### 構造

![IMG_1417.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/4fc7fe16-d04e-49da-8a3a-3111fb1116f9/8d122ba4-d35e-48c3-b666-ab0a059bf4b7.png)

- 木構造
- 最上位のノード(ルートノード)から順に辿り、最下層のリーフノードのポインタから実データを見つけにいく

### 長所

B-treeインデックスは以下の観点において、平均的に優れている

- 均一性
    - 各キー値の間で検索速度にばらつきがない
        - B-treeが平衡木であるため
            - 平衡木とは、どのリーフもルートからの距離(高さ)が一定であること。
            - どんなキー値を使っても、リーフまでの距離が一定であるため、探索を同じ計算量で行える
    - テーブルへの挿入、更新、削除が繰り返されると、インデックスの構造が崩れ、非平衡木になっていくことがあり、探索にかかるコストもばらつきが出るようになってくる
        - 自動的に修復する機能もあるが、長期間の運用によって更新が重なると崩れてくる
- 持続性
    - データ量の増加に比して、パフォーマンス低下が少ない
    - 計算量はO(log n)
        - 対してフルスキャンはO(n)
        - データ量が増えても、フルスキャンと比べて処理時間は緩やかに増加する
- 処理汎用性
    - 検索、挿入、更新、削除のいずれの処理もそこそこ速い
- 非等値性
    - 等号に限らず、不等号(<、> ..etc)を使っても、そこそこ早い
- 親ソート性
    - GROUP BY、ORDER BY、CONT / MAX / MINなどソートが必要な処理を高速化できる
    - ソート処理について
        - DBMSm内部にて専用のメモリ領域が割り当てられており、その内部に一時的にデータを保持して実施されるが、大量データのソートが必要な場合、メモリに乗り切らず、一時的にディスクへデータを書き出す。
            - → I/Oコストが非常に大きい
            - 大きなソートは避けるべきとされている
    - B-treeインデックスは、構築時にキー値をソートして保持するため、B-treeインデックスの列をORDER BY句のキーとして指定した場合、ソート処理をスキップすることができる

# B-treeインデックスの設計方針

## B-treeインデックスはどの列に作れば良いか

---

### 大規模なテーブルに対して作成する

- データが少ないとフルスキャンの方が早い
    
    ![IMG_1418.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/f8fc41fe-fe8a-4088-a0a5-93e6eec18332/39df8b18-12ea-4829-a405-2d63d31b940c.png)
    
- サーバーの性能等、環境要因によってばらつきはあるが、目安としてデータが1万件以下であれば、B-treeインデックスの効果はほぼない

### カーディナリティの高い列に作成する

- その列の値を指定することで、全体の5%程度に絞り込めるだけのカーディナリティがあるかどうか
- カーディナリティの注意点
    1. 複合列に対してインデックスを作成する場合は単体の列ではなく、組み合わせでカーディナリティを考える
        - Ex.
            
            (a,b,c)という列にインデックスを作るとして、カーディナリティがaは2, bは10, cは5だったとすると、(a,b,c)の組み合わせが100通りあり、カーディナリティは100になる
            
    2. カーディナリティが高くても、特定の値にデータが集中しているような列は向いていない

### SQL文でWHERE句の選択条件、または結合条件に使用されている列に作成する

- 表題に加え、インデックスを使用するには注意点がある。以下のケースはインデックスが使われない
    - インデックス列に演算を行っている
    - インデックス列にSQL関数を適用している
    - IS NULL述語を使用している
    - 否定系を用いている
    - ORを用いている
    - 後方一致、または中間一位のLIKE述語を用いている
    - 暗黙の型変換を行なっている

p178~

主キーおよび一意制約の列には作成しなくて良い

更新性能を劣化させる

定期的なメンテナンスを行うことが望ましい

p180 統計情報

DBMSがSQL文を受け取ると、テーブルにアクセスするまでに、パーサ、オプティマイザ、カタログマネージャの経路を経てアクセスをする

SQLの実行計画は、DBMSが選ぶ

統計情報は大きくテーブル構造が変わった場合に迅速に取ることが望ましいが、負荷の高い処理であるため夜間に実行した方が良い

p184

統計情報を更新させない、凍結させるという選択肢もある

→ DBMSも常に最適な実行計画を立てるとは限らない

演習

ビットマップインデックス

ハッシュインデックス