# データベースのパフォーマンスを決める要因

## インデックス

---

プログラミング言語的な表現だと(x, a)という形式の配列になる

- xはキー値、aは実データかそれへのポインタ

### 前提

- キー
    - インデックスが作成される列（または列の組み合わせ）を指します
        
        ```sql
        CREATE INDEX idx_users_name ON users (name);
        # nameがインデックスのキーとなる
        ```
        
- キー値
    - インデックスが作成された列の実際の値を指す
        
        ```sql
        | id | name  |
        |----|-------|
        | 1  | Alice |
        | 2  | Bob   |
        | 3  | Carol |
        
        # Alice, Bob, Carolがインデックスのキー値となる
        ```
        

# インデックスの設計

インデックスはSQLのパフォーマンス改善のポピュラーな存在

- アプリケーションのコードに影響を与えない(アプリケーション透過的)
    - 前章の非正規化によるパフォーマンス調整はアプリケーションのコードも変更する必要があった
- テーブルのデータに影響を与えない(データ透過的)
    - インデックスを作成しても、テーブル構造やデータに変化は起きない
- それでいて性能改善の効果が大きい

## B-treeインデックス

---

いろんなインデックスがあるが、頻繁に利用するインデックスはB-treeインデックスのみ

### 構造

![IMG_1417.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/4fc7fe16-d04e-49da-8a3a-3111fb1116f9/8d122ba4-d35e-48c3-b666-ab0a059bf4b7.png)

- 木構造
- 最上位のノード(ルートノード)から順に辿り、最下層のリーフノードのポインタから実データを見つけにいく

### 長所

B-treeインデックスは以下の観点において、平均的に優れている

- 均一性
    - 各キー値の間で検索速度にばらつきがない
        - B-treeが平衡木であるため
            - 平衡木とは、どのリーフもルートからの距離(高さ)が一定であること。
            - どんなキー値を使っても、リーフまでの距離が一定であるため、探索を同じ計算量で行える
    - テーブルへの挿入、更新、削除が繰り返されると、インデックスの構造が崩れ、非平衡木になっていくことがあり、探索にかかるコストもばらつきが出るようになってくる
        - 自動的に修復する機能もあるが、長期間の運用によって更新が重なると崩れてくる
- 持続性
    - データ量の増加に比して、パフォーマンス低下が少ない
    - 計算量はO(log n)
        - 対してフルスキャンはO(n)
        - データ量が増えても、フルスキャンと比べて処理時間は緩やかに増加する
- 処理汎用性
    - 検索、挿入、更新、削除のいずれの処理もそこそこ速い
- 非等値性
    - 等号に限らず、不等号(<、> ..etc)を使っても、そこそこ早い
- 親ソート性
    - GROUP BY、ORDER BY、CONT / MAX / MINなどソートが必要な処理を高速化できる
    - ソート処理について
        - DBMSm内部にて専用のメモリ領域が割り当てられており、その内部に一時的にデータを保持して実施されるが、大量データのソートが必要な場合、メモリに乗り切らず、一時的にディスクへデータを書き出す。
            - → I/Oコストが非常に大きい
            - 大きなソートは避けるべきとされている
    - B-treeインデックスは、構築時にキー値をソートして保持するため、B-treeインデックスの列をORDER BY句のキーとして指定した場合、ソート処理をスキップすることができる

# B-treeインデックスの設計方針

## B-treeインデックスはどの列に作れば良いか

---

### 大規模なテーブルに対して作成する

- データが少ないとフルスキャンの方が早い
    
    ![IMG_1418.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/f8fc41fe-fe8a-4088-a0a5-93e6eec18332/39df8b18-12ea-4829-a405-2d63d31b940c.png)
    
- サーバーの性能等、環境要因によってばらつきはあるが、目安としてデータが1万件以下であれば、B-treeインデックスの効果はほぼない

### カーディナリティの高い列に作成する

- その列の値を指定することで、全体の5%程度に絞り込めるだけのカーディナリティがあるかどうか
- カーディナリティの注意点
    1. 複合列に対してインデックスを作成する場合は単体の列ではなく、組み合わせでカーディナリティを考える
        - Ex.
            
            (a,b,c)という列にインデックスを作るとして、カーディナリティがaは2, bは10, cは5だったとすると、(a,b,c)の組み合わせが100通りあり、カーディナリティは100になる
            
    2. カーディナリティが高くても、特定の値にデータが集中しているような列は向いていない

### SQL文でWHERE句の選択条件、または結合条件に使用されている列に作成する

- 表題に加え、インデックスを使用するには注意点がある。以下のケースはインデックスが使われない
    - インデックス列に演算を行っている
    - インデックス列にSQL関数を適用している
    - IS NULL述語を使用している
    - 否定系を用いている
    - ORを用いている
    - 後方一致、または中間一位のLIKE述語を用いている
    - 暗黙の型変換を行なっている

## B-treeインデックスに関するその他の注意事項

- 主キーおよび一意制約の列には作成しなくて良い
    
    → 内部的にB-treeインデックスを使用しているため
    
- B-treeインデックスは更新性能を劣化させる
    - B-treeに限らず、インデックス全般に言われる
    - インデックスはテーブルとは独立したオブジェクトとして保持されており、テーブルの値を変更すると、インデックスの値の変更も発生するため
- 定期的なメンテナンスを行うことが望ましい
    - 更新等により、長期的に運用するとインデックスの構造が崩れ性能が劣化するため

# 統計情報

- テーブルやインデックスなどデータについてのデータ(メタデータ)
    
    → データへ最短距離でアクセスする方法を決定するための情報
    

## オプティマイザと実行計画

---

SQL文を受け取ると、テーブルにアクセスするまでに以下の経路を辿る

![IMG_1421.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/0edce3f0-bf86-4412-b380-5f1d7b79c01c/21317fe9-0fc8-4fa5-a62c-b699667e3261.png)

- パーサ
    - SQL文の構文チェック
- オプティマイザ
    - SQLへの実行計画を決める。カタログマネージャから統計情報を取得し、最短と思われる経路を選択し、SQLを手続に変換する
        
        → この時得られた手続きの手順が「実行計画」と言われる
        
- カタログマネージャー
    - 統計情報を持っている。

## 統計情報の収集をどのように行うか

- 一般的にエンジニアがSQLの実行計画立案に直接的に関与することはない。統計情報を通した間接的な関わり方になる
    
    → 統計情報の設計においても、収集をどのように行うのかが重要になってくる
    

### 統計情報収集のタイミング

- 統計情報は大きくテーブル構造が変わった場合に迅速に取ることが望ましい
    - 古い統計情報からでは適切な実行計画を立てられないため
- しかし負荷の高い処理であるため、システムの利用者の少ない夜間に実施するのが原則

### 統計情報収集の対象(範囲)

- 大きく更新のあったテーブルのみ
    - 統計情報収集は負荷の高い処理であるため

## 統計情報の凍結

特定の統計情報で更新を止めることを、「統計情報を凍結する」「統計情報をロックする」という

→ 現状のものから実行計画を変化させたくない場合に凍結する

- データ量の増加に伴って実行計画が変化し、DBMSが常に最適な実行計画を立てるとは限らない
- オプティマイザの仕事を完全に信じない、悲観的な考えに基づく選択

# 演習

- ビットマップインデックス
    - 検索に用いられるカラムに対して、その値とレコードとのビットマップを使ってレコードを検索するインデックス。
    - メリット
        - カーディナリティが低い列に対して有効
        - OR検索でもインデックスが使用される
    - Ex.  [ビットマップインデックスの仕組み](https://qiita.com/gohandesuyo/items/b3a684157b2eefc69a79)
        - テーブル
            
            
            | ID | 名前 | 血液型 | 性別 |
            | --- | --- | --- | --- |
            | 1 | 佐藤 | A | 男 |
            | 2 | 鈴木 | B | 女 |
            | 3 | 田中 | O | 男 |
            | 4 | 高橋 | A | 女 |
            | 5 | 伊藤 | O | 男 |
            | 6 | 山本 | AB | 女 |
        - ビットマップインデックス
            - 血液型
                
                
                | レコード番号 | 1 | 2 | 3 | 4 | 5 | 6 |
                | --- | --- | --- | --- | --- | --- | --- |
                | A | 1 | 0 | 0 | 1 | 0 | 0 |
                | B | 0 | 1 | 0 | 0 | 0 | 0 |
                | O | 0 | 0 | 1 | 0 | 1 | 0 |
                | AB | 0 | 0 | 0 | 0 | 0 | 1 |
        - 血液型の検索クエリ
            
            ```sql
            select * from ユーザー where 血液型 = 'A';
            ```
            
            > ビットマップインデックスが使用される場合、血液型のビットマップのAのビット列を見る。
            > 
            > 
            > 「100100」となっているため、1つ目のレコードと4つ目のレコードが該当する。
            > 
            > 条件に合致するビット列を見て、値が1になっているレコードを取得するのが
            > 
            > ビットマップインデクスの仕組み
            > 

- [ハッシュインデックス](https://zenn.dev/suzuki_hoge/books/2022-12-database-index-9520da88d02c4f/viewer/6-others)
    - ハッシュ関数
        - 引数が同じなら同じ結果を返す関数
        - ちょっとでも引数が違うと結果が全然違うという特徴を持つ
    - 仕組み
        - データを格納するときに データ自体にハッシュ関数を実行して配置する場所を決める
            - → 探すときも同じハッシュ関数を実行すればデータをしまった場所がわかる
    - メリット
        - 一発でわかるから検索が速い
        - 覚えることが少ないのでインデックスサイズが小さい
    - デメリット
        - 完全一致しか使えない