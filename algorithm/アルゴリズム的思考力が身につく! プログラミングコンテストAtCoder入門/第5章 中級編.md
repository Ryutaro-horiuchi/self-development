## 全探索

- 例題 ABC085 C問題 「[Otoshidama](https://atcoder.jp/contests/abc085/tasks/abc085_c)」
    - 単純な全探索を用いると3重でfor文を回す必要がある
- 有効なアプローチ
    
    <aside>
    💡
    
    変数を3つ同時に動かすのではなく、1つか2つ動かしてのみ考える
    
    </aside>
    

## バケット・連想配列

### バケット

- 配列に含まれる要素の個数を表した配列をバケットと呼ぶ
    
    ```python
    A = [3,1,4,1,5,9,2,6,5,3,5,8,9]
    
    backet = [0,2,1,2,1,3,1,0,1,2]
    ```
    
- 次のような問いに答えられやすい
    - 配列 A に値 v が含まれているか
    - 配列 A に含まれる値は何種類か
    - 配列 A の要素が全て異なるか

### 集合型set

- Pythonのset型は、サイズ取得や、要素vの挿入・削除・検索に要するす計算量は全て平均的にはO(1)である

### 連想配列

- バケットの添字は正の整数値のみに限られるため、特定の文字列が何個出てきたかといった用途には適さない
    - → そのような用途に適しているのが連想配列
    - 連想配列にアクセスするときの計算量は、PYthon3では平均的にO(1)である。collections.defaultdict型を用いる
- 使用例
    
    ```python
    from collections import defaultdict
    
    a = ["cat", "dog", "cow", "lion", "zebra", "cow"]
    
    # int型を指定することで、num[s]のデフォルト値は 0 になる
    num = defaultdict(int)
    
    # 度数分布を作る
    for s in a:
        num[s] += 1
    
    # 結果を表示する
    for key in num:
        print(f"{key}: {num[key]}")
        
    #=> cat: 1
    #=> dog: 1
    #=> cow: 2
    #=> lion: 1
    #=> zebra: 1
    ```
    

### [例題 ABC137 C問題 「Green Bin」](https://atcoder.jp/contests/abc137/tasks/abc137_c)

- ポイント「条件をわかりやすく言い換える」
    - s[i] はs[j] のアナグラムである → s[i] と s[j]はそれぞれソートして一致するかどうか
- 場合の数
    - s[i] がs[j]のアナグラムであるようなものの個数を考える
        - 同じ文字列のグループの中から、2個選ぶ場合の数を考える
            - [3.3 場合の数とアルゴリズム](https://www.notion.so/3-3-1b393db0555480709868f50c9ba056c7?pvs=21)
            - nC₂ = n * (n-1) // 2
- 解
    
    ```python
    from collections import defaultdict
    
    N = int(input())
    
    nums = defaultdict(int)
    for _ in range(N):
        s = "".join(sorted(input()))
        nums[s] += 1
    
    count = 0
    for s in nums:
        c = nums[s]
        count += c * (c-1) // 2
    
    print(count)
    ```
    
- 別解
    - collections.Counterを使用する方法もある