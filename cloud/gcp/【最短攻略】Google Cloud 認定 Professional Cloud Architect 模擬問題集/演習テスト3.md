1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/94a1790a-4320-402b-921d-0489a191f62b/image.png)
    
    - 解説
        - このケーススタディでは、Google CloudのCloud Functions間でセキュアに通信し、特定の関数が他の関数からのリクエストのみを受け付ける仕組みを作る方法について説明しています。要件は、**func_display**からのリクエストだけが**func_query**で受け入れられるようにすることです。
        - ステップ
            1. CloudFunctionsのセキュリティモデル
                - Cloud Functionsはデフォルトでは、全てのリクエストを受け入れるように設定されている
                - しかし、セキュリティを考慮すると、誰からでもアクセスできるのではなく、特定の関数やサービスからのリクエストだけを受け付けるようにすることが望ましい
            2. サービスアカウントと認証
                1. **func_query**のCloud Functionに対して、認証なしのアクセスを拒否するように設定します。具体的には、「**認証を必須にする**」オプションを有効にします。
                2. **func_display**専用のサービスアカウントを作成し、この関数に関連付けます。
                    1. サービスアカウントは、関数が他のGoogle Cloudリソースにアクセスする際の「身分証明書」として機能します。
                3. invokerロールの付与
                    1. **func_display**のサービスアカウントに「**Cloud Functions Invoker**」ロール（`roles/cloudfunctions.invoker`）を付与します。どの関数か指定することができるため、**func_query**を指定します
                    2. このロールを付与することで、**func_display**のサービスアカウントを使って認証されたリクエストだけが**func_query**を呼び出せるようになります。
            3. リクエストにIDトークンを含める
                1. **func_display**が**func_query**を呼び出す際に、リクエストにIDトークンを含める必要があります。IDトークンはJWT（JSON Web Token）の一種で、サービスアカウントを使用して認証されます。
                2. このトークンには、呼び出し元のサービスアカウントが含まれており、**func_query**はこのトークンを検証して、呼び出しが認証されたものかどうかを判断します。

6. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/3ee55fb4-87d3-4c8f-bb43-8c48853a3de5/image.png)

- 解説
    - URLのパスに基づく、グローバルなロードバランシングを行う際は、URL Mapsという機能が最適です。
    - 外部 HTTP(S) ロードバランサでは、1 つの URL マップを使用して、URL マップで構成されたルールに基づいてリクエストを異なる宛先にルーティングできます。
        - https://example.com/video のリクエストは 1 つのバックエンド サービスに送信されます。
        - https://example.com/audio のリクエストは別のバックエンド サービスに送信されます。
        - https://example.com/images のリクエストは Cloud Storage バックエンド バケットに送信されます。
    
    ‣ 
    
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/e40a0ae2-a3c5-4d56-896e-99d0d58aa32d/image.png)
    
    - 解説
        - 各選択肢のステップが長大なため、コアの要件に絞って効率的に選択肢を絞り込む方法が有効です。
            - 「移行に伴うアプリケーションのダウンタイムを最小化する」という要件から考えると、MySQLのダンプよりも、レプリカを作成することの方が適していると判断できます。
                
                これは、既存のデータベースに対して、最小のダウンタイムで行うことのできる方法です。
                
        - 手順の詳細
            
            ### 1. **Cloud VPNを設定して、Compute EngineアプリケーションとオンプレミスのMySQLサーバー間にプライベートネットワーク接続を提供する**
            
            - オンプレミスのネットワークとGoogle Cloud間で安全な通信を行うために、**Cloud VPN**を使用してプライベート接続を確立します。これにより、オンプレミスのMySQLサーバーとGoogle CloudのCompute Engineインスタンスが直接通信できるようになります。
            - この手順は、オンプレミスのアプリケーションを停止する前に、Compute Engineのアプリケーションがオンプレミスのデータベースにアクセスし続けられるようにするためです。
            
            ### 2. **オンプレミスのアプリケーションを停止する**
            
            - 移行中にデータの整合性を保つために、オンプレミスで稼働しているアプリケーションを停止します。これにより、MySQLに対する新しい書き込みが停止し、データの一貫性が維持されます。
            
            ### 3. **オンプレミスのMySQLサーバーに読み書きできるように構成したCompute Engineアプリケーションを起動する**
            
            - オンプレミスのMySQLサーバーにアクセスできるように、**Compute Engine**上でアプリケーションを再起動します。これにより、Google Cloud上のアプリケーションがオンプレミスのMySQLサーバーに接続し続け、データベースの変更がない状態で実行できます。
            
            ### 4. **Cloud SQLでレプリケーション構成を作成する**
            
            - オンプレミスのMySQLサーバーからCloud SQLへのデータレプリケーションを構成します。これにより、オンプレミスのMySQLサーバーのすべてのデータがCloud SQLに複製され、移行に伴うデータの損失が防げます。
            - Google Cloudの「**外部マスター構成**」を使用して、オンプレミスのMySQLデータベースをCloud SQLにレプリケートする方法が推奨されます。
            
            ### 5. **Cloud SQLレプリカからの接続を受け入れるようにソースデータベースサーバーを設定する**
            
            - オンプレミスのMySQLサーバーを、Cloud SQLがレプリケーション接続を許可するように設定します。これには、MySQLの**バイナリログを有効化**し、レプリケーションに必要な適切な設定を行います。
            
            ### 6. **Cloud SQLのレプリカ構成を確定する**
            
            - Cloud SQLでのレプリケーションが開始され、オンプレミスのMySQLサーバーからのデータがリアルタイムで同期される状態を確認します。これにより、Cloud SQL内のデータベースはオンプレミスのデータベースと同一の内容となります。
            
            ### 7. **レプリケーションが完了したら、Compute Engineアプリケーションを停止する**
            
            - データレプリケーションが完了したら、Google Cloud上で稼働していたCompute Engineアプリケーションを停止します。これにより、アプリケーションは一旦すべての操作を停止し、データベースのカットオーバー準備を行います。
            
            ### 8. **Cloud SQLレプリカをスタンドアロンインスタンスにプロモートする**
            
            - Cloud SQLのレプリカを**スタンドアロン**のインスタンスに昇格させます。これにより、Cloud SQLインスタンスがオンプレミスのMySQLに依存せずに独立して稼働できるようになります。
            
            ### 9. **Cloud SQLスタンドアロン・インスタンスに読み書きできるように構成されたCompute Engineアプリケーションを再起動する**
            
            - 最後に、**Cloud SQL**をデフォルトのデータベースとして使用するようにアプリケーションを構成し、Google Cloud上でアプリケーションを再起動します。これにより、データベースの完全移行が完了し、アプリケーションはCloud SQLに対して読み書き操作を行います。

16. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/e82f5e85-9240-495c-b2ad-90dae99f3713/image.png)

- 解説
    - Firebase Test Labはクラウドベースのアプリテストインフラで、様々なデバイスや構成でアプリをテストできます。
        
        テストによって、実際のユーザーの手元でどのように動作するかをよく知ることができます。
        
    - Firebase Test LabはAndroidおよびiOSデバイスでのテストも実現できます。
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/c290618a-426c-461c-8b1c-b54b387630e5/image.png)
    
    - 解説
        - GCDSはユーザーアカウントと他のいくつかのLDAP属性を同期しますが、パスワードは同期しません。
        - SAML（**Security Assertion Markup Language**）
            - ユーザー認証と認可に関するデータをやり取りするための標準的なプロトコル
            - バージョン2.0が広く採用されており、**SAML 2.0**と呼ばれることが多い
            - 特徴
                - **SSO（シングルサインオン）**: 一度ログインすれば、複数のサービスに再度ログインすることなくアクセスできる仕組み
                - **XMLベースのプロトコル**: 認証や属性に関するデータが**XML**形式でやり取りされる
            - 役割
                - **ユーザー**: 認証を受ける人（企業の従業員や顧客など）。
                - **IDプロバイダー（IdP）**: ユーザーを認証する役割を持つシステム。IDプロバイダーはユーザーの資格情報（たとえばパスワード）を管理し、成功した認証後に認証情報を生成します。
                - **サービスプロバイダー（SP）**: 認証されたユーザーがアクセスしたいアプリケーションやサービス。サービスプロバイダーは、IDプロバイダーからの認証情報を確認し、ユーザーがアクセスできるようにします。
            - 流れ
                1. ユーザーがサービスプロバイダー（たとえば、Google Cloudのアプリ）にアクセスを要求します。
                2. サービスプロバイダーは、ユーザーをIDプロバイダーにリダイレクトし、認証を要求します。
                3. ユーザーがIDプロバイダーにログインし、認証されると、IDプロバイダーはSAMLアサーション（認証の証明）をサービスプロバイダーに送信します。
                4. サービスプロバイダーはSAMLアサーションを検証し、ユーザーにアクセスを許可します。
            - なぜSAMLを使用するのか
                - **セキュリティ向上**: パスワードがサービスプロバイダーに保存されず、IDプロバイダーにのみ保存されます。
                - **ユーザーエクスペリエンス向上**: SSOにより、ユーザーは複数のサービスにログインする際に再度認証を行う必要がなくなります。
                - **互換性**: SAMLは、異なるシステムやプラットフォーム間で認証情報をやり取りできる標準で、Google Cloudなど多くのクラウドサービスが対応しています。
        
        ### GCDSとSAMLの違い
        
        | 機能/要件 | **GCDS** | **SAML 2.0** |
        | --- | --- | --- |
        | **ユーザー情報の同期** | ユーザー、グループ、組織情報の同期が可能 | 関係なし |
        | **パスワードの同期** | パスワードは同期されない | 認証は既存のIDプロバイダーで管理 |
        | **認証** | 認証機能なし | 既存のIDプロバイダーで認証（SSO対応） |
        | **ユーザーの利便性** | Google Cloudで新しいアカウントが作成され、別途認証が必要 | 既存のアカウントでシームレスにログイン可能 |
        | **セキュリティ要求** | パスワードは管理されないが、同期されたユーザーはGoogle Cloud上で個別の認証が必要 | 既存の認証基盤を使用し、パスワードはIDプロバイダーのみで管理 |

25. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/38a3529f-d3ae-4e72-9080-2398e0b99a86/image.png)

- 解説
    - 権限は親階層から継承され、ユニオンとなります。
    - 該当のフォルダのいずれかにリソースを作成できないようにするには、組織レベルの所有者を削除する必要があります。
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/8f03dd56-f479-4dd1-949b-19b4cdce0fd4/image.png)
    
    - 解説
        - `--encryption-key`フラグは、個別のオブジェクトのアップロード操作に対して暗号化キーを指定するものであり、バケットそのものにデフォルトの暗号化キーを適用する機能ではありません。
        - gsutilを使ってCloud Storageにアップロードする際、暗号化キーを指定するために`--encryption-key`フラグを使うことは正しいですが、それは**個々のコマンドで一時的に指定する方法です。**これは有効な方法ですが、**毎回手動でキーを指定する必要がある**ため、利便性に欠けます。
            
            ```bash
            gsutil cp --encryption-key <your-encryption-key> file.txt gs://your-bucket/
            ```
            
        - 一方、暗号化キーを`.boto`設定ファイルに指定する方法は、**デフォルトで使用される暗号化キーを設定**できます。
            
            ```bash
            [GSUtil]
            encryption_key = <your-encryption-key>
            ```
            

30. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/3c8b916a-2b6a-405d-a07d-932f9657c63d/image.png)

- 解説
    - ‣
    - この問題は、インターネットアクセスが制限されている高度なセキュリティ環境で、Google CloudのCompute Engine VMにどのようにソフトウェアをインストールするかに関するものです
    - 手順
        1. Cloud Storageにインストールファイルをアップロード
            1. ファイルサーバーや他のインターネット接続を必要とせずに、インストールファイルをCloud Storageにアップロードできるため、この方法が安全です。
        2. VMをGoogle Accessのプライベートサブネットに設定する
            1. 次に、VMインスタンスがインターネットを直接利用せずにGoogle Cloudサービス（Cloud Storageなど）にアクセスできるように、**プライベートサブネット**（VPC）を設定します。
            2. Googleの**Private Google Access**を使用します。これは、インターネット経由ではなく、Googleの内部ネットワーク経由でGoogle Cloudサービスにアクセスできる仕組みです。Private Google Accessを有効化するには、VMが内部IPアドレスを持つVPCネットワーク内に存在する必要があります。
        3. VMに内部IPアドレスのみを割り当てる
            
            セキュリティのために、VMに**内部IPアドレスのみ**を割り当て、外部IPアドレスを持たない設定にします。これにより、VMはインターネットから直接アクセスできなくなり、安全性が高まります。
            
        4. gsutilを使用してファイルをダウンロード
            
            `gsutil`は、Cloud Storageに対してファイルのアップロードやダウンロードを行うためのCLIツールです。VMから直接Cloud Storageにアクセスして、アップロードしたインストールファイルをダウンロードし、インストールすることができます。
            
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/805d08a2-e5ba-49cb-930e-93b17f31e3d1/image.png)
    
    - 解説
        - 解答について
            
            Cloud Shellは、仮想マシンインスタンス上の$HOMEディレクトリにマウントされた5GBの無料永続ディスクストレージを提供します。
            
            このストレージはユーザー単位で、プロジェクト間で利用可能です。
            
            インストール済みのソフトウェア、スクリプト、および .bashrc や .vimrc などのユーザー設定ファイルを含め、ホーム ディレクトリに保存したすべてのファイルは、セッション間で持続されます。
            
            ホーム・ディレクトリはあなただけのもので、他のユーザがアクセスすることはできません。
            
        - カスタムユーティリティ
            - 開発者が独自に作成した汎用的な関数やクラス、ライブラリのこと
        - Cloud Shellの特性
            - **$HOMEディレクトリの永続性**: Cloud Shellでは、`$HOME` ディレクトリにマウントされた5GBの永続的なストレージが提供される。このストレージは、Cloud Shellセッションが終了してもデータが保持され、再度ログインしてもそのままアクセス可能
                - $HOME とは
                    - ユーザーのホームディレクトリを指す環境変数です。Cloud Shellでは、`/home/<username>` のようなパスが割り当てられており、このディレクトリ内に個人のファイルや設定を保存します。
            - Cloud Shellは一時的な仮想マシンであり、セッションが終了すると削除されるが、$HOMEディレクトリは永続的であるため、仮想マシンが変わってもデータは消えない
        - ~/bin
            - Cloud ShellのPATHには、デフォルトで~/binディレクトリが含まれている。$HOMEディレクトリ配下なので、セッションが終了しても、~/binは以下のファイルは引き続き利用できる
            - Cloud Shellでは、各ユーザーに対して**専用の`$HOME`ディレクトリ**（およびその配下の`~/bin`ディレクトリ）が割り当てられます。したがって、他のユーザーが同じCloud Shellインスタンスを使用していても、**各ユーザーは自分専用の`$HOME`ディレクトリ**を持っており、その中に保存されたファイルやディレクトリは他のユーザーからアクセスできません。
            
            ※ ~/binは、$HOME/bin と同義
            
        - /usr/local/bin
            - システム全体のディレクトリであり、通常は管理者権限が必要な場所です。システム全体で利用できるプログラムやコマンドがここに配置されます。
            - ただし、Cloud Shellのような一時的な仮想環境では、このディレクトリは永続的なストレージではなく、またユーザーがこのディレクトリに書き込む権限も通常はありません。