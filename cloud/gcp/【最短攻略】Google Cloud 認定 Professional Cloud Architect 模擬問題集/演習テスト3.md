1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/90c73cf0-630e-48af-81f5-6a3e3cbf7265/image.png)
    
    - 解説
        - デジタル署名
            - データをハッシュ化し、秘密鍵で署名し、公開鍵で検証する
            - データの改ざん防止や認証を目的としている
                - ハッシュ化 Ex. SHA-256
                    
                    ```bash
                    a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b56c94eaf2b7a6432
                    ```
                    
                - 秘密鍵で署名 Ex. RSA
                    
                    ```bash
                    7a1a97dc06bf2f1e88ba54258b32f77c3d5f6a597c8f987b164d6f61b0e0e6a2...
                    ```
                    
                    - RSAの秘密鍵を使ってハッシュ値をべき乗計算とモジュロ演算によって変換する。結果はバイナリデータ
                - 公開鍵の検証
                    - 署名を公開鍵を使って元のハッシュ値に戻す
                    - 元データを再度ハッシュ化して、公開鍵で複合したハッシュ値と一致するかを検証する
            
            ‣ 
            

4. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/94a1790a-4320-402b-921d-0489a191f62b/image.png)

- 解説
    - このケーススタディでは、Google CloudのCloud Functions間でセキュアに通信し、特定の関数が他の関数からのリクエストのみを受け付ける仕組みを作る方法について説明しています。要件は、**func_display**からのリクエストだけが**func_query**で受け入れられるようにすることです。
    - ステップ
        1. CloudFunctionsのセキュリティモデル
            - Cloud Functionsはデフォルトでは、全てのリクエストを受け入れるように設定されている
            - しかし、セキュリティを考慮すると、誰からでもアクセスできるのではなく、特定の関数やサービスからのリクエストだけを受け付けるようにすることが望ましい
        2. サービスアカウントと認証
            1. **func_query**のCloud Functionに対して、認証なしのアクセスを拒否するように設定します。具体的には、「**認証を必須にする**」オプションを有効にします。
            2. **func_display**専用のサービスアカウントを作成し、この関数に関連付けます。
                1. サービスアカウントは、関数が他のGoogle Cloudリソースにアクセスする際の「身分証明書」として機能します。
            3. invokerロールの付与
                1. **func_display**のサービスアカウントに「**Cloud Functions Invoker**」ロール（`roles/cloudfunctions.invoker`）を付与します。どの関数か指定することができるため、**func_query**を指定します
                2. このロールを付与することで、**func_display**のサービスアカウントを使って認証されたリクエストだけが**func_query**を呼び出せるようになります。
        3. リクエストにIDトークンを含める
            1. **func_display**が**func_query**を呼び出す際に、リクエストにIDトークンを含める必要があります。IDトークンはJWT（JSON Web Token）の一種で、サービスアカウントを使用して認証されます。
            2. このトークンには、呼び出し元のサービスアカウントが含まれており、**func_query**はこのトークンを検証して、呼び出しが認証されたものかどうかを判断します。

6. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/3ee55fb4-87d3-4c8f-bb43-8c48853a3de5/image.png)

- 解説
    - URLのパスに基づく、グローバルなロードバランシングを行う際は、URL Mapsという機能が最適です。
    - 外部 HTTP(S) ロードバランサでは、1 つの URL マップを使用して、URL マップで構成されたルールに基づいてリクエストを異なる宛先にルーティングできます。
        - https://example.com/video のリクエストは 1 つのバックエンド サービスに送信されます。
        - https://example.com/audio のリクエストは別のバックエンド サービスに送信されます。
        - https://example.com/images のリクエストは Cloud Storage バックエンド バケットに送信されます。
    
    ‣ 
    
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/e40a0ae2-a3c5-4d56-896e-99d0d58aa32d/image.png)
    
    - 解説
        - 各選択肢のステップが長大なため、コアの要件に絞って効率的に選択肢を絞り込む方法が有効です。
            - 「移行に伴うアプリケーションのダウンタイムを最小化する」という要件から考えると、MySQLのダンプよりも、レプリカを作成することの方が適していると判断できます。
                
                これは、既存のデータベースに対して、最小のダウンタイムで行うことのできる方法です。
                
        - 手順の詳細
            
            ### 1. **Cloud VPNを設定して、Compute EngineアプリケーションとオンプレミスのMySQLサーバー間にプライベートネットワーク接続を提供する**
            
            - オンプレミスのネットワークとGoogle Cloud間で安全な通信を行うために、**Cloud VPN**を使用してプライベート接続を確立します。これにより、オンプレミスのMySQLサーバーとGoogle CloudのCompute Engineインスタンスが直接通信できるようになります。
            - この手順は、オンプレミスのアプリケーションを停止する前に、Compute Engineのアプリケーションがオンプレミスのデータベースにアクセスし続けられるようにするためです。
            
            ### 2. **オンプレミスのアプリケーションを停止する**
            
            - 移行中にデータの整合性を保つために、オンプレミスで稼働しているアプリケーションを停止します。これにより、MySQLに対する新しい書き込みが停止し、データの一貫性が維持されます。
            
            ### 3. **オンプレミスのMySQLサーバーに読み書きできるように構成したCompute Engineアプリケーションを起動する**
            
            - オンプレミスのMySQLサーバーにアクセスできるように、**Compute Engine**上でアプリケーションを再起動します。これにより、Google Cloud上のアプリケーションがオンプレミスのMySQLサーバーに接続し続け、データベースの変更がない状態で実行できます。
            
            ### 4. **Cloud SQLでレプリケーション構成を作成する**
            
            - オンプレミスのMySQLサーバーからCloud SQLへのデータレプリケーションを構成します。これにより、オンプレミスのMySQLサーバーのすべてのデータがCloud SQLに複製され、移行に伴うデータの損失が防げます。
            - Google Cloudの「**外部マスター構成**」を使用して、オンプレミスのMySQLデータベースをCloud SQLにレプリケートする方法が推奨されます。
            
            ### 5. **Cloud SQLレプリカからの接続を受け入れるようにソースデータベースサーバーを設定する**
            
            - オンプレミスのMySQLサーバーを、Cloud SQLがレプリケーション接続を許可するように設定します。これには、MySQLの**バイナリログを有効化**し、レプリケーションに必要な適切な設定を行います。
            
            ### 6. **Cloud SQLのレプリカ構成を確定する**
            
            - Cloud SQLでのレプリケーションが開始され、オンプレミスのMySQLサーバーからのデータがリアルタイムで同期される状態を確認します。これにより、Cloud SQL内のデータベースはオンプレミスのデータベースと同一の内容となります。
            
            ### 7. **レプリケーションが完了したら、Compute Engineアプリケーションを停止する**
            
            - データレプリケーションが完了したら、Google Cloud上で稼働していたCompute Engineアプリケーションを停止します。これにより、アプリケーションは一旦すべての操作を停止し、データベースのカットオーバー準備を行います。
            
            ### 8. **Cloud SQLレプリカをスタンドアロンインスタンスにプロモートする**
            
            - Cloud SQLのレプリカを**スタンドアロン**のインスタンスに昇格させます。これにより、Cloud SQLインスタンスがオンプレミスのMySQLに依存せずに独立して稼働できるようになります。
            
            ### 9. **Cloud SQLスタンドアロン・インスタンスに読み書きできるように構成されたCompute Engineアプリケーションを再起動する**
            
            - 最後に、**Cloud SQL**をデフォルトのデータベースとして使用するようにアプリケーションを構成し、Google Cloud上でアプリケーションを再起動します。これにより、データベースの完全移行が完了し、アプリケーションはCloud SQLに対して読み書き操作を行います。

16. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/e82f5e85-9240-495c-b2ad-90dae99f3713/image.png)

- 解説
    - Firebase Test Labはクラウドベースのアプリテストインフラで、様々なデバイスや構成でアプリをテストできます。
        
        テストによって、実際のユーザーの手元でどのように動作するかをよく知ることができます。
        
    - Firebase Test LabはAndroidおよびiOSデバイスでのテストも実現できます。
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/0851d54d-c239-45c4-b962-e1b2a86ca9c5/image.png)
    
    - 解説
        - Pub/Sub API では、Cloud Monitoring を介してメトリクスをエクスポートします。
        - 今回はPub/Subの中に処理されないデータが徐々に蓄積されること原因になるため、未処理のデータの数をもとにKubernetesポッドをスケーリングする必要があります。
        - `subscription/num_undelivered_messages` メトリクスは、確認応答されていないメッセージの数を表示します。
        - この数が大きくなった場合は、現在のポッドの状態ではキャパシティーを超過していることになるので、スケーリングが必要になります。
    

1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/c290618a-426c-461c-8b1c-b54b387630e5/image.png)
    
    - 解説
        - GCDSはユーザーアカウントと他のいくつかのLDAP属性を同期しますが、パスワードは同期しません。
        - SAML（**Security Assertion Markup Language**）
            - ユーザー認証と認可に関するデータをやり取りするための標準的なプロトコル
            - バージョン2.0が広く採用されており、**SAML 2.0**と呼ばれることが多い
            - 特徴
                - **SSO（シングルサインオン）**: 一度ログインすれば、複数のサービスに再度ログインすることなくアクセスできる仕組み
                - **XMLベースのプロトコル**: 認証や属性に関するデータが**XML**形式でやり取りされる
            - 役割
                - **ユーザー**: 認証を受ける人（企業の従業員や顧客など）。
                - **IDプロバイダー（IdP）**: ユーザーを認証する役割を持つシステム。IDプロバイダーはユーザーの資格情報（たとえばパスワード）を管理し、成功した認証後に認証情報を生成します。
                - **サービスプロバイダー（SP）**: 認証されたユーザーがアクセスしたいアプリケーションやサービス。サービスプロバイダーは、IDプロバイダーからの認証情報を確認し、ユーザーがアクセスできるようにします。
            - 流れ
                1. ユーザーがサービスプロバイダー（たとえば、Google Cloudのアプリ）にアクセスを要求します。
                2. サービスプロバイダーは、ユーザーをIDプロバイダーにリダイレクトし、認証を要求します。
                3. ユーザーがIDプロバイダーにログインし、認証されると、IDプロバイダーはSAMLアサーション（認証の証明）をサービスプロバイダーに送信します。
                4. サービスプロバイダーはSAMLアサーションを検証し、ユーザーにアクセスを許可します。
            - なぜSAMLを使用するのか
                - **セキュリティ向上**: パスワードがサービスプロバイダーに保存されず、IDプロバイダーにのみ保存されます。
                - **ユーザーエクスペリエンス向上**: SSOにより、ユーザーは複数のサービスにログインする際に再度認証を行う必要がなくなります。
                - **互換性**: SAMLは、異なるシステムやプラットフォーム間で認証情報をやり取りできる標準で、Google Cloudなど多くのクラウドサービスが対応しています。
        
        ### GCDSとSAMLの違い
        
        | 機能/要件 | **GCDS** | **SAML 2.0** |
        | --- | --- | --- |
        | **ユーザー情報の同期** | ユーザー、グループ、組織情報の同期が可能 | 関係なし |
        | **パスワードの同期** | パスワードは同期されない | 認証は既存のIDプロバイダーで管理 |
        | **認証** | 認証機能なし | 既存のIDプロバイダーで認証（SSO対応） |
        | **ユーザーの利便性** | Google Cloudで新しいアカウントが作成され、別途認証が必要 | 既存のアカウントでシームレスにログイン可能 |
        | **セキュリティ要求** | パスワードは管理されないが、同期されたユーザーはGoogle Cloud上で個別の認証が必要 | 既存の認証基盤を使用し、パスワードはIDプロバイダーのみで管理 |

25. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/38a3529f-d3ae-4e72-9080-2398e0b99a86/image.png)

- 解説
    - 権限は親階層から継承され、ユニオンとなります。
    - 該当のフォルダのいずれかにリソースを作成できないようにするには、組織レベルの所有者を削除する必要があります。
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/8f03dd56-f479-4dd1-949b-19b4cdce0fd4/image.png)
    
    - 解説
        - `--encryption-key`フラグは、個別のオブジェクトのアップロード操作に対して暗号化キーを指定するものであり、バケットそのものにデフォルトの暗号化キーを適用する機能ではありません。
        - gsutilを使ってCloud Storageにアップロードする際、暗号化キーを指定するために`--encryption-key`フラグを使うことは正しいですが、それは**個々のコマンドで一時的に指定する方法です。**これは有効な方法ですが、**毎回手動でキーを指定する必要がある**ため、利便性に欠けます。
            
            ```bash
            gsutil cp --encryption-key <your-encryption-key> file.txt gs://your-bucket/
            ```
            
        - 一方、暗号化キーを`.boto`設定ファイルに指定する方法は、**デフォルトで使用される暗号化キーを設定**できます。
            
            ```bash
            [GSUtil]
            encryption_key = <your-encryption-key>
            ```
            
    

30. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/3c8b916a-2b6a-405d-a07d-932f9657c63d/image.png)

- 解説
    - ‣
    - この問題は、インターネットアクセスが制限されている高度なセキュリティ環境で、Google CloudのCompute Engine VMにどのようにソフトウェアをインストールするかに関するものです
    - 手順
        1. Cloud Storageにインストールファイルをアップロード
            1. ファイルサーバーや他のインターネット接続を必要とせずに、インストールファイルをCloud Storageにアップロードできるため、この方法が安全です。
        2. VMをGoogle Accessのプライベートサブネットに設定する
            1. 次に、VMインスタンスがインターネットを直接利用せずにGoogle Cloudサービス（Cloud Storageなど）にアクセスできるように、**プライベートサブネット**（VPC）を設定します。
            2. Googleの**Private Google Access**を使用します。これは、インターネット経由ではなく、Googleの内部ネットワーク経由でGoogle Cloudサービスにアクセスできる仕組みです。Private Google Accessを有効化するには、VMが内部IPアドレスを持つVPCネットワーク内に存在する必要があります。
        3. VMに内部IPアドレスのみを割り当てる
            
            セキュリティのために、VMに**内部IPアドレスのみ**を割り当て、外部IPアドレスを持たない設定にします。これにより、VMはインターネットから直接アクセスできなくなり、安全性が高まります。
            
        4. gsutilを使用してファイルをダウンロード
            
            `gsutil`は、Cloud Storageに対してファイルのアップロードやダウンロードを行うためのCLIツールです。VMから直接Cloud Storageにアクセスして、アップロードしたインストールファイルをダウンロードし、インストールすることができます。
            
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/805d08a2-e5ba-49cb-930e-93b17f31e3d1/image.png)
    
    - 解説
        - 解答について
            
            Cloud Shellは、仮想マシンインスタンス上の$HOMEディレクトリにマウントされた5GBの無料永続ディスクストレージを提供します。
            
            このストレージはユーザー単位で、プロジェクト間で利用可能です。
            
            インストール済みのソフトウェア、スクリプト、および .bashrc や .vimrc などのユーザー設定ファイルを含め、ホーム ディレクトリに保存したすべてのファイルは、セッション間で持続されます。
            
            ホーム・ディレクトリはあなただけのもので、他のユーザがアクセスすることはできません。
            
        - カスタムユーティリティ
            - 開発者が独自に作成した汎用的な関数やクラス、ライブラリのこと
        - Cloud Shellの特性
            - **$HOMEディレクトリの永続性**: Cloud Shellでは、`$HOME` ディレクトリにマウントされた5GBの永続的なストレージが提供される。このストレージは、Cloud Shellセッションが終了してもデータが保持され、再度ログインしてもそのままアクセス可能
                - $HOME とは
                    - ユーザーのホームディレクトリを指す環境変数です。Cloud Shellでは、`/home/<username>` のようなパスが割り当てられており、このディレクトリ内に個人のファイルや設定を保存します。
            - Cloud Shellは一時的な仮想マシンであり、セッションが終了すると削除されるが、$HOMEディレクトリは永続的であるため、仮想マシンが変わってもデータは消えない
        - ~/bin
            - Cloud ShellのPATHには、デフォルトで~/binディレクトリが含まれている。$HOMEディレクトリ配下なので、セッションが終了しても、~/binは以下のファイルは引き続き利用できる
            - Cloud Shellでは、各ユーザーに対して**専用の`$HOME`ディレクトリ**（およびその配下の`~/bin`ディレクトリ）が割り当てられます。したがって、他のユーザーが同じCloud Shellインスタンスを使用していても、**各ユーザーは自分専用の`$HOME`ディレクトリ**を持っており、その中に保存されたファイルやディレクトリは他のユーザーからアクセスできません。
            
            ※ ~/binは、$HOME/bin と同義
            
        - /usr/local/bin
            - システム全体のディレクトリであり、通常は管理者権限が必要な場所です。システム全体で利用できるプログラムやコマンドがここに配置されます。
            - ただし、Cloud Shellのような一時的な仮想環境では、このディレクトリは永続的なストレージではなく、またユーザーがこのディレクトリに書き込む権限も通常はありません。

41. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/176403c5-dd74-46ae-81d6-c18c8a4b2835/image.png)

- 解説
    
    ‣ 
    
    Cloud Runはリージョナルなサービスです。
    
    グローバルなユーザーにサービスを提供するためには、グローバルHTTP LBとバックエンドとしてNEGを設定する必要があります。
    
    1. **Cloud Runのリージョナル性**
    
    - Cloud Runは**リージョナルなサービス**であるため、1つのリージョンで実行するだけでは、グローバルな顧客に対して低遅延や高可用性を十分に提供できません。
    - 遠くの地域からのリクエストには遅延が生じるため、複数のリージョンにサービスを展開することが重要です。
    1. サーバーレスNEG（Network Endpoint Group）
        - **サーバーレスNEG**は、Cloud RunやApp Engine、Cloud Functionsなどのサーバーレスサービスに特化したエンドポイントグループです。
        - **サーバーレスNEG**を使用して、Cloud Runサービスをロードバランサーのバックエンドとして登録します。これにより、ロードバランサーはユーザーからのリクエストを適切なリージョンにルーティングし、低遅延を確保できます
    2. **グローバルHTTP(S)ロードバランサー**
        
        ユーザーの地理的位置に基づいて、最も近いリージョンのCloud Runサービスにリクエストをルーティングします。
        
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/eb8ee527-1b3b-46ff-9bda-d35c389fff87/image.png)
    
    - 解説
        - サービスを使う
            - 特定のデプロイメント（マイクロサービス）のすべてのレプリカに対して**統一的なDNS名**を提供します。これにより、他のマイクロサービスがそのDNS名を使ってアクセスすると、適切なレプリカに負荷分散されます。
        - サービスのDNS名は内部で自動的に解決され、他のマイクロサービスが同じクラスタ内で統一的にアクセスできます。
        - Ingressは通常、外部からのアクセスを管理するために使われます。今回の要件では、クラスタ内部のマイクロサービス間の通信なので、**Serviceを使用して内部通信を実現**するのが適切です。

47. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/a8ff4868-9a80-4076-882f-9e1aa49f08ad/image.png)

- 解説
    - `gcloud`ツールを使って永続ディスクスナップショットを取得する方法では、スナップショットを取得する際にI/Oが発生します。これにより、データベースのパフォーマンスに影響を与える可能性があります。
    - ローカルSSDは高いIO性能を持ち、DBのバックアップとして適している。
    - 実際の作業としてはCloud ConsoleやCloud Shellを使用して、MySQLインスタンスにSSHで接続し、ローカルSSDをインスタンスに追加し、マウント → バックアップ → GCSへの移動という流れになる
1. 
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/42b16988-a5a8-437d-af8b-c8412ee1342b/76d5a672-13fd-4c8d-abff-174b46523bec/image.png)
    
- 解説
    
    **自動化フレームワークの選択**は重要ですが、他の選択肢に比べて直接的な移行プロセスにはあまり関与しません。