## Vueのおさらい

### SFC(単一ファイルコンポーネント)

- コンポーネントに必要なscript, template, styleを一つにまとめたもの

### リアクティブ

- 変数の値が変化すると、表示内容が自動で変わること
- refやcomputedを使用する
- computed記法(TypeScript)
    
    ```tsx
    const 変数名　= computed((): 結果の型 => {});
    ```
    
- reactive
    - オブジェクトをまとめてリアクティブに
    
    ```tsx
    const 変数名 = reactive(オブジェクト)
    ```
    

### ディレクティブ

- テンプレートブロックでHTMLタグ内に記述する `v-` で始まる属性のこと

### メソッドの引数とイベント

- イベントのみ
    
    ```tsx
    const onButtonClick = (event: Event): void => {
    	...
    }
    
    <template>
    	<button @click="onButtonClick">
    </template>
    ```
    
- 任意の引数とイベント
    
    ```tsx
    const onButtonClick = (label: string, event: Event): void => {
    	...
    }
    
    <template>
    	<button @click="onButtonClick("hello", $event)">
    </template>
    ```
    

### ライフサイクルフック

[ライフサイクルフック(Compositon API)](https://www.notion.so/Compositon-API-90fe791fcd714676b9234060b1cedb07?pvs=21) 

### v-cloak

- マスタッシュ構文がレンダリングされる前に一瞬そのまま表示されてしまわないように、該当箇所を一時的に非表示にするためのディレクティブ
    
    ```tsx
    <template>
      <p v-cloak>{{ hello }}</p>
    </template>
    <style scoped>
    [v-cloak] {
      display: none;
    }
    </style>
    ```
    
    - helloの値がpタグ内に表示されるまで、pタグにはv-cloak属性が付与されたままになる
    - helloの値が表示されると同時に、v-cloak属性が削除される
        - この仕組みを利用して、v-cloak属性と`display: none;`を組み合わせて、マスタッシュ構文がレンダリングされるまで、一時的に非表示にすることができる

### Props

- 親コンポーネントから子コンポーネントへデータを渡す仕組み
- TypeScript環境だと以下のような記述になる
    1. 個々のPropをメンバとするinterfaceを定義する
    2. defineProps()関数を実行する
    
    ```tsx
    // 1.
    interface Props {
    	各Prop名: データ型;
    	...
    }
    
    // 2.
    defineProps<Props>();
    ```
    
- Ex.
    
    ```tsx
    <script setup lang="ts">
    //Propsインターフェースの定義。
    interface Props {
    	id: number;
    	name: string;
    	email: string;
    	points: number;
    	note?: string;
    }
    
    //Propsオブジェクトの設定。
    const props = defineProps<Props>();
    
    //このコンポーネント内で利用するポイント数のテンプレート変数。
    const localPoints = ref(props.points);
    </script>
    ```
    

### Emit

- 子から親へイベントを渡す仕組み
- TypeScript環境だと以下のような記述になる
    1. Emitの定義
        
        ```tsx
        //コールシグネチャによるEmitsの定義。
        // interface Emits {
        // 	(event: "incrementPoint", id: number): void;
        // }
        
        // typeキーワードを使用したEmitsの定義。
        type Emits = {
        	incrementPoint: [id: number];
        };
        
        //Emitの設定。
        const emit = defineEmits<Emits>();
        ```
        
        - typeキーワードを使用して、型を定義
            - イベント名がプロパティ
            - 値に「ラベル付きタプル」
                - [ラベル付きタプル型](https://www.notion.so/2a193db0555480308dfed1aee957339f?pvs=21) (Vue.js 3.3以降)
            - コールシグネチャによるEmits型定義
                - [コールシグネチャによる関数型の表現](https://www.notion.so/2a593db0555480528217e55c14f58dab?pvs=21)
    2. Emitの実行
        
        ```tsx
        const pointUp = (): void => {
        	emit("incrementPoint", props.id);
        }
        ```
        

## Nuxt AutoImports (オートインポート)

Vueの時に記述した下記のようなimport文は不要。Nuxtは自動で必要な関数をインポートしてくれる

```tsx
import { ref, computed } from "vue";
```

## event.targetのアサーション

```tsx
const onButtonClick = (label: string, event: Event): void => {
	...
	const target = event.target as HTMLButtonElement
	const text = target.innerText
}

<template>
	<button @click="onButtonClick("hello", $event)">
</template>
```

- eventのtargetプロパティの型は`EventTarget`になるが、EventTargetオブジェクトには、innerTextプロパティはない
- イベントが発生したターゲットの実態であるボタンに型変換する必要があり、その型変換のキーワードがasであり、`HTMLButtonElement`という型になる

## Nuxtのコンポーネント間連携

### Ex.

- ディレクトリ構成
    - components/OneSection.vue
    - components/parts/TheSupplement.vue
    - app.vue
- app.vue
    
    ```tsx
    <template>
    	<section>
    		<h1>コンポーネント基礎</h1>
    		<OneSection/>
    		<OneSection/>
    		<PartsTheSupplement/>
    	</section>
    </template>
    
    <style>
    section {
    	border: blue 1px solid;
    	margin: 10px;
    }
    </style>
    
    ```
    

### Nuxtはコンポーネントもオートインポート

- componentsフォルダ内のコンポーネントも自動化されている
- タグ名に注意
    - Ex.の`PartsTheSupplement.vue`というファイルは存在しないが、これはpartsフォルダ内のTheSupplement.vueを表している記述だと、Nuxtは解釈する
- 公式ドキュメントでは、サブフォルダ内のコンポーネントファイル名には、サブフォルダ名を含めることを推奨している
    - Ex.では、`TheSupplement.vue`としていたが、タグ名を含めた`PartsTheSupplement.vue`がより推奨されたファイル名ということになる

# ステートの利用

- アプリケーション全体でデータを保持しておき、各コンポーネントはそこからデータを取得したり書き換えたりする仕組み
    - Vue単体では、ProvideやInject
    - モジュールではPinia
    - Nuxtには独自のステート管理がある

## 独自のNuxtのステート管理を利用したサンプル

### 型の準備

- interfaces.ts
    
    ```tsx
    export interface Member {
    	id: number;
    	name: string;
    	email: string;
    	points: number;
    	note?: string;
    }
    ```
    

### ステートを用意する useState()

- app.vue
    
    ```tsx
    <script setup lang="ts">
    import type {Member} from "@/interfaces";
    
    //会員情報リストをステートとして用意。
    useState<Map<number, Member>>(
    	"memberList",
    	(): Map<number, Member> => {
    		const memberListInit = new Map<number, Member>();
    		memberListInit.set(33456, {id: 33456, name: "田中太郎", email: "bow@example.com", points: 35, note: "初回入会特典あり。"});
    		memberListInit.set(47783, {id: 47783, name: "鈴木二郎", email: "mue@example.com", points: 53});
    		return memberListInit;
    	}
    );
    </script>
    
    <template>
    	<TheBaseSection/>
    </template>
    ```
    
    - useState()
        - `script`ブロックでこの関数を実行すると、Nuxtはそのデータはステートとして管理し、コンポーネントを跨いで利用できるリアクティブデータとして扱えるようになる
        - ステートするデータをジェネリクスとして型指定する
        - 引数
            - 第一引数はステート名。アプリケーション全体で一意になるように
            - 第二引数はステートして管理するデータの初期値を生成するアロー関数
        - 戻り値
            - ジェネリクスで指定した型と同じにする
        - 構文
            
            ```tsx
            useState<ステートのデータ型>(
            	ステート名,
            	(): ステートのデータ型 => {
            		ステートの初期値の生成処理
            		return ステートの初期値;
            	}
            )
            ```
            

### ステートの利用もuseState()

- TheBaseSection
    
    ```tsx
    //会員情報リストをステートから取得。
    const memberList = useState<Map<number, Member>>("memberList");
    
    //保有ポイントの合計の算出プロパティ。
    const totalPoints = computed(
    	(): number => {
    		let total = 0;
    		for(const member of memberList.value.values()) {
    			total += member.points;
    		}
    		return total;
    	}
    );
    ```
    
    - 利用するときもuseStateを使用する
    - 定義した時との違いは、引数。第一引数のステート名のみ
    - 取得したステートデータはリアクティブであるため、valueプロパティを使用してアクセスする
    - 構文
        
        ```tsx
        const ステートを格納する変数　= useState<ステートのデータ型>(ステート名);
        ```
        

### その他

- ステートを利用するとPropsが最小限になる
- データ更新も直接ステートを変更