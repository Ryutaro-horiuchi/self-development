## 変数に型注釈を与える

```tsx
const 変数: 型　= 式;

const greeting: string = "Hello";
```

## 数値型

### TypeScriptにおける数値型の特徴

- number型では整数と小数の区別がない。
    - 言語によっては、整数と小数が別の型になっていたり、数値を表すのに使用するバイト数に応じて異なる型があるが、TypeScriptではそのような区別がない

### 数値リテラル

- 2進数・8進数・16進数
    
    ```tsx
    const binary = 0b1010; // 2進数リテラル
    const octal = 0o755; // 8進数リテラル
    const hexadecimal = 0xff; // 16進数リテラル
    
    console.log(num, binary, octal, hexadecimal);
    //=> 10 10 493 255
    ```
    
    2進数・8進数・16進数はそれぞれ接頭辞`0b`, `0o`, `0x`をつける
    
- 指数表記
    
    ```tsx
    const big = 1e8;
    const small = 4e-5;
    
    console.log(big, small);
    //=> 100000000 0.00004
    ```
    

### NaNについて

- 数値が必要な場面で数値が得られなかった場合に出現する値
- 数値計算においてNaNが絡む計算の結果は常にNaNになるため、NaNが得られた場合にどうするかを考える必要がある
- 等価演算子のどちらかのオペランドに、NaNが与えられた場合は常にfalseを返す
    - NaNかどうかの判定は、Number.isNaN関数を使用する

### TypeScriptにおける数値はIEEE 754倍精度小数点数である

- 64ビットで現れる小数型
- 数値(仮数部)の精度が53ビットである
    - 整数の情報量も53ビットであり、53ビットに収まらない大きさの整数を扱おうとした場合、下の桁から精度が落ちていく現象が発生する
    
    ```tsx
    // 9007199254740992 と表示される
    console.log(9007199254740993);
    ```
    
    - 9007199254740993は2進数で表すと54桁
- 構成
    
    EEE 754倍精度（double型）は次の3つの部分で構成されています
    
    | 区分 | ビット数 | 内容 |
    | --- | --- | --- |
    | 符号部 | 1ビット | 正の数か負の数か（0=正, 1=負） |
    | 指数部 | 11ビット | 小数点の位置を決めるための指数（2の何乗か） |
    | 仮数部（mantissa, significand） | 52ビット（実質53ビット精度） | 数字の細かい部分（有効桁） |
    
    `1.10101 × 2³` だと、1.10101 の部分が 仮数部 です。
    

### BigInt(任意精度整数)

- ES2020から新しく追加された
- ポイント
    - 任意精度であるため、どれだけ大きな数でも誤差なく表すことができるが、計算速度は通常のnumberの方が早い
    - 整数のみしか扱えないため、除算の結果が小数になる場合は、整数に丸められる
    - 普通の数値型と混ぜて使用することはできない
- リテラル
    
    整数の後に`n`を書く
    
    ```tsx
    const bignum: bigint = (123n + 456n) * 2n;
    console.log(bignum);
    //=> 1158n
    ```
    

## 文字列型

### 文字列中のエスケープシーケンス

- ソースコードに直接記述しにくい文字を表現したいときに役立つ
    - `\` (バックスラッシュ)で始まる
        - バックスラッシュ自体を文字に含めるときは、`\\`と記述する
- Unicodeコードポイントを使ってかけるエスケープシーケンスもある
    - JavaScriptの文字列はUnicode(UTF-16)で表現されている
    - フォーマット
        
        `\u{コードポイント}`
        
    - Ex. 「A」U+0041(16進数で41)
        
        ```tsx
        console.log("\u{41}")
        //=> A
        ```
        

## 真偽値

### 真偽値への型変換

- 数値
    - 0とNaNがfalse。他はtrue
- BigInt
    - 0nがfalse。他はtrue
- 文字列
    - `“”`がfalse。他はtrue
- null・undefined
    - false
- オブジェクト
    - すべてtrue

## nullとundefined

筆者曰くTypeScriptの言語使用上ではundefinedの方がサポートが厚いため、nullよりも推奨とのこと

```tsx
const n: null = null
const u: undefined = undefined
```

### nullの等価演算子

- `x == null`とすると、「xがnullまたはundefinedである」という意味の比較になる
    - nullはいいが、undefinedはダメというときは厳密な等価演算子を使用する

## 型推論

- 明示的な型注釈がない場合にTypeScriptが変数の型を自動的に判断する機能

## 論理演算子

- `&&`や`||`, `!`
- 基本は真偽値に使用する
- 真偽値以外にもあらゆる型のオペランドに使用することができる
    - `!`は真偽値以外だと、オペランドを真偽値に変換した結果をさらに反転させるという挙動をする
        - オペランド - 演算子の構成要素となっている要素
        - Ex.
            - `!123` はfalse
            - `!null`はtrue
        - このことを応用して`!!式`のような書き方がされることがある。
            - `!!式`は`式`を真偽値に変換した結果と一致する
    - `&&`や`||`は、左側のオペランドを真偽値に変換した結果に応じて動作する。
        - `&&`は左側のオペランドを真偽値に変換した結果がfalseだった場合、左側を返す。対してtrueだったときは、右側を返す
            - Ex.
                
                ```tsx
                console.log("foo" && "bar")
                // => bar
                ```
                
        - `||`は左側のオペランドを真偽値に変換した結果がtrueだった場合、左側を返す。対してfalseだったときは、右側を返す
            - Ex.
                
                ```tsx
                console.log("foo" || "bar")
                // => foo
                ```
                
- `??`演算子
    - ES2020から導入
    - `x ?? y` の時、xがnullまたはundefinedの時、yを返し、それ以外の時はxを返す

### 論理代入演算子

- `&&=`や`||=,` `??=`
- ES2021から導入
- `変数 ||= 式` は、`変数 || (変数 = 式)`と同じ
    - `変数 = 変数 || 式` ではない
    - 変数を真偽値に変換して真だった時は、代入が行われない

## 制御構文

### while文におけるbreak文の使い所

- if文と組み合わせてループの終了条件を記述する
- Ex.
    
    ```bash
    while (true) {
    	if (i > 100) {
    		break;
    	}
    	sum += i;
    	i++;
    }
    ```
    
    - while文の条件式をtrueにすることで、常に真となり終了条件を持たない
    - 代わりにif文の中にbreak文を記述している
        - while文の終了条件が式では書ききれない場合に有効

### for文 構成要素の省略

- for文の中の各構成要素は省略が可能

```tsx
// 変数を初期化しない。iをあらかじめ宣言しておく必要がある
for(; i <= 100; i++)

// 条件式を省略した場合は、trueを指定したのと同じ。break文を使用することは可能
for(let i = 1; ; i++)

// 最後の最後の更新式も省略可能。
for(let i = 1; i <= 100;)

// while(true)と同様
for(;;)
```