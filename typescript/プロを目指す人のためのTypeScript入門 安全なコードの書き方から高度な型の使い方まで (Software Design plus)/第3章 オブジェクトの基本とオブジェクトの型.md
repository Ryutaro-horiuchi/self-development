## オブジェクトリテラル

### プロパティ名の種々の指定方法

- 識別子の他に文字列リテラル, 数値リテラルを使用することができる
    
    ```tsx
    const obj = {
    	"foo": 123,
    	"foo bar": -500,
    	1: "one"
    };
    
    console.log(obj.foo);
    console.log(obj["foo bar"])
    console.log(obj["1"])
    ```
    
    - 文字列リテラルだと、識別子に使用できない文字列もプロパティ名にできる
        - → 識別子でアクセスできないものは、ブラケット[] でアクセスする必要がある
- 動的なプロパティ名
    - 変数に入っている文字列をプロパティ名にすることができる
        
        ```tsx
        const propName = "foo";
        const obj = {
        	[propName]: 123
        };
        
        const messages = {
        	good: "0以上の数値",
        	bad: "負の数値"
        }
        
        const num = 2
        console.log(messages[num >= 0 ? "good" : "bad"])
        ```
        

### オブジェクトはいつ同じなのか

<aside>
💡

明示的にコピーしなければオブジェクトは同じである

</aside>

- 次のfooとbarに入っているオブジェクトは同じである
    
    ```tsx
    const foo = { num: 1234 };
    const bar = foo;
    console.log(bar.num); // 1234 と表示される
    bar.num = 0;
    console.log(foo.num); // 0 と表示される
    ```
    
- スプレッド構文を使用して明示的にコピーする
    
    ```tsx
    const foo = { num: 1234 };
    const bar = { ...foo }; // { num: 1234 } になる
    console.log(bar.num); // 1234 と表示される
    bar.num = 0;
    console.log(foo.num); // 1234 と表示される
    ```
    
    スプレッド構文は各プロパティが同じ値を持つ新しいオブジェクトを作成するときに使用される
    
- ネストしたスプレッド構文は注意
    
    ```tsx
    const foo = { obj: { num: 1234 } };
    const bar = { ...foo };
    bar.obj.num = 0;
    console.log(foo.obj.num); // 0 と表示される
    ```
    

### オブジェクトの比較

両辺が同じオブジェクトであればtrueである

```tsx
const foo = { num: 1234 };
const bar = foo;
const baz = { num: 1234 };

console.log(foo === bar); // true と表示される
console.log(foo === baz); // false と表示される
```

- プロパティが全く同じでも別々のオブジェクトの比較はfalseになる

## TypeScriptの型

### オブジェクト型の記法

```tsx
const obj: {
  foo: number;
  bar: string;
} = {
  foo: 123,
  bar: "Hello, world!"
};

// 識別子ではないプロパティ名を使用する場合
const obj: {
  "foo bar": number;
} = {
  "foo bar": 123,
};
```

### type文で型に別名をつける

- 型名を宣言する文であり、どんな型にも別名をつけられる
- type文による型名の作成は、その型名を使うより後でも構わない
- 構文
    
    ```tsx
    type 型名　= 型;
    ```
    
- Ex.  オブジェクト型の別名を定義
    
    ```tsx
    type FooBarObj = {
    	foo: number;
    	bar: string:
    };
    const obj: FooBarObj = {
    	foo: 123,
    	bar: "Hello, world!"
    };
    ```
    
- Ex. プリミティブ型の別名を定義
    
    ```tsx
    type UserId = string;
    const id: UserId = "uhyo";
    ```
    

### interface宣言でオブジェクト型を宣言する

- 型名を新規作成するtype文とは異なる方法
- type文とは違い、オブジェクト型のみ使用できる
- 構文
    
    ```tsx
    interface 型名 オブジェクト型
    ```
    
- Ex.
    
    ```tsx
    interface FooBarObj {
    	foo: number,
    	bar: string
    }
    const obj: FooBarObj = {
    	foo: 0,
    	bar: "string"
    };
    
    ```
    

### 任意のプロパティ名を許容する型(インデックスシグネチャ)

- 「どんな名前のプロパティでも受け入れる」という性質のオブジェクト型を使用することができる
- 構文 オブジェクトの中
    
    ```tsx
    [キー名: string]: 型;
    
    // 任意の名前のプロパティが型を持つ
    ```
    
- Ex.
    
    ```tsx
    type PriceData = {
     [key: string]: number;
    }
    const data: PriceData = {
      apple: 220,
    };
    
    // これはOK
    data.chicken = 250;
    
    // これはコンパイルエラー: Type '"foo"' is not assignable to type 'number'.
    data.弁当 = "foo";
    ```
    
- インデックスシグネチャに潜む罠
    - TypeScriptが保証する型安全性を破壊することができる
        
        ```tsx
        type MyObj = {[key: string]: number };
        const obj: MyObj = { foo: 123 };
        const num: number = obj.bar;
        
        console.log(num);
        // undefinedと表示される
        ```
        
        本来であれば存在しないプロパティにアクセスするのはコンパイル時点でエラーになるはずだが、シグネチャを使うことにより「どんな名前のプロパティでも受け入れる(アクセスできる)」という特性を持つため、コンパイルエラーとならず型安全性を破壊する
        
    - Mapオブジェクトで代替することを推奨


### オプショナルなプロパティの宣言

- Ex.
    
    ```tsx
    type MyObj = {
    	foo: boolean;
    	bar: boolean;
    	baz?: number;
    }
    
    const obj: MyObj = { foo: false, bar: true, };
    const obj2: MyObj = { foo: false, bar: true,baz: 1234 };
    ```
    
    - MyObjのbazはあってもなくても良いオプショナルなプロパティである

### 読み取り専用のプロパティの宣言

- Ex.
    
    ```tsx
    type MyObj = {
    	readonly foo: number,
    }
    
    const obj: MyObj = { foo: 123 };
    obj.foo = 0;
    //=> コンパイルエラー
    ```
    
    - fooは読み取り専用であるため、再代入しようとするとコンパイルエラーになる

### typeofキーワードで変数の型を得る

- `typeof 変数名`の形で、その変数が持つ型を表す
- Ex.
    
    ```tsx
    const num: number = 0;
    type T = typeof num;
    
    // fooはnumber型の変数となる
    const foo: T = 123;
    ```
    

## 部分型関係

### 部分型とは

- 2つの互換性を表す概念
- 型Sが型Tの部分型であるとは、S型の値がT型の値でもあることを指す。
    - Ex.  FooBarBaz型がFooBar型の部分型である
        
        ```tsx
        type FooBar = {
          foo: string;
          bar: number;
        }
        type FooBarBaz = {
          foo: string;
          bar: number;
          baz: boolean;
        }
        
        const obj: FooBarBaz = {
          foo: "hi",
          bar: 1,
          baz: false
        };
        const obj2: FooBar = obj;
        
        ```
        
- オブジェクト型の場合、次の条件が満たされれば部分型の関係になる
    1. Tが持つプロパティは全てSにも存在する
    2. 条件1の各プロパティについて、Sにおけるそのプロパティの型はTにおけるプロパティの型の部分型(または同じ型)である。

## 型引数を持つ型

- type文またはinterface宣言で型を作成するときに宣言する
    - 型引数はその宣言の中でだけ有効な型名として扱われる
    - 型引数を持つ型はジェネリック型と呼ばれる
    - Ex.
        - 定義
            
            ```tsx
            type User<T> = {
            	name: string;
            	child: T;
            };
            
            // 型引数は複数でも可能
            type Family<Parent, Child> = {
            	mother: Parent;
            	father: Parent;
            	child: Child;
            }
            	
            ```
            
            - `Family<Parent, Child>`型については、「同じ型のmotherとfatherプロパティを持ち、さらにchildプロパティを持つ」という構造を表しており、これはある種の抽象化である

### 型引数を持つ型を使用する

- Ex.
    
    ```tsx
    const obj: Family<number, string> = {
    	mother: 0,
    	father: 100,
    	child: "1000"
    };
    ```
    
- 型引数を持つ型を利用する際は、`< >` の中に型を書く。
- `Family<number, string>`はFamilyが持つ2つの型引数ParentとChildにそれぞれnumberとstring型を当てはめた型という意味

### 部分型関係による型引数の制約

- 型引数を宣言するときに、extendsという構文を使うことができる
- Ex.
    
    ```tsx
    type HasName = {
      name: string;
    };
    type Family<Parent extends HasName, Child extends HasName> = {
      mother: Parent;
      father: Parent;
      child: Child;
    };
    ```
    
    - Parent, Childの型引数は常に、HasName型の部分型でなければならないという制約になる

### オプショナルな型引数

- デフォルトの型引数を設定することができる
    - 設定時は使用時に型引数を省略することができる
- Ex.
    
    ```tsx
    type Animal = {
      name: string;
    }
    type Family<Parent = Animal, Child = Animal> = {
      mother: Parent;
      father: Parent;
      child: Child;
    }
    
    // 通常どおりの使い方
    type S = Family<string, string>;
    // TはFamily<Animal, Animal>と同じ
    type T = Family;
    // UはFamily<string, Animal>と同じ
    type U = Family<string>;
    ```
    

# 配列

TypeScriptでは、配列はオブジェクトの一種である。

### 配列型の記法

- 構文
    
    ```tsx
    const hoge 型[] = [..];
    const fuga Array<型> = [..];
    ```
    
- Ex.
    
    ```tsx
    const arr1: boolean[] = [false, false];
    const arr2: Array<{
    	name: string
    }> = [
    	{ name: "山田さん" },
    	{ name: "山田さん" },
    	{ name: "山田さん" }
    ];
    ```
    
    上記のように簡単な時は`T[]`、難しい時は`Array<T>`をというように使い分けする流派が存在するとのこお
    
- ユニオン型を用いた型の定義
    
    ```tsx
    const arr2: (string | number | boolean)[] = [100, "文字列", false]
    ```
    

### readonly 配列型

- 内容を書き換えられない読み取り専用配列型
- 構文:  `readonly 型[]`
- Ex.
    
    ```tsx
    const arr: readonly number[] = [1, 10, 100]
    ```
    
- 変更する必要がないオブジェクトや配列の方については、積極的にreadonlyを付与することを推奨

### タプル型

要素数が固定された配列型。

- 要素数が固定される代わりに、配列のそれぞれの要素に異なる型を定義できる
    - → 対して`number[]`のような通常の配列型は要素数を何個も持っても構わない一方で、全ての型が同じだった
- 構文
    
    ```tsx
    const hoge [型, 型] = [..];
    ```
    
    - Ex.
        
        ```tsx
        let tuple: [string, number] = ["foo", 0];
        tuple = ["aiueo", -555];
        
        const str = tuple[0]; // strはstring型
        const num = tuple[1]; // numはnumber型
        // エラー: Tuple type '[string, number]' of length '2' has no element at index '2'.
        const nothing = tuple[2];
        ```
        
- ラベル付きタプル型
    
    ```tsx
    type User = [name: string, age: number];
    
    const uhyo: User = ["uhyo", 26];
    
    console.log(uhyo[1]); // 26 と表示される
    ```
    
    - 可読性が上がるが、nameやageという名前をつけても最終的なアクセスはインデックス指定である
- 読み取り専用タプル型
    
    ```tsx
    readonly[string, number]
    ```
    
- オプショナルな要素を持つタプル型
    
    ```tsx
    [string, number, string?]
    ```
    
    - 最後のstring型の要素がなくなっても良い

# 分割代入

## オブジェクト

### 基本的なパターン

```tsx
const {foo, bar} = obj;

// 下記と同じ意味
const foo = obj.foo;
const bar = obj.bar;
```

### プロパティとは別の名前の変数を使用

```tsx
const {foo, bar: barVar, "foo bar": fooBar} = obj;

```

### ネストしたパターン

```tsx
const nested = {
	num: 123,
	obj: {
		foo: "hello"
	}
}

const { num, obj: { foo } } = nested;
```

- 注意点
    - 型注釈を与えることができない

## 配列

### 基本的なパターン

```tsx
const [first, second, third] = arr;
```

### オブジェクトパターンとの併用

- Ex. 1
    
    ```tsx
    const obj = {
    	arr: [100, 200, 300]
    }
    
    const { arr: [foo]} = obj;
    console.log(foo)
    // => 100
    ```
    
- Ex. 2
    
    ```tsx
    const arr = [{name: "hoge"}]
    const [{ name }] = arr;
    console.log(name)
    // hoge
    ```
    

## デフォルト値

- Ex.
    
    ```tsx
    type Obj = { foo?: number};
    const obj1: Obj = {};
    const obj2: Obj = { foo: -1234 };
    
    const { foo = 500 } = obj1;
    console.log(foo)
    // => 500
    const { foo: bar = 500 } = obj2;
    console.log(bar)
    // => -1234
    
    ```
    
- デフォルト値はundefinedのみに対して適用される。nullに対しては何も行われない
    - ??演算子とは挙動が異なるため注意する
    
    ```tsx
    const obj = {foo: null};
    const {foo = 500} = obj;
    console.log(foo)
    //=> null
    ```