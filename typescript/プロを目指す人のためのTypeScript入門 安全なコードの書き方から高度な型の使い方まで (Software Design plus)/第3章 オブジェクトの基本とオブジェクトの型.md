## オブジェクトリテラル

### プロパティ名の種々の指定方法

- 識別子の他に文字列リテラル, 数値リテラルを使用することができる
    
    ```tsx
    const obj = {
    	"foo": 123,
    	"foo bar": -500,
    	1: "one"
    };
    
    console.log(obj.foo);
    console.log(obj["foo bar"])
    console.log(obj["1"])
    ```
    
    - 文字列リテラルだと、識別子に使用できない文字列もプロパティ名にできる
        - → 識別子でアクセスできないものは、ブラケット[] でアクセスする必要がある
- 動的なプロパティ名
    - 変数に入っている文字列をプロパティ名にすることができる
        
        ```tsx
        const propName = "foo";
        const obj = {
        	[propName]: 123
        };
        
        const messages = {
        	good: "0以上の数値",
        	bad: "負の数値"
        }
        
        const num = 2
        console.log(messages[num >= 0 ? "good" : "bad"])
        ```
        

### オブジェクトはいつ同じなのか

<aside>
💡

明示的にコピーしなければオブジェクトは同じである

</aside>

- 次のfooとbarに入っているオブジェクトは同じである
    
    ```tsx
    const foo = { num: 1234 };
    const bar = foo;
    console.log(bar.num); // 1234 と表示される
    bar.num = 0;
    console.log(foo.num); // 0 と表示される
    ```
    
- スプレッド構文を使用して明示的にコピーする
    
    ```tsx
    const foo = { num: 1234 };
    const bar = { ...foo }; // { num: 1234 } になる
    console.log(bar.num); // 1234 と表示される
    bar.num = 0;
    console.log(foo.num); // 1234 と表示される
    ```
    
    スプレッド構文は各プロパティが同じ値を持つ新しいオブジェクトを作成するときに使用される
    
- ネストしたスプレッド構文は注意
    
    ```tsx
    const foo = { obj: { num: 1234 } };
    const bar = { ...foo };
    bar.obj.num = 0;
    console.log(foo.obj.num); // 0 と表示される
    ```
    

### オブジェクトの比較

両辺が同じオブジェクトであればtrueである

```tsx
const foo = { num: 1234 };
const bar = foo;
const baz = { num: 1234 };

console.log(foo === bar); // true と表示される
console.log(foo === baz); // false と表示される
```

- プロパティが全く同じでも別々のオブジェクトの比較はfalseになる

## TypeScriptの型

### オブジェクト型の記法

```tsx
const obj: {
  foo: number;
  bar: string;
} = {
  foo: 123,
  bar: "Hello, world!"
};

// 識別子ではないプロパティ名を使用する場合
const obj: {
  "foo bar": number;
} = {
  "foo bar": 123,
};
```

### type文で型に別名をつける

- 型名を宣言する文であり、どんな型にも別名をつけられる
- type文による型名の作成は、その型名を使うより後でも構わない
- 構文
    
    ```tsx
    type 型名　= 型;
    ```
    
- Ex.  オブジェクト型の別名を定義
    
    ```tsx
    type FooBarObj = {
    	foo: number;
    	bar: string:
    };
    const obj: FooBarObj = {
    	foo: 123,
    	bar: "Hello, world!"
    };
    ```
    
- Ex. プリミティブ型の別名を定義
    
    ```tsx
    type UserId = string;
    const id: UserId = "uhyo";
    ```
    

### interface宣言でオブジェクト型を宣言する

- 型名を新規作成するtype文とは異なる方法
- type文とは違い、オブジェクト型のみ使用できる
- 構文
    
    ```tsx
    interface 型名 オブジェクト型
    ```
    
- Ex.
    
    ```tsx
    interface FooBarObj {
    	foo: number,
    	bar: string
    }
    const obj: FooBarObj = {
    	foo: 0,
    	bar: "string"
    };
    
    ```
    

### 任意のプロパティ名を許容する型(インデックスシグネチャ)

- 「どんな名前のプロパティでも受け入れる」という性質のオブジェクト型を使用することができる
- 構文 オブジェクトの中
    
    ```tsx
    [キー名: string]: 型;
    
    // 任意の名前のプロパティが型を持つ
    ```
    
- Ex.
    
    ```tsx
    type PriceData = {
     [key: string]: number;
    }
    const data: PriceData = {
      apple: 220,
    };
    
    // これはOK
    data.chicken = 250;
    
    // これはコンパイルエラー: Type '"foo"' is not assignable to type 'number'.
    data.弁当 = "foo";
    ```
    
- インデックスシグネチャに潜む罠
    - TypeScriptが保証する型安全性を破壊することができる
        
        ```tsx
        type MyObj = {[key: string]: number };
        const obj: MyObj = { foo: 123 };
        const num: number = obj.bar;
        
        console.log(num);
        // undefinedと表示される
        ```
        
        本来であれば存在しないプロパティにアクセスするのはコンパイル時点でエラーになるはずだが、シグネチャを使うことにより「どんな名前のプロパティでも受け入れる(アクセスできる)」という特性を持つため、コンパイルエラーとならず型安全性を破壊する
        
    - Mapオブジェクトで代替することを推奨