## 非同期処理とは

- 下記いずれか、あるいはその両方を特徴として持つ
    - 裏で行われる処理
    - 時間がかかる処理

## シングルスレッドモデル・ノンブロッキング

- 時間のかかる処理をプログラムから行う場合、そのAPIはブロッキングなものとノンブロッキングなもの2種類に分かれる
    - ブロッキングな処理は、その処理が完了するまでプログラムがそこで停止する処理
        
        ↔ ノンブロッキング
        
        - JavaScript・TypeScriptでは非同期処理はノンブロッキングなものである
- JavaScript・TypeScriptでは、実行モデルとしてシングルスレッドなモデル(プログラムが並列に実行されることはない)が採用されている
    - 通信の処理中に他のことができるのは通信自体はOSがおこなっているものであり、JavaScriptがシングルスレッドというのは、あくまでアプリケーションロジックが描かれたJavaScriptプログラム部分が並列に実行されないことを指す

### 同期処理と非同期処理の順序

- 同期的に実行中のプログラムに非同期処理が割り込むことはない
- 同期的な処理が全部終了してからコールバック関数が実行される

## Promise

### Promiseの型

- Ex.
    
    ```tsx
    import { readFile } from "fs/promises";
    
    const p = readFile("foo.txt", "utf8");
    // pの型 Promise<string>
    ```
    
- Promiseオブジェクトは`Promise<T>`という型を持つ
    - 型引数を一つ持ち今回のPromise<string>は、string型の結果をもつPromiseオブジェクト

### Promiseの非同期処理タイミング

- PromiseベースのAPIの場合実際に非同期処理が始まるのはどのタイミングか？
    - 非同期処理を呼び出した瞬間に始まっており、Promiseオブジェクトが返り値として返された段階ですでに始まっている
    - Promise内部の処理は同期的に実行されており、その後の結果の処理(then, catch)は非同期的に行われる

### catch時の型

- catchに渡されたコールバック関数や、thenの第二引数に渡されたコールバック関数の引数の型は型推論だとany型である
    - 歴史的経緯からany型が使われている。unknown型の注釈をつけることを著者は推奨
    
    ```tsx
    import { readFile } from "fs/promises";
    
    const p = readFile("foo.txt", "utf8");
    
    p.then((result) => {
      console.log("成功", result);
    });
    p.catch((error) => { // errorはany型
      console.log("失敗", error);
    });
    
    // p.catch(error: unknown) => 
    ```
    

### Promiseの静的メソッド

- resolveとreject
    - 即座に成功 / 失敗するPromiseオブジェクトを作る
- race
    - Promise.allと同じPromiseの配列を受け取る
    - Promiseの配列のうち、最も早く成功または失敗したものの結果を全体の結果とする
    - タイムアウトを簡単に表現したい際に有効
        
        ```tsx
        import { readFile } from "fs/promises";
        
        const sleepReject = (duration: number) => {
          return new Promise<never>((resolve, reject) => {
            setTimeout(reject, duration);
          })
        };
        
        const p = Promise.race([
          readFile("foo.txt", "utf8"),
          sleepReject(5000)
        ]);
        
        p.then((result) => {
          console.log("成功", result);
        }, (error: unknown) => {
          console.log("失敗", error);
        })
        ```
        
        - readFileの非同期処理が5秒以内に成功すれば、sleepRejectの失敗よりも先に成功することになるため、pの結果も成功となる。反対に5秒以上かかった場合は、pの結果も失敗となる
- allSettled
    
    [全ての非同期処理が終了したところでコールバックする -allSettledメソッド](https://www.notion.so/allSettled-54aaab0b25b54dc1b1520edd57e97884?pvs=21) 
    
- any
    - Promiseの配列のうち最も早く成功した結果を全体の結果とする

### Promiseチェーン

- Promiseの特性
    - then, catch, finallyといったPromiseメソッドは、成功・失敗した時の挙動を指定する機能を持つのと同時に新しいPromiseオブジェクトを返す
    - Ex. then
        
        ```tsx
        import { readFile } from "fs/promises";
        
        const p = readFile("foo.txt", "utf8");
        
        const p2 = p.then((result) => result + result);
        // thenメソッドの戻り値もPromiseを返す
        
        p2.then((result) => { // Promiseなのでthenが使える
          console.log(result);
        });
        ```
        
    - Ex. catch
        
        ```tsx
        import { readFile } from "fs/promises";
        
        const p = readFile("foo.txt", "utf8");
        
        const p2 = p.catch(() => "");
         // pが失敗した時はcatchを使用するがその戻り値は成功したPromiseである
        
        p2.then((result) => {
          console.log(result);
        });
        ```
        
        - catchメソッドは、Promiseの失敗を成功に変換することができる
        - 成功した場合はpの結果がp2にそのまま伝播する
- Promiseチェーン
    - Ex.  catchの例をチェーンで表現
        
        ```tsx
        readFile("foo.txt", "utf8")
          .catch(() => "")
          .then((result) => {
            console.log(result);
          })
        ```
        
    

## dynamic import構文

- 指定されたモジュールを非同期的に読み込むことができる
    - そのモジュールが必要になるまでモジュールを読み込みたくない(遅延読み込みをしたい)場合にdynamic importが重宝される
    - 結果はPromiseとなる
- Ex. fs/promiseモジュール
    
    ```tsx
    import("fs/promises")
      .then(({ readFile }) =>
        readFile("foo.txt", "utf8")
      )
      .then((result) => {
        console.log(result);
      })
      .catch((error) => {
        console.log("エラーが発生しました！！！！", error);
      });
      
      
    // await
    async function main() {
    	const { readFile } = await import("fs/promises")
    	const result = await readFile("foo.txt", "utf8")
    	console.log(result)
    }
    ```
    

## async/await構文

### async関数

```tsx
async function get3(): Promise<number> {
	return 3;
}

const p = get3()
p.then(num => {
	console.log(`num is ${num}`);
});
```

- async関数の返り値は必ずPromiseになる

### async関数の色々な記法

- async function
    
    ```tsx
    const main = async function() {
      ...
    };
    ```
    
- async アロー関数式
    
    ```tsx
    const main = async () => {
      ...
    };
    ```
    

### await

Promiseの結果が出るまで待つ

- top-level await
    - 基本 await式はasync関数の中でしか使えないが、モジュールのトップレベルでもawaitの使用が可能になった