## ユニオン型の基本

- 「型T または 型U」のような表現ができる型
- 構文
    - `type Hoge = T | U` ;
- Ex.
    
    ```tsx
    type Animal = {
      species: string;
    };
    type Human = {
      name: string;
    }
    
    type User = Animal | Human;
    
    // このオブジェクトはAnimal型なのでUser型に代入可能
    const tama: User = {
      species: "Felis silvestris catus"
    }
    // このオブジェクトはHuman型なのでUser型に代入可能
    const uhyo: User = {
      name: "uhyo"
    };
    ```
    
    - 一方の型にしかないプロパティにアクセスするとコンパイルエラーになる
        
        ```tsx
        function getName(user: User): string {
        	return user.name;
          // エラー: Property 'name' does not exist on type 'User'.
          // Property 'name' does not exist on type 'Animal'.
        }
        ```
        

## インターセクション型

- 「T型でありかつU型でもある値」を意味する型
- 構文
    - `type Hoge = T & U;`
- Ex
    
    ```tsx
    type Animal = {
      species: string;
      age: number;
    }
    
    type Human = Animal & {
      name: string;
    }
    
    const tama: Animal = {
      species: "Felis silvestris catus",
      age: 3
    };
    const uhyo: Human = {
      species:  "Homo sapiens sapiens",
      age: 26,
      name: "uhyo"
    };
    ```
    
    - Human型はtype Animalとnameプロパティを持つ合成された型である

## オプショナル

### オプショナルプロパティの表現

- プロパティが「あるかもしれないしないかもしれない」という状況を表現する方法は2つある
    1. オプショナルプロパティ ? をつける
        - [オプショナルなプロパティの宣言](https://www.notion.so/29f93db05554804cb49be1d3a23c72a8?pvs=21)
        - ageを定義しなくても問題ない
    2. オプショナルプロパティを使わずにundefinedとのユニオン型をとる
        
        ```tsx
        const uhyo: Human = {
        	name: string;
        	age: number | undefined;
        };
        ```
        
        - この時ageはundefinedでも良いので、明示的にageが存在する必要がある
- tsconfig.jsonで設定できる`exactOptionalPropertyTypes`オプションが有効なときは、age?: numberのようなオプションは明示的にundefinedを代入できなくなる

### オプショナルチェイニングによるプロパティアクセス

- アクセスされるオブジェクトがnullやundefinedでもプロパティアクセスできる構文
- 構文
    - `obj?.hoge`
- Ex.
    
    ```tsx
    type Human = {
    	name: string;
    	age: number;
    }
    
    function useMaybeHuman(human: Human | undefined) {
    	const age = human?.age;
    	console.log(age)
    }
    
    // 関数呼び出し
    function useTime(getTimeFunc: GetTimeFunc | undefined) {
    	const timeOrUndefined = getTimeFunc?.();
    }
    
    // ブラケット
    obj?.["foo"]
    
    ```
    
- オプショナルチェイニングの後にメソッド呼び出しもつけられる。
    - ?.の呼び出し元のオブジェクトがnull, undefinedだった場合、その後の呼び出しはスキップされる
        - ?.から続く、まとめて飛ばされるひとまとまりの部分をオプショナルチェインと呼ばれる
    
    ```tsx
    const timeStringOrUndefined = getTimeFunc?.().toString();
    // getTimeFuncがnull(undefined)でもコンパイルエラーにならない
    ```
    

## リテラル型

- プリミティブ型をさらに細分化した型
- Ex.
    
    ```tsx
    // 文字列のリテラル型
    const foo: "foo" = "foo";
    // 数値のリテラル型
    const one: 1 = 1;
    // 真偽値のリテラル型
    const t: true = true;
    // BigIntのリテラル型
    const three: 3n = 3n;
    ```
    
    - foo型は`”foo”`という文字列しか入れることができない
- ユニオン型とリテラル型を組み合わせて使うケースが多い
    
    ```tsx
    function signNumber(type: "plus" | "minus") {
      return type === "plus" ? 1 : -1;
    }
    ```
    

### テンプレートリテラル型

- 文字列のテンプレートリテラルと同じく、バッククォートと`${}`を使用するが、`${}`に入るのは型である
- Ex.
    
    ```tsx
    function getHelloStr(): `Hello, ${string}!` {
      const rand = Math.random();
      if (rand < 0.3) {
        return "Hello, world!";
      } else if (rand < 0.6) {
        return "Hello, my world!";
      } else if (rand < 0.9) {
        // エラー: Type '"Hello, world."' is not assignable to type '`Hello, ${string}!`'.
        return "Hello, world.";
      } else {
        // エラー: Type '"Hell, world!"' is not assignable to type '`Hello, ${string}!`'.
        return "Hell, world!";
      }
    }
    ```
    
    - 文字列が特定の型であること(例では、``Hello, ${string}!``)をチェックすることができる


## 型の絞り込み

ユニオン型は、コードの中身に応じて値の持つ型情報が変化する

### 等価演算子による絞り込み

```tsx
function numberWithSign(num: number, type: SignType | "none") {
  if (type === "none") {
    // ここではtypeは"none"型ととなる
    return 0;
  } else {
    // ここではtypeはSignType型となる
    return num * signNumber(type);
  }
}
```

### typeof 演算子による絞り込み

- https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/typeof
    - typeof nullが”object”になる点だけ気を付ける

### 代数的データ型をユニオン型で表現するテクニック

- 代数的データ型
    - データの判別用の情報(タグ)を持つのが代数的データ型の特徴
        - 扱うデータの形と可能性を型で正確に表現することができる
    - TypeScriptでは、原理的にランタイムに型情報を取得することが不可能であるため、それを補うために、ランタイムに見えるデータとしてタグを付与しているとも考えられる
- Ex.
    
    ```tsx
    type Animal = {
      tag: "animal";
      species: string;
    }
    type Human = {
      tag: "human";
      name: string;
    }
    type User = Animal | Human;
    
    function getUserName(user: User) {
      if (user.tag === "human") {
        // ここではuserはHuman型
        return user.name;
      } else {
        // ここではuserはAnimal型
        return "名無し";
      }
    }
    ```
    

## lookup型

- 型情報を再利用する
- 構文
    
    ```tsx
    T[K]
    ```
    
    - TとKはどちらも何らかの型
    - Tはオブジェクト型、Kは文字列のリテラル型
- Ex.
    
    ```tsx
    type Human = {
      type: "human";
      name: string;
      age: number;
    };
    
    function setAge(human: Human, age: Human["age"]) {
      return {
        ...human,
        age
      };
    }
    
    const uhyo: Human = {
      type: "human",
      name: "uhyo",
      age: 26,
    };
    
    const uhyo2 = setAge(uhyo, 27);
    console.log(uhyo2); // { "type": "human", "name": "uhyo", "age": 27 } と表示される
    ```
    
    - 例で言うと、Human[”age”]はnumber型となっているため、setAgeのageの型は動的にnumber型が割り当てられる
    - `function setAge(…, age: number)`ともできるが、lookup型を使うのは、同じことを二度書かない(DRY)ことが主な目的となる
- 使いすぎるのは良くない
    - 一見して具体的な型がわからない
    - 例で言えば、「Humanオブジェクトのageプロパティからとった値を引数に渡してほしい」と言う意思表示がある場合のみ推奨

## keyof型

- オブジェクトのプロパティ名を全て受け入れる型を作成できる
- Ex.
    
    ```tsx
    type Human = {
      name: string;
      age: number;
    };
    
    type HumanKeys = keyof Human;
    // HumanKeysは "name" | "age" という型になる
    
    let key: HumanKeys = "name";
    key = "age";
    // エラー: Type '"hoge"' is not assignable to type 'keyof Human'.
    key = "hoge";
    ```
    
### typeofと組み合わせて動的に型を定義する

- [typeofキーワードで変数の型を得る](https://www.notion.so/typeof-2a193db0555480f29494e994888fc23b?pvs=21)
- Ex.
    
    ```tsx
    const mmConversionTable = {
      mm: 1,
      m: 1e3,
      km: 1e6,
    };
    
    function convertUnits(value: number, unit: keyof typeof mmConversionTable) {
      const mmValue = value * mmConversionTable[unit];
      return {
        mm: mmValue,
        m: mmValue / 1e3,
        km: mmValue / 1e6
      };
    }
    
    // { "mm": 5600000, "m": 5600, "km": 5.6 } と表示される
    console.log(convertUnits(5600, "m"));
    ```
    
    1. typeof mmConversionTableで、変数の型を得る
        - typeof mmConversionTable = `{ mm: number;  m: number; km: number; }` 型となる
    2. 上記に対し、keyofを使用する
        - 結果、引数unitの型は`”mm” | “m” | “km”`となる
- Ex.では、`mmConversionTable[unit]`としているが、これはunitがstring型だとコンパイルエラーになる。
    
    <aside>
    💡
    
    そのため keyof typeof 変数 はよく使われるとのこと。覚えておく
    
    </aside>
    

### number型もキーになれる

- keyofによって得られるキー名は、文字列のリテラル型以外にも数値型やsymbol型になる可能性がある
    - 実際の実行時の挙動としては、数値型は全て文字列に統一して扱われる。
    - 型の世界では、数値やsymbolがキーとして取りうる可能性があるということ

## keyof型・lookup型とジェネリクス

- keyofはジェネリクス(型変数)と組み合わせて使うことができる
- Ex.
    
    ```tsx
    function get<T, K extends keyof T>(obj: T, key: K): T[K] {
      return obj[key];
    }
    
    type Human = {
      name: string;
      age: number;
    }
    
    const uhyo: Human = {
      name: "uhyo",
      age: 26
    };
    
    // uhyoNameはstring型
    const uhyoName = get(uhyo, "name");
    // uhyoAgeはnumber型
    const uhyoAge = get(uhyo, "age");
    ```
    
    - 引数によって関数getの戻り値は変わるが、keyofとジェネリクス、lookupで動的に型を定義できている
    - K extends key of T
        - 引数obj(T)のプロパティ名を受け入れる型(`”name”,` `“age”`)とし、Kはその部分型であると定義している
    - T[K]
        - lookup型でオブジェクトTのリテラル型とすることで、動的に返却する型を定義できる

## asによる型アサーション

<aside>
💡

- 型アサーションの使用は極力避けるべき
    - TypeScriptが保証してくれる型安全性を意図的に破壊する機能であるため
    - アサーションの使用を回避できないかをまず考える
- TypeScriptの型推論がこちらの意図と異なるときに、それを補うために型アサーションを使うことができる
</aside>

### 型アサーションを用いて式の型をごまかす

- 構文
    - 式 as 型

### Ex.

- Ex. 1
    
    ```tsx
    function getFirstFiveLetters(strOrNum: string | number) {
      const str = strOrNum as string;
      return str.slice(0, 5);
    }
    
    // "uhyoh" と表示される
    console.log(getFirstFiveLetters("uhyohyohyo"));
    
    // ランタイムエラーが発生！
    console.log(getFirstFiveLetters(123));
    ```
    
- Ex. 2 正しい使い型
    
    ```tsx
    type Animal = {
      tag: "animal";
      species: string;
    }
    type Human = {
      tag: "human";
      name: string;
    }
    type User = Animal | Human;
    
    function getNamesIfAllHuman(users: readonly User[]): string[] | undefined {
      if (users.every(user => user.tag === "human")) {
        // エラー: Property 'name' does not exist on type 'User'.
        //          Property 'name' does not exist on type 'Animal'.
        return users.map(user => user.name);
      }
      return undefined;
    }
    ```
    
    - TypeScriptコンパイラはeveryメソッドの挙動を理解できず、usersの型はUser[]型であると認識しているため、コンパイルエラーが起きる
    - as を使用する
        
        ```tsx
        function getNamesIfAllHuman(users: readonly User[]): string[] | undefined {
          if (users.every(user => user.tag === "human")) {
            return (users as Human[]).map(user => user.name);
          }
          return undefined;
        }
        ```
        

### 型アサーションの古い記法

- 構文
    - <型>式
- Ex.
    
    ```tsx
    return (<Human[]>users).map(>user => user.name);
    ```
    

### !を用いてnullとundefinedを無視する

- 式がnullまたはundefinedである可能性を無視する
- 構文
    - 式!
- Ex.
    
    ```tsx
    return user2!.name
    ```

