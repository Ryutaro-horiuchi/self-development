## ユニオン型の基本

- 「型T または 型U」のような表現ができる型
- 構文
    - `type Hoge = T | U` ;
- Ex.
    
    ```tsx
    type Animal = {
      species: string;
    };
    type Human = {
      name: string;
    }
    
    type User = Animal | Human;
    
    // このオブジェクトはAnimal型なのでUser型に代入可能
    const tama: User = {
      species: "Felis silvestris catus"
    }
    // このオブジェクトはHuman型なのでUser型に代入可能
    const uhyo: User = {
      name: "uhyo"
    };
    ```
    
    - 一方の型にしかないプロパティにアクセスするとコンパイルエラーになる
        
        ```tsx
        function getName(user: User): string {
        	return user.name;
          // エラー: Property 'name' does not exist on type 'User'.
          // Property 'name' does not exist on type 'Animal'.
        }
        ```
        

## インターセクション型

- 「T型でありかつU型でもある値」を意味する型
- 構文
    - `type Hoge = T & U;`
- Ex
    
    ```tsx
    type Animal = {
      species: string;
      age: number;
    }
    
    type Human = Animal & {
      name: string;
    }
    
    const tama: Animal = {
      species: "Felis silvestris catus",
      age: 3
    };
    const uhyo: Human = {
      species:  "Homo sapiens sapiens",
      age: 26,
      name: "uhyo"
    };
    ```
    
    - Human型はtype Animalとnameプロパティを持つ合成された型である

## オプショナル

### オプショナルプロパティの表現

- プロパティが「あるかもしれないしないかもしれない」という状況を表現する方法は2つある
    1. オプショナルプロパティ ? をつける
        - [オプショナルなプロパティの宣言](https://www.notion.so/29f93db05554804cb49be1d3a23c72a8?pvs=21)
        - ageを定義しなくても問題ない
    2. オプショナルプロパティを使わずにundefinedとのユニオン型をとる
        
        ```tsx
        const uhyo: Human = {
        	name: string;
        	age: number | undefined;
        };
        ```
        
        - この時ageはundefinedでも良いので、明示的にageが存在する必要がある
- tsconfig.jsonで設定できる`exactOptionalPropertyTypes`オプションが有効なときは、age?: numberのようなオプションは明示的にundefinedを代入できなくなる

### オプショナルチェイニングによるプロパティアクセス

- アクセスされるオブジェクトがnullやundefinedでもプロパティアクセスできる構文
- 構文
    - `obj?.hoge`
- Ex.
    
    ```tsx
    type Human = {
    	name: string;
    	age: number;
    }
    
    function useMaybeHuman(human: Human | undefined) {
    	const age = human?.age;
    	console.log(age)
    }
    
    // 関数呼び出し
    function useTime(getTimeFunc: GetTimeFunc | undefined) {
    	const timeOrUndefined = getTimeFunc?.();
    }
    
    // ブラケット
    obj?.["foo"]
    
    ```
    
- オプショナルチェイニングの後にメソッド呼び出しもつけられる。
    - ?.の呼び出し元のオブジェクトがnull, undefinedだった場合、その後の呼び出しはスキップされる
        - ?.から続く、まとめて飛ばされるひとまとまりの部分をオプショナルチェインと呼ばれる
    
    ```tsx
    const timeStringOrUndefined = getTimeFunc?.().toString();
    // getTimeFuncがnull(undefined)でもコンパイルエラーにならない
    ```
    

## リテラル型

- プリミティブ型をさらに細分化した型
- Ex.
    
    ```tsx
    // 文字列のリテラル型
    const foo: "foo" = "foo";
    // 数値のリテラル型
    const one: 1 = 1;
    // 真偽値のリテラル型
    const t: true = true;
    // BigIntのリテラル型
    const three: 3n = 3n;
    ```
    
    - foo型は`”foo”`という文字列しか入れることができない
- ユニオン型とリテラル型を組み合わせて使うケースが多い
    
    ```tsx
    function signNumber(type: "plus" | "minus") {
      return type === "plus" ? 1 : -1;
    }
    ```
    

### テンプレートリテラル型

- 文字列のテンプレートリテラルと同じく、バッククォートと`${}`を使用するが、`${}`に入るのは型である
- Ex.
    
    ```tsx
    function getHelloStr(): `Hello, ${string}!` {
      const rand = Math.random();
      if (rand < 0.3) {
        return "Hello, world!";
      } else if (rand < 0.6) {
        return "Hello, my world!";
      } else if (rand < 0.9) {
        // エラー: Type '"Hello, world."' is not assignable to type '`Hello, ${string}!`'.
        return "Hello, world.";
      } else {
        // エラー: Type '"Hell, world!"' is not assignable to type '`Hello, ${string}!`'.
        return "Hell, world!";
      }
    }
    ```
    
    - 文字列が特定の型であること(例では、``Hello, ${string}!``)をチェックすることができる


## 型の絞り込み

ユニオン型は、コードの中身に応じて値の持つ型情報が変化する

### 等価演算子による絞り込み

```tsx
function numberWithSign(num: number, type: SignType | "none") {
  if (type === "none") {
    // ここではtypeは"none"型ととなる
    return 0;
  } else {
    // ここではtypeはSignType型となる
    return num * signNumber(type);
  }
}
```

### typeof 演算子による絞り込み

- https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/typeof
    - typeof nullが”object”になる点だけ気を付ける

### 代数的データ型をユニオン型で表現するテクニック

- 代数的データ型
    - データの判別用の情報(タグ)を持つのが代数的データ型の特徴
        - 扱うデータの形と可能性を型で正確に表現することができる
    - TypeScriptでは、原理的にランタイムに型情報を取得することが不可能であるため、それを補うために、ランタイムに見えるデータとしてタグを付与しているとも考えられる
- Ex.
    
    ```tsx
    type Animal = {
      tag: "animal";
      species: string;
    }
    type Human = {
      tag: "human";
      name: string;
    }
    type User = Animal | Human;
    
    function getUserName(user: User) {
      if (user.tag === "human") {
        // ここではuserはHuman型
        return user.name;
      } else {
        // ここではuserはAnimal型
        return "名無し";
      }
    }
    ```
    

## lookup型

- 型情報を再利用する
- 構文
    
    ```tsx
    T[K]
    ```
    
    - TとKはどちらも何らかの型
    - Tはオブジェクト型、Kは文字列のリテラル型
- Ex.
    
    ```tsx
    type Human = {
      type: "human";
      name: string;
      age: number;
    };
    
    function setAge(human: Human, age: Human["age"]) {
      return {
        ...human,
        age
      };
    }
    
    const uhyo: Human = {
      type: "human",
      name: "uhyo",
      age: 26,
    };
    
    const uhyo2 = setAge(uhyo, 27);
    console.log(uhyo2); // { "type": "human", "name": "uhyo", "age": 27 } と表示される
    ```
    
    - 例で言うと、Human[”age”]はnumber型となっているため、setAgeのageの型は動的にnumber型が割り当てられる
    - `function setAge(…, age: number)`ともできるが、lookup型を使うのは、同じことを二度書かない(DRY)ことが主な目的となる
- 使いすぎるのは良くない
    - 一見して具体的な型がわからない
    - 例で言えば、「Humanオブジェクトのageプロパティからとった値を引数に渡してほしい」と言う意思表示がある場合のみ推奨

## keyof型

- オブジェクトのプロパティ名を全て受け入れる型を作成できる
- Ex.
    
    ```tsx
    type Human = {
      name: string;
      age: number;
    };
    
    type HumanKeys = keyof Human;
    // HumanKeysは "name" | "age" という型になる
    
    let key: HumanKeys = "name";
    key = "age";
    // エラー: Type '"hoge"' is not assignable to type 'keyof Human'.
    key = "hoge";
    ```
    
### typeofと組み合わせて動的に型を定義する

- [typeofキーワードで変数の型を得る](https://www.notion.so/typeof-2a193db0555480f29494e994888fc23b?pvs=21)
- Ex.
    
    ```tsx
    const mmConversionTable = {
      mm: 1,
      m: 1e3,
      km: 1e6,
    };
    
    function convertUnits(value: number, unit: keyof typeof mmConversionTable) {
      const mmValue = value * mmConversionTable[unit];
      return {
        mm: mmValue,
        m: mmValue / 1e3,
        km: mmValue / 1e6
      };
    }
    
    // { "mm": 5600000, "m": 5600, "km": 5.6 } と表示される
    console.log(convertUnits(5600, "m"));
    ```
    
    1. typeof mmConversionTableで、変数の型を得る
        - typeof mmConversionTable = `{ mm: number;  m: number; km: number; }` 型となる
    2. 上記に対し、keyofを使用する
        - 結果、引数unitの型は`”mm” | “m” | “km”`となる
- Ex.では、`mmConversionTable[unit]`としているが、これはunitがstring型だとコンパイルエラーになる。
    
    <aside>
    💡
    
    そのため keyof typeof 変数 はよく使われるとのこと。覚えておく
    
    </aside>
    

### number型もキーになれる

- keyofによって得られるキー名は、文字列のリテラル型以外にも数値型やsymbol型になる可能性がある
    - 実際の実行時の挙動としては、数値型は全て文字列に統一して扱われる。
    - 型の世界では、数値やsymbolがキーとして取りうる可能性があるということ

## keyof型・lookup型とジェネリクス

- keyofはジェネリクス(型変数)と組み合わせて使うことができる
- Ex.
    
    ```tsx
    function get<T, K extends keyof T>(obj: T, key: K): T[K] {
      return obj[key];
    }
    
    type Human = {
      name: string;
      age: number;
    }
    
    const uhyo: Human = {
      name: "uhyo",
      age: 26
    };
    
    // uhyoNameはstring型
    const uhyoName = get(uhyo, "name");
    // uhyoAgeはnumber型
    const uhyoAge = get(uhyo, "age");
    ```
    
    - 引数によって関数getの戻り値は変わるが、keyofとジェネリクス、lookupで動的に型を定義できている
    - K extends key of T
        - 引数obj(T)のプロパティ名を受け入れる型(`”name”,` `“age”`)とし、Kはその部分型であると定義している
    - T[K]
        - lookup型でオブジェクトTのリテラル型とすることで、動的に返却する型を定義できる

## asによる型アサーション

<aside>
💡

- 型アサーションの使用は極力避けるべき
    - TypeScriptが保証してくれる型安全性を意図的に破壊する機能であるため
    - アサーションの使用を回避できないかをまず考える
- TypeScriptの型推論がこちらの意図と異なるときに、それを補うために型アサーションを使うことができる
</aside>

### 型アサーションを用いて式の型をごまかす

- 構文
    - 式 as 型

### Ex.

- Ex. 1
    
    ```tsx
    function getFirstFiveLetters(strOrNum: string | number) {
      const str = strOrNum as string;
      return str.slice(0, 5);
    }
    
    // "uhyoh" と表示される
    console.log(getFirstFiveLetters("uhyohyohyo"));
    
    // ランタイムエラーが発生！
    console.log(getFirstFiveLetters(123));
    ```
    
- Ex. 2 正しい使い型
    
    ```tsx
    type Animal = {
      tag: "animal";
      species: string;
    }
    type Human = {
      tag: "human";
      name: string;
    }
    type User = Animal | Human;
    
    function getNamesIfAllHuman(users: readonly User[]): string[] | undefined {
      if (users.every(user => user.tag === "human")) {
        // エラー: Property 'name' does not exist on type 'User'.
        //          Property 'name' does not exist on type 'Animal'.
        return users.map(user => user.name);
      }
      return undefined;
    }
    ```
    
    - TypeScriptコンパイラはeveryメソッドの挙動を理解できず、usersの型はUser[]型であると認識しているため、コンパイルエラーが起きる
    - as を使用する
        
        ```tsx
        function getNamesIfAllHuman(users: readonly User[]): string[] | undefined {
          if (users.every(user => user.tag === "human")) {
            return (users as Human[]).map(user => user.name);
          }
          return undefined;
        }
        ```
        

### 型アサーションの古い記法

- 構文
    - <型>式
- Ex.
    
    ```tsx
    return (<Human[]>users).map(>user => user.name);
    ```
    

### !を用いてnullとundefinedを無視する

- 式がnullまたはundefinedである可能性を無視する
- 構文
    - 式!
- Ex.
    
    ```tsx
    return user2!.name
    ```

## as constの用法

- `as 型`とは違い、適切に使えばプログラムの安全性を向上させてくれる
- 構文
    - 式 as const
- 効果
    
    <aside>
    💡
    
    基本的には as constが付けられた式に登場する各種リテラルを変えられないものと理解する
    
    </aside>
    
    1. 配列リテラルの型推論結果を配列型ではなくタプル型にする。
        1. [タプル型](https://www.notion.so/2a193db05554807e94d1f740a0fe528a?pvs=21) 
    2. オブジェクトリテラルから推論されるオブジェクト型は全てのプロパティがreadonlyになる。配列リテラルから推論されるタプル型もreadonlyタプル型になる。
    3. 文字列・数値・Bignt・真値リテラルに対してつけられるリテラル型がwideningしないリテラル型になる。
    4. テンプレート文字列リテラルの型がstringではなくテンプレートリテラル型になる。
- Ex.
    - Ex.1
        
        ```tsx
        const names1 = ["uhyo", "John", "Taro"];
        // string[]型
        
        const names2 = ["uhyo", "John", "Taro"] as const;
        // readonly ["uhyo", "John", "Taro"] 型
        ```
        
        - names2は各種リテラルを変えられない
            
            → タプル型で要素の数を固定
            
            → 読み取り専用とし、wideningしないリテラル型
            
    - Ex.2 Lookup型とtypeofキーワードとの組み合わせ
        
        ```tsx
        const names = ["uhyo", "John", "Taro"] as const;
        
        type Name = (typeof names)[number];
        // type Name = "uhyo" | "John" | "Taro"
        ```
        
        → 多くの場合は先に型を定義しておいて、それに準拠するように値を用意するが、as constを使用すると、値から型を定義することができる
        

## any型とunknown型

### any型

<aside>
⚠️

型安全性を破壊する機能であり、とにかく避けるべき

</aside>

- 型チェックを無効にする型
    - any型の変数に何かを代入することや、any型の値を他の型の変数に代入することに対してもコンパイルエラーは発生しない
- Ex.
    
    ```tsx
    function doWhatever(obj: any) {
      // 好きなプロパティにアクセスできる
      console.log(obj.user.name);
      
      // 関数呼び出しもできる
      obj();
      
      // 計算もできる
      const result = obj * 10;
      return result;
    }
    ```
    
    上記のようにany型のobjに何をしてもコンパイルエラーは発生しない
    
    ```tsx
    doWhatever(3);
    doWhatever({
      user: {
        name: "uhyo"
      }
    });
    doWhatever(()=> {
      console.log("hi");
    });
    ```
    
    全部コンパイルエラーが発生しないがランタイムエラーになる
    
    ```tsx
    function useNumber(num: number) {
      console.log(num);
    }
    
    function doWhatever(obj: any) {
      // string型の変数に入れられる
      const str: string = obj;
     
      // number型を要求する関数に渡せる
      useNumber(obj);
    }
    ```
    
    string型の変数に代入することも可能であり、どの型の引数でも渡すことができる
    

### unknown型

- 何でも入れられる型ではあるがany型とは違い、「中に何が入っているか不明である」と言う性質に則ったチェックをしてくれる
- Ex.
    
    ```tsx
    function useUnknown(val: unknown) {
      if (typeof val === "string") {
        // 型の絞り込みによりここではvalはstring型
        console.log("valは文字列です");
        console.log(val.slice(0, 5));
      } else {
        console.log("valは文字列以外の何かです");
        console.log(val);
      }
    }
    
    useUnknown("foobar");
    useUnknown(null);
    ```
    
    - 型の絞り込みをうまく活用してunknown型を使用する

## object型とnever型

### object型

- 「オブジェクトのみ」に制限したい場合に使用する
    - `{}`型は、nullとundefined型以外は全ての値が代入可能であるため、数値型や文字列型も代入できてしまう
- 単体では使用しづらい
    - 何のプロパティを持っているかが不明であるため、使えない
- 使い所の例
    
    ```tsx
    // toStringを持つ値の型
    type HasToString = {
      toString: () => string
    }
    
    function useToString1(value: HasToString) {
      console.log(`value is ${value.toString()}`);
    }
    
    // "value is foo!" と表示される
    useToString1({
      toString() {
        return "foo!";
      }
    });
    
    // "value is 3.14" と表示される
    useToString1(3.14);
    ```
    
    toStringというメソッドは数値型でも所有しているため、`useToString1`は数値も渡せてしまう。
    
    ```tsx
    function useToString2(value: HasToString & object) {
      console.log(`value is ${value.toString()}`);
    }
    
    // "value is foo!" と表示される
    useToString2({
      toString() {
        return "foo!";
      }
    });
    
    // エラー: Argument of type 'number' is not assignable to parameter of type 'HasToString & object'.
    //          Type 'number' is not assignable to type 'object'.
    useToString2(3.14);
    ```
    
    インターセクション型と組み合わせてobject型を使用することで、数値型を受け入れないようにすることができる
    

### never型

- 「当てはまる値が存在しない」という性質を持つ型
    - never型を受け取る関数を作った場合、その関数を呼び出すことは不可能。一方でnever型の値を入手した場合、never型は他の値に代入することができる
        - never型に当てはまる値が存在しない → 実行されることはないため、他の値に代入しようが コンパイルエラーを発生させない
- 例外をスローする関数では、戻り値をnever型に指定することはできる

## 型述語(ユーザー定義型ガード)

- 型の絞り込みを自由に行うための仕組み
    - 複雑な条件をかくとTypeScriptコンパイラが理解できる範囲を超えてしまい、自動で型の絞り込みをしてくれなくなってしまう
- any型やasと同じく型安全性を破壊する恐れのある機能の一つではあるが、取り回しが良く選択の一つとして検討しても良い
    - 可能な局面では、any型やasよりもユーザー定義型ガードを優先すべき
        - ユーザー定義型ガードを使用した関数のみに責任を持てば良い
        - 対してany型は、any型を使用している全てで問題がないことを確認しなくてはならない
- 注意点
    - 関数の実装が型述語に書かれている通りの絞り込みを行っているかどうかのチェックはTypeScriptは行なってくれない
- 構文は二つある
    
    ### 構文1  `引数名 is 型`
    
    - 返り値がbooleanであり真であれば、`引数名`に与えられた値が`型`と言う形の構文
    - Ex.
    
    ```tsx
    function isStringOrNumber(value: unknown): value is string | number {
      return typeof value === "string" || typeof value === "number";
    }
    
    const something: unknown = 123;
    
    if (isStringOrNumber(something)) {
      // ここではsomethingは string | number 型
      console.log(something.toString());
    }
    ```
    
    ### 構文2 `asserts 引数名 is 型`
    
    - 実際の返り値の型がvoid型である
        - 関数が無事に終了すれば、`引数名`は`型`である。例外であれば`引数名`は`型`ではないとなる
    
    ```tsx
    function assertHuman(value: any): asserts value is Human {
      // プロパティアクセスできない可能性を排除
      if (value == null) {
        throw new Error('Given value is null or undefined');
      }
      // 3つのプロパティの型を判定
      if (
        value.type !== "Human" ||
        typeof value.name !== "string" ||
        typeof value.age !== "number"
      ) {
        throw new Error('Given value is not a Human');
      }
    }
    
    function checkAndUseHuman(value: unknown) {
      assertHuman(value);
     
      // ここから下ではvalueがHuman型になる
      const name = value.name;
      // （略）
    }
    ```
    

## 可変長タプル型

- 構文
    - タプル型([タプル型](https://www.notion.so/2a193db05554807e94d1f740a0fe528a?pvs=21))の中に、`…T`
    
    というスプレット構文のような要素を含んだ形の型
    
    - `…配列型`が基本形
- Ex.
    
    ```tsx
    type NumberAndStrings = [number, ...string[]];
    
    const arr1: NumberAndStrings = [25, "uhyo", "hyo", "hyo"];
    const arr2: NumberAndStrings = [25];
    ```
    
    NumberAndStringsは、最初の要素がnumber型で、それ以降が任意個のstringという配列型になる
    

## mapped types

- 構文
    
    ```tsx
    { [P in K]: T}
    ```
    
    - Pはこの構文内で定義された新たな型変数であり、Tの中で使用することができる
    - Kはプロパティ名になれる型(string | number | symbol)である必要がある
- Ex.1 簡単な例
    
    ```tsx
    type Fruit = "apple" | "orange" | "strawberry";
    
    // FruitNumbers は {
    //     apple: number;
    //     orange: number;
    //     strawberry: number;
    // } 型
    type FruitNumbers = {
      [P in Fruit]: number
    };
    
    const numbers: FruitNumbers = {
      apple: 3,
      orange: 10,
      strawberry: 20
    };
    ```
    
    - FruitNumber型は、Fruitの各構成要素Pに対して、Pというプロパティが型numberを持つようなオブジェクト型
- Ex.2 複雑な例 PをTの中で使用
    
    ```tsx
    type Fruit = "apple" | "orange" | "strawberry";
    
    // FruitArrays は {
    //     apple: "apple"[];
    //     orange: "orange"[];
    //     strawberry: "strawberry"[];
    // } 型
    type FruitArrays = {
      [P in Fruit]: P[]
    };
    
    const numbers: FruitArrays = {
      apple: ["apple", "apple"],
      orange: ["orange", "orange", "orange"],
      strawberry: []
    };
    ```
    

## conditional types

- 型の条件分岐を行うための型
- 構文
    
    ```tsx
    X extends Y ? S : T
    ```
    
    - X, Y, S, Tは全て何らかの型
- Ex.
    
    ```tsx
    type RestArgs<M> = M extends "string" ? [string, string] : [number, number, number];
    
    function func<M extends "string" | "number">(
      mode: M,
      ...args: RestArgs<M>
    ) {
      console.log(mode, ...args);
    }
    
    // これらの呼び出しはOK
    func("string", "uhyo", "hyo");
    func("number", 1, 2, 3)
    
    // こちらはコンパイルエラー
    // エラー: Argument of type 'number' is not assignable to parameter of type 'string'.
    func("string", 1, 2);
    // エラー: Expected 4 arguments, but got 3.
    func("number", "uhyo", "hyo")
    ```
    
    - Mが”string”かどうかに応じて異なる型になる

## 組み込みの型を使いこなす

裏でmapped typesやconditional typesが使われている組み込みの型

- Readonly<T>
    - Tに与えられたオブジェクト型の全てのプロパティを読み取り専用にする
- Partial<T>
    - Tの全てのプロパティをオプショナルにした型
- Pick<T,K>
    - Tというオブジェクト型のうちKで指定した名前のプロパティのみを残したオブジェクト型
    - ↔ Omit<T,K>
        - Kで指定されたプロパティを除いたオブジェクト型
- Extract<T, U>
    - Tの構成要素のうち、Uの部分がであるもののみを抜き出した新しいユニオン型
    - ↔ Exclude<T, U>
        - Tの構成要素のうちUの部分がであるもののみを除いた新しいユニオン型
- NonNullable<T>
    - Tからnullとundefinedを除いた型