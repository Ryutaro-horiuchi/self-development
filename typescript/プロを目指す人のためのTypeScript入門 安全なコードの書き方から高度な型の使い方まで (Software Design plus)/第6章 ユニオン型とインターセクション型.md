## ユニオン型の基本

- 「型T または 型U」のような表現ができる型
- 構文
    - `type Hoge = T | U` ;
- Ex.
    
    ```tsx
    type Animal = {
      species: string;
    };
    type Human = {
      name: string;
    }
    
    type User = Animal | Human;
    
    // このオブジェクトはAnimal型なのでUser型に代入可能
    const tama: User = {
      species: "Felis silvestris catus"
    }
    // このオブジェクトはHuman型なのでUser型に代入可能
    const uhyo: User = {
      name: "uhyo"
    };
    ```
    
    - 一方の型にしかないプロパティにアクセスするとコンパイルエラーになる
        
        ```tsx
        function getName(user: User): string {
        	return user.name;
          // エラー: Property 'name' does not exist on type 'User'.
          // Property 'name' does not exist on type 'Animal'.
        }
        ```
        

## インターセクション型

- 「T型でありかつU型でもある値」を意味する型
- 構文
    - `type Hoge = T & U;`
- Ex
    
    ```tsx
    type Animal = {
      species: string;
      age: number;
    }
    
    type Human = Animal & {
      name: string;
    }
    
    const tama: Animal = {
      species: "Felis silvestris catus",
      age: 3
    };
    const uhyo: Human = {
      species:  "Homo sapiens sapiens",
      age: 26,
      name: "uhyo"
    };
    ```
    
    - Human型はtype Animalとnameプロパティを持つ合成された型である

## オプショナル

### オプショナルプロパティの表現

- プロパティが「あるかもしれないしないかもしれない」という状況を表現する方法は2つある
    1. オプショナルプロパティ ? をつける
        - [オプショナルなプロパティの宣言](https://www.notion.so/29f93db05554804cb49be1d3a23c72a8?pvs=21)
        - ageを定義しなくても問題ない
    2. オプショナルプロパティを使わずにundefinedとのユニオン型をとる
        
        ```tsx
        const uhyo: Human = {
        	name: string;
        	age: number | undefined;
        };
        ```
        
        - この時ageはundefinedでも良いので、明示的にageが存在する必要がある
- tsconfig.jsonで設定できる`exactOptionalPropertyTypes`オプションが有効なときは、age?: numberのようなオプションは明示的にundefinedを代入できなくなる

### オプショナルチェイニングによるプロパティアクセス

- アクセスされるオブジェクトがnullやundefinedでもプロパティアクセスできる構文
- 構文
    - `obj?.hoge`
- Ex.
    
    ```tsx
    type Human = {
    	name: string;
    	age: number;
    }
    
    function useMaybeHuman(human: Human | undefined) {
    	const age = human?.age;
    	console.log(age)
    }
    
    // 関数呼び出し
    function useTime(getTimeFunc: GetTimeFunc | undefined) {
    	const timeOrUndefined = getTimeFunc?.();
    }
    
    // ブラケット
    obj?.["foo"]
    
    ```
    
- オプショナルチェイニングの後にメソッド呼び出しもつけられる。
    - ?.の呼び出し元のオブジェクトがnull, undefinedだった場合、その後の呼び出しはスキップされる
        - ?.から続く、まとめて飛ばされるひとまとまりの部分をオプショナルチェインと呼ばれる
    
    ```tsx
    const timeStringOrUndefined = getTimeFunc?.().toString();
    // getTimeFuncがnull(undefined)でもコンパイルエラーにならない
    ```
    

## リテラル型

- プリミティブ型をさらに細分化した型
- Ex.
    
    ```tsx
    // 文字列のリテラル型
    const foo: "foo" = "foo";
    // 数値のリテラル型
    const one: 1 = 1;
    // 真偽値のリテラル型
    const t: true = true;
    // BigIntのリテラル型
    const three: 3n = 3n;
    ```
    
    - foo型は`”foo”`という文字列しか入れることができない
- ユニオン型とリテラル型を組み合わせて使うケースが多い
    
    ```tsx
    function signNumber(type: "plus" | "minus") {
      return type === "plus" ? 1 : -1;
    }
    ```
    

### テンプレートリテラル型

- 文字列のテンプレートリテラルと同じく、バッククォートと`${}`を使用するが、`${}`に入るのは型である
- Ex.
    
    ```tsx
    function getHelloStr(): `Hello, ${string}!` {
      const rand = Math.random();
      if (rand < 0.3) {
        return "Hello, world!";
      } else if (rand < 0.6) {
        return "Hello, my world!";
      } else if (rand < 0.9) {
        // エラー: Type '"Hello, world."' is not assignable to type '`Hello, ${string}!`'.
        return "Hello, world.";
      } else {
        // エラー: Type '"Hell, world!"' is not assignable to type '`Hello, ${string}!`'.
        return "Hell, world!";
      }
    }
    ```
    
    - 文字列が特定の型であること(例では、``Hello, ${string}!``)をチェックすることができる